[
["index.html", "Data Integration, Manipulation and Visualization of Phylogenetic Trees Preface", " Data Integration, Manipulation and Visualization of Phylogenetic Trees Guangchuang Yu Preface You can’t even begin to understand biology, you can’t understand life, unless you understand what it’s all there for, how it arose - and that means evolution. — Richard Dawkins The book is meant as a guide for data integration, manipulation and visualization of phylogenetic trees using a suite of R packages, tidytree, treeio and ggtree. If you use the software suite in published research, please cite the most appropriate paper(s) from this list: G Yu*, TTY Lam, H Zhu, Y Guan*. Two methods for mapping and visualizing associated data on phylogeny using ggtree. Molecular Biology and Evolution, 2018, 35(2):3041-3043. doi: 10.1093/molbev/msy194. G Yu, DK Smith, H Zhu, Y Guan, TTY Lam*. ggtree: an R package for visualization and annotation of phylogenetic trees with their covariates and other associated data. Methods in Ecology and Evolution. 2017, 8(1):28-36. doi: 10.1111/2041-210X.12628. The book’s source code is hosted on GitHub, at https://github.com/YuLab-SMU/treedata-book. If you notice typos or other issues, feel free to open an issue on GitHub or send me a pull request. If you do the latter, in your commit message, please add the sentence “I assign the copyright of this contribution to Guangchuang Yu,” so that I can maintain the option of publishing this book in other forms. This work is licensed under the Attribution-NonCommercial-NoDerivatives 4.0 International License. "],
["chapter1.html", "Chapter 1 Importing Tree with Data 1.1 Overview of Phylogenetic Tree Construction 1.2 Phylogenetic Tree Formats 1.3 Getting Tree Data with treeio 1.4 Summary", " Chapter 1 Importing Tree with Data 1.1 Overview of Phylogenetic Tree Construction Phylogenetic trees are used to describe genealogical relationships among a group of organisms, which can be constructed based on the genetic sequences of the organisms. A rooted phylogenetic tree represents a model of evolutionary history depicted by ancestor-descendant relationships between tree nodes and clustering of ‘sister’ or ‘cousin’ organisms at different level of relatedness, as illustrated in Figure 1.1. In infectious disease research, phylogenetic trees are usually built from the pathogens’ gene or genome sequences to show which pathogen sample is genetically closer to a pathogen sample, providing insights into the underlying unobserved epidemiologic linkage and potential source of an outbreak. Figure 1.1: Components of a phylogenetic tree. External nodes (green circles), also called ‘tips’, represent actual organisms sampled and sequenced (e.g., virus in infectious disease research). They are the ‘taxa’ in the terminology of evolutionary biology. The internal nodes (blue circles) represent hypothetical ancestors for the tips. The root (red circle) is the common ancestor of all species in the tree. The horizontal lines are branches and represent evolutionary changes (grey number) measured in unit of time or genetic divergence. The bar at the bottom provides the scale of these branch lengths. Phylogenetic tree can be constructed from genetic sequences using distance-based methods or character-based methods. Distance-based methods, including unweighted pair group method with arithmetic means (UPGMA) and Neighbor-joining (NJ), are based on the matrix of pairwise genetic distances calculated between sequences. The character-based methods, including maximum parsimony (MP) (Fitch 1971), maximum likelihood (ML) (Felsenstein 1981), and Bayesian Markov Chain Monte Carlo (BMCMC) method (Rannala and Yang 1996), are based on mathematical model that describes the evolution of genetic characters and search for the best phylogenetic tree according to their own optimality criteria. Maximum Parsimony (MP) method assumes that the evolutionary change is rare and minimizes the amount of character-state changes (e.g., number of DNA substitutions). The criterion is similar to Occam’s razor, that the simplest hypothesis that can explains the data is the best hypothesis. Unweighted parsimony assumes mutations across different characters (nucleotides or amino acids) are equally likely while weighted method assume unequal likely of mutations (e.g., the third codon position is more liable than other codon positions; and the transition mutations have higher frequency than transversion). The concept of MP method is straightforward and intuitive, which is a probable reason for its popularity amongst biologists who care more about the research question rather than the computational details of the analysis. However, this method has a number of disadvantages, which in particular the tree inference can be biased by the well-known systematic error called long-branch attraction (LBA) that incorrectly infer distantly related lineages as closely related (Felsenstein 1978). This is because MP method poorly takes into consideration of many sequence evolution factors (e.g., reversals and convergence) that are hardly observable from the existing genetic data. Maximum likelihood (ML) method and Bayesian Markov Chain Monte Carlo (BMCMC) method are the two most commonly used methods in phylogenetic tree construction and are most often used in scientific publications. ML and BMCMC methods require a substitution model of sequence evolution. Different sequence data have different substitution models to formulate the evolutionary process of DNA, codon and amino acid. There are several models for nucleotide substitution, including JC69, K2P, F81, HKY and GTR (Arenas 2015). These models can be used in conjunction with the rate variation across sites (denoted as +\\(\\Gamma\\))) (Yang 1994) and the proportion of invariable sites (denoted as +I) (Shoemaker and Fitch 1989). Previous research (Lemmon and Moriarty 2004) had suggested that misspecification of substitution model might bias phylogenetic inference. Procedural testing for the best-fit substitution model is recommended. The optimal criterion of ML method is to find the tree that maximizes the likelihood given the sequence data. The procedure of ML method is simple: calculating the likelihood of a tree and optimizing its topology and branches (and the substitution model parameters, if not fixed) until the best tree is found. Heuristic search such as those implemented in PhyML and RAxML, is often used to find the best tree based on the likelihood criterion. Bayesian method finds the tree that maximizes posterior probability by sampling trees through MCMC based on the given substitution model. One of the advantage of BMCMC is that parameter variance and tree topological uncertainty, included by the posterior clade probability, can be naturally and conveniently obtained from the sampling trees in MCMC process. Moreover, influence of topological uncertainty to other parameter estimates are also naturally integrated in the BMCMC phylogenetic framework. In a simple phylogenetic tree, data associated with the tree branches/nodes could be the branch lengths (indicating genetic or time divergence) and lineage supports such as bootstrap values estimated from bootstrapping procedure or posterior clade probability summarized from the sampled trees in the BMCMC analysis. 1.2 Phylogenetic Tree Formats There are several file formats designed to store phylogenetic trees and the data associated with the nodes and branches. The three commonly used formats are Newick1, NEXUS (Maddison et al. 1997) and Phylip (Felsenstein 1989). Some formats (e.g., NHX) are extended from Newick format. Newick and NEXUS formats are supported as input by most of the software in evolutionary biology, while some of the software tools output newer standard files (e.g., BEAST and MrBayes) by introducing new rules/data blocks for storing evolutionary inferences. On the other cases (e.g., PAML and r8s), output log files are only recognized by their own single software. 1.2.1 Newick tree format The Newick tree format is the standard for representing trees in computer-readable form. Figure 1.2: A sample tree for demonstrating Newick text to encode tree structure. Tips were aligned to right hand side and branch lengths were labelled on the middle of each branch. The rooted tree shown in Figure 1.2 can be represented by the following sequence of characters as a newick tree text. ((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59); The tree text ends with semicolon. Internal nodes are represented by a pair of matched parentheses. Between the parentheses are descendant nodes of that node. For instance (t4:0.59, t1:0.37) represents the parent node of t4 and t1 that are the immediate descendants. Sibling nodes are separated by comma and tips are represented by their names. A branch length (from parent node to child node) is represented by a real number after the child node and preceded by a colon. Singular data (e.g., bootstrap values) associated with internal nodes or branches maybe encoded as node label and represented by the simple text/numbers before the colon. Newick tree format was developed by Meacham in 1984 for the PHYLIP (Retief 2000) package. Newick format is now the most widely used tree format and used by PHYLIP, PAUP* (Wilgenbusch and Swofford 2003), TREE-PUZZLE (Schmidt et al. 2002), MrBayes and many other applications. Phylip tree format contains Phylip multiple sequence alignment (MSA) with a corresponding Newick tree text that was built based on the MSA sequences in the same file. 1.2.2 NEXUS tree format The NEXUS format incorporates Newick tree text with related information organized into separated units known as blocks. A NEXUS block has the following structure: #NEXUS ... BEGIN characters; ... END; For example, the above example tree can be saved as a following NEXUS format: #NEXUS [R-package APE, Wed Nov 9 11:46:32 2016] BEGIN TAXA; DIMENSIONS NTAX = 5; TAXLABELS t5 t4 t1 t2 t3 ; END; BEGIN TREES; TRANSLATE 1 t5, 2 t4, 3 t1, 4 t2, 5 t3 ; TREE * UNTITLED = [&amp;R] (1:0.89,((2:0.59,3:0.37):0.34, (4:0.03,5:0.67):0.9):0.04); END; Comments can be placed by using square brackets. Some blocks can be recognized by most of the programs including TAXA (contains information of taxa), DATA (contains data matrix, e.g., sequence alignment) and TREE (contains phylogenetic tree, i.e., Newick tree text). Notably, blocks can be very diversed and some of them are only be recognized by one particular program. For example NEXUS file exported by PAUP* has a paup block which contains PAUP* commands, whereas FigTree exports NEXUS file with a figtree block that contains visualization settings. NEXUS organizes different types of data into different blocks, whereas programs that support reading NEXUS can parse some blocks they recognized and ignore those they could not. This is a good mechanism to allow different programs to use the same format without crashing when unsupported types of data are present. Notably most of the programs only support parsing TAXA, DATA and TREE blocks, therefore a program/platform that could generically read all kinds of data blocks from the NEXUS would be useful for phylogenetic data integration. The DATA block is widely used to store sequence alignment. For this purpose, user can store tree and sequence data in Phylip format which are essentially Phylip multiple sequence alignment and Newick tree text respectively. It is used in Phylogeny Inference Package (PHYLIP). 1.2.3 New Hampshire eXtended format Newick, NEXUS and phylip are mainly designed to store phylogenetic tree and basic singular data associated with internal nodes or branches. In addition to the singular data annotation at branches and nodes (mentioned above), New Hampshire eXtended format (NHX), which is based on Newick (also called New Hampshire), was developed to introduce tags to associate multiple data fields with the tree nodes (both internal nodes and tips). Tags are placed after branch length and must be wrapped between [&amp;&amp;NHX and ] which makes it possible to compatible with NEXUS format as it defined characters between [ and ] as comments. NHX is also the output format of PHYLDOG (Boussau et al. 2013) and RevBayes (Höhna et al. 2016). A Tree Viewer (ATV) (Zmasek and Eddy 2001) is a java tool that supports displaying annotation data stored in NHX format, but this package is no more maintained. Here is a sample tree from NHX definition document2: (((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]):0.05[&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY:0.1[&amp;&amp;NHX:S=nematode],ADHX:0.12[&amp;&amp;NHX:S=insect]):0.1[&amp;&amp;NHX:S=metazoa:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast],ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast],ADH1:0.11[&amp;&amp;NHX:S=yeast]):0.1[&amp;&amp;NHX:S=Fungi]) [&amp;&amp;NHX:D=N]; 1.2.4 Jplace format In order to store the NGS short reads mapped onto a phylogenetic tree (for the purpose of metagenomic classification), Matsen proposed jplace format for such phylogenetic placements (Matsen et al. 2012). Jplace format is based on JSON and contains four keys: tree, fields, placements, metadata and version. The tree value contains tree text extended from Newick tree format by putting the edge label in brackets (if available) after branch length and putting the edge number in curly braces after edge label. The fields value contains header information of placement data. The value of placements is a list of pqueries. Each pquery contains two keys: p for placements and n for name or nm for names with multiplicity. The value of p is a list of placement for that pqueries. Here is a jplace sample file: { &quot;tree&quot;: &quot;(((((((A:4{1},B:4{2}):6{3},C:5{4}):8{5},D:6{6}): 3{7},E:21{8}):10{9},((F:4{10},G:12{11}):14{12},H:8{13}): 13{14}):13{15},((I:5{16},J:2{17}):30{18},(K:11{19}, L:11{20}):2{21}):17{22}):4{23},M:56{24});&quot;, &quot;placements&quot;: [ {&quot;p&quot;:[24, -61371.300778, 0.333344, 0.000003, 0.003887], &quot;n&quot;:[&quot;AA&quot;] }, {&quot;p&quot;:[[1, -61312.210786, 0.333335, 0.000001, 0.000003], [2, -61322.210823, 0.333322, 0.000003, 0.000003], [3, -61352.210823, 0.333322, 0.000961, 0.000003]], &quot;n&quot;:[&quot;BB&quot;] }, {&quot;p&quot;:[[8, -61312.229128, 0.200011, 0.000001, 0.000003], [9, -61322.229179, 0.200000, 0.000003, 0.000003], [10, -61342.229223, 0.199992, 0.000003, 0.000003]], &quot;n&quot;:[&quot;CC&quot;] } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;a jplace sample file&quot;}, &quot;version&quot; : 2, &quot;fields&quot;: [&quot;edge_num&quot;, &quot;likelihood&quot;, &quot;like_weight_ratio&quot;, &quot;distal_length&quot;, &quot;pendant_length&quot; ] } Jplace is the output format of pplacer (Frederick A. Matsen, Kodner, and Armbrust 2010) and Evolutionary Placement Algorithm (EPA) (Berger, Krompass, and Stamatakis 2011a). But these two programs do not contain tools to visualize placement results. Pplacer provides placeviz to convert jplace file to phyloXML or Newick formats which can be visualized by Archaeopteryx3. 1.2.5 Software outputs RAxML (Stamatakis 2014) can output Newick format by storing the bootstrap values as internal node labels. Another way that RAxML supported is to place bootstrap value inside square brackets and after branch length. This could not be supported by most of the software that support Newick format where square brackets will be ignored. BEAST (Bouckaert et al. 2014) output is based on NEXUS and it also introduce square brackets in the tree block to store evolutionary evidences inferred by BEAST. Inside brackets, curly braces may also incorporated if feature values have length more than 1 (e.g., HPD or range of substitution rate). These brackets are placed between node and branch length (i.e., after label if exists and before colon). Bracket is not defined in Newick format and is reserve character for NEXUS comment. So these information will be ignored for standard NEXUS parsers. Here is a sample TREE block of the BEAST output: tree TREE1 = [&amp;R] (((11[&amp;length=9.4]:9.38,14[&amp;length=6.4]:6.385096430786298) [&amp;length=25.7]:25.43,4[&amp;length=9.1]:8.821663252749829) [&amp;length=3.0]:3.10,(12[&amp;length=0.6]:0.56, (10[&amp;length=1.6]:1.56,(7[&amp;length=5.2]:5.19, ((((2[&amp;length=3.3]:3.26,(1[&amp;length=1.3]:1.32, (6[&amp;length=0.8]:0.83,13[&amp;length=0.8]:0.8311577761397366) [&amp;length=2.4]:2.48917886025146) [&amp;length=0.9]:0.9416178372674331) [&amp;length=0.4]:0.49,9[&amp;length=1.7]:1.757288031101215) [&amp;length=2.4]:2.35,8[&amp;length=2.1]:2.1125745387283246) [&amp;length=0.2]:0.23,(3[&amp;length=3.3]:3.31, (15[&amp;length=5.2]:5.27,5[&amp;length=3.2]:3.2710481368304585) [&amp;length=1.0]:1.0409443024626412) [&amp;length=1.9]:2.0372962536780435) [&amp;length=2.8]:2.8446835614595685) [&amp;length=5.3]:5.367459711197171) [&amp;length=2.0]:2.0037467863383043) [&amp;length=4.3]:4.360909907798238)[&amp;length=0.0]; BEAST output can contain many different evolutionary inferences, depending of the analysis models defined in BEAUTi for running. For example in molecular clock analysis, it contains rate, length, height, posterior and corresponding HPD and range for uncertainty estimation. Rate is the estimated evolutionary rate of the branch. Length is the length of the branch in years. Height is the time from node to root while posterior is the Bayesian clade credibility value. The above example is the output tree of clock analysis and should contains these inferences. To save space, I only keep the length above. MrBayes (Huelsenbeck and Ronquist 2001) is a program that uses Markov Chain Monte Carlo method to sample from the posterior probability distributions. Its output file annotates nodes and branches separately by two sets of square brackets. For example below, posterior clade probabilities for the node and branch length estimates for the branch: tree con_all_compat = [&amp;U] (8[&amp;prob=1.0]:2.94e-1[&amp;length_mean=2.9e-1],10[&amp;prob=1.0]:2.25e-1[&amp;length_mean=2.2e-1], ((((1[&amp;prob=1.0]:1.43e-1[&amp;length_mean=1.4e-1],2[&amp;prob=1.0]:1.92e-1[&amp;length_mean=1.9e-1]) [&amp;prob=1.0]:1.24e-1[&amp;length_mean=1.2e-1],9[&amp;prob=1.0]:2.27e-1[&amp;length_mean=2.2e-1]) [&amp;prob=1.0]:1.72e-1[&amp;length_mean=1.7e-1],12[&amp;prob=1.0]:5.11e-1[&amp;length_mean=5.1e-1]) [&amp;prob=1.0]:1.76e-1[&amp;length_mean=1.7e-1], (((3[&amp;prob=1.0]:5.46e-2[&amp;length_mean=5.4e-2], (6[&amp;prob=1.0]:1.03e-2[&amp;length_mean=1.0e-2],7[&amp;prob=1.0]:7.13e-3[&amp;length_mean=7.2e-3]) [&amp;prob=1.0]:6.93e-2[&amp;length_mean=6.9e-2]) [&amp;prob=1.0]:6.03e-2[&amp;length_mean=6.0e-2], (4[&amp;prob=1.0]:6.27e-2[&amp;length_mean=6.2e-2],5[&amp;prob=1.0]:6.31e-2[&amp;length_mean=6.3e-2]) [&amp;prob=1.0]:6.07e-2[&amp;length_mean=6.0e-2]) [&amp;prob=1.0]:1.80e-1[&amp;length_mean=1.8e-1],11[&amp;prob=1.0]:2.37e-1[&amp;length_mean=2.3e-1]) [&amp;prob=1.0]:4.05e-1[&amp;length_mean=4.0e-1]) [&amp;prob=1.0]:1.16e+000[&amp;length_mean=1.162699558201079e+000]) [&amp;prob=1.0][&amp;length_mean=0]; To save space, most of the inferences were removed and only contains prob for clade probability and length_mean for mean value of branch length. The full version of this file also contains prob_stddev, prob_range, prob(percent), prob+-sd for probability inferences and length_median, length_95%_HPD for every branch. The BEAST and MrBayes outputs are expected to be parsed without inferences (dropped as comments) by software that support NEXUS. FigTree supports parsing BEAST and MrBayes outputs with inferences that can be used to display or annotate on the tree. But from there extracting these data for further analysis is still challenging. HyPhy (Pond, Frost, and Muse 2005) could do a number of phylogenetic analysis, including ancestral sequence reconstruction. For ancestral sequence reconstruction, these sequences and the Newick tree text are stored in NEXUS format as the major analysis output. It did not completely follow the NEXUS definition and only put the ancestral node labels in TAXA instead of external node label. The MATRIX block contains sequence alignment of ancestral nodes which cannot be referred back to the tree stored in TREES block since it does not contains node labels. Here is the sample output (to save space, only the first 72bp of alignment are shown): #NEXUS [ Generated by HYPHY 2.0020110620beta(MP) for MacOS(Universal Binary) on Tue Dec 23 13:52:34 2014 ] BEGIN TAXA; DIMENSIONS NTAX = 13; TAXLABELS &#39;Node1&#39; &#39;Node2&#39; &#39;Node3&#39; &#39;Node4&#39; &#39;Node5&#39; &#39;Node12&#39; &#39;Node13&#39; &#39;Node15&#39; &#39;Node18&#39; &#39;Node20&#39; &#39;Node22&#39; &#39;Node24&#39; &#39;Node26&#39; ; END; BEGIN CHARACTERS; DIMENSIONS NCHAR = 2148; FORMAT DATATYPE = DNA GAP=- MISSING=? NOLABELS ; MATRIX ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATTGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAGTGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT END; BEGIN TREES; TREE tree = (K,N,(D,(L,(J,(G,((C,(E,O)),(H,(I,(B,(A,(F,M))))))))))); END; There are other applications that output rich information text that also contains phylogenetic trees with associated data. For example r8s (Sanderson 2003) output three trees in its log file, namely TREE, RATE and PHYLO for branches scaled by time, substitution rate, and absolute substitutions respectively. Phylogenetic Analysis by Maximum Likelihood (PAML) (Yang 2007) is a package of programs for phylogenetic analyses of DNA or protein sequences. Two main programs, BaseML and CodeML, implement a variety of models. BaseML estimates tree topology, branch lengths and substitution parameters using a number of nucleotide substitution models available, including JC69, K80, F81, F84, HKY85, T92, TN93 and GTR. CodeML estimates synonymous and non-synonymous substitution rates, likelihood ratio test of positive selection under codon substitution models (Goldman and Yang 1994). BaseML outputs mlb file that contains input sequence (taxa) alignment and phylogenetic tree with branch length as well as substitution model and other parameters estimated. The supplementary result file, rst, contains sequence alignment (with ancestral sequence if perform reconstruction of ancestral sequences) and Naive Empirical Bayes (NBE) probabilities that each site in the alignment evolved. CodeML outputs mlc file that contains tree structure and estimation of synonymous and non-synonymous substitution rates. CodeML also output supplementary result file, rst, that is similar to BaseML except that site is defined as codon instead of nucleotide. Parsing these files can be tedious and would oftentimes need a number of post-processing steps and require expertise in programming (e.g. with Python4 or Perl5). Introducing square brackets is quite common for storing extra information, including RAxML to store bootstrap value, NHX format for annotation, jplace for edge label and BEAST for evolutionary estimation, etc.. But the positions to place square brackets are not consistent in different software and the contents employ different rules for storing associated data, these properties make it difficult to parse associated data. For most of the software, they will just ignore square brackets and only parse the tree structure if the file is compatible. Some of them contains invalid characters (e.g. curly braces in tree field of jplace format) and even the tree structure can’t be parsed by standard parsers. It is difficult to extract useful phylogeny/taxon-related information from the different analysis outputs produced by various evolutionary inference software, for displaying on the same phylogenetic tree and for further analysis. FigTree supports BEAST output, but not for most of other software outputs that contains evolutionary inferences or associated data. For those output rich text files (e.g. r8s, PAML, etc.), the tree structure cannot be parsed by any tree viewing software and users need expertise to manually extract the phylogenetic tree and other useful result data from the output file. However, such manual operation is slow and error-prone. It was not easy to retrieve phylogenetic trees with evolutionary data from different analysis outputs of commonly used software in the field. Some of them (e.g., PAML output and jplace file) without software or programming library to support parsing file, while others (e.g., BEAST and MrBayes output) can be parsed without evolutionary inferences as they are stored in square brackets that will be omitted as comment by most of the software. Although FigTree support visualizing evolutionary statistics inferred by BEAST and MrBayes, extracting these data for further analysis is not supported. Different software packages implement different algorithms for different analyses (e.g., PAML for dN/dS, HyPhy for ancestral sequences and BEAST for skyline analysis). Therefore, in encountering the genomic sequence data, there is a desire need to efficiently and flexibly integrate different analysis inference results for comprehensive understanding, comparison and further analysis. This motivated us to develop the programming library to parse the phylogenetic trees and data from various sources. 1.3 Getting Tree Data with treeio Phylogenetic trees are commonly used to present evolutionary relationships of species. Information associated with taxon species/strains may be further analyzed in the context of the evolutionary history depicted by the phylogenetic tree. For example, host information of the influenza virus strains in the tree could be studied to understand host range of a virus linage. Moreover, such meta-data (e.g., isolation host, time, location, etc.) directly associated with taxon strains are also often subjected to further evolutionary or comparative phylogenetic models and analyses, to infer their dynamics associated with the evolutionary or transmission processes of the virus. All these meta-data or other phenotypic or experimental data are stored either as the annotation data associated with the nodes or branches, and are often produced in inconsistent format by different analysis programs. Getting trees into R is still limited. Newick and Nexus can be imported by several packages, including ape, phylobase. NeXML format can be parsed by RNeXML. However, analysis results from widely used software packages in this field are not well supported. SIMMAP output can be parsed by phyext2 and phytools. Although PHYLOCH can import BEAST and MrBayes output, only internal node attributes were parsed and tip attributes were ignore6. Many other software outputs are mainly required programming expertise to import the tree with associated data. Linking external data, including experimental and clinical data, to phylogeny is another obstacle for evolution biologists. To fill the gap that most of the tree formats or software outputs cannot be parsed within the same software/platform, an R package treeio was developed for parsing various tree file formats and outputs from common evolutionary analysis software. Treeio is developed with the R programming language (R Core Team 2016). Not only the tree structure can be parsed but also the associated data and evolutionary inferences, including NHX annotation, clock rate inferences (from BEAST or r8s (Sanderson 2003) programs), snynonymous and non-synonymous substitutions (from CodeML), and ancestral sequence construction (from HyPhy, BaseML or CodeML), etc.. Currently, treeio is able to read the following file formats: Newick, Nexus, New Hampshire eXtended format (NHX), jplace and Phylip as well as the data outputs from the following analysis programs: ASTRAL, BEAST, EPA, HyPhy, MEGA, MrBayes, PAML, PHYLDOG, pplacer, r8s, RAxML and RevBayes etc. This is made possible with the several parser functions developed in treeio (Table 1.1)7. Table 1.1: Parser functions defined in treeio Parser function Description read.astral parsing output of ASTRAL read.beast parsing output of BEAST read.codeml parsing output of CodeML (rst and mlc files) read.codeml_mlc parsing mlc file (output of CodeML) read.fasta parsing FASTA format sequence file read.hyphy parsing output of HYPHY read.hyphy.seq parsing ancestral sequences from HYPHY output read.iqtree parsing IQ-Tree newick string, with ability to parse SH-aLRT and UFBoot support values read.jplace parsing jplace file including output of EPA and pplacer read.jtree parsing jtree format read.mega parsing MEGA Nexus output read.mega_tabular parsing MEGA tabular output read.mrbayes parsing output of MrBayes read.newick parsing newick string, with ability to parse node label as support values read.nhx parsing NHX file including output of PHYLDOG and RevBayes read.paml_rst parsing rst file (output of BaseML or CodeML) read.phylip parsing phylip file (phylip alignment + newick string) read.phylip.seq parsing multiple sequence alignment from phylip file read.phylip.tree parsing newick string from phylip file read.r8s parsing output of r8s read.raxml parsing output of RAxML The treeio package defines base classes and functions for phylogenetic tree input and output. It is an infrastructure that enables evolutionary evidences that inferred by commonly used software packages to be used in R. For instance, dN/dS values or ancestral sequences inferred by CODEML (Yang 2007), clade support values (posterior) inferred by BEAST (Bouckaert et al. 2014) and short read placement by EPA (Berger, Krompass, and Stamatakis 2011b) and pplacer (Frederick A Matsen, Kodner, and Armbrust 2010). These evolutionary evidences can be further analyzed in R and used to annotate phylogenetic tree using ggtree (Yu et al. 2017). The growth of analysis tools and models available introduces a challenge to integrate different varieties of data and analysis results from different sources for an integral analysis on the the same phylogenetic tree background. The treeio package provides a merge_tree function to allow combining tree data obtained from different sources. In addition, treeio also enables external data to be linked to phylogenetic tree structure. After parsing, storage of the tree structure with associated data is made through a S4 class, treedata, defined in the tidytree package. These parsed data are mapped to the tree branches and nodes inside treedata object, so that they can be efficiently used to visually annotate the tree using ggtree package (Yu et al. 2017) (described in Chapter 4 and 5). A programmable platform for phylogenetic data parsing, integration and annotations as such makes us easier to identify the evolutionary dynamics and correlation patterns. 1.3.1 Overview of treeio The treeio package defined S4 classes for storing phylogenetic tree with diverse types of associated data or covariates from different sources including analysis outputs from different software packages. It also defined corresponding parser functions for parsing phylogenetic tree with annotation data and stored as data object in R for further manipulation or analysis (see Table 1.1). Several accessor functions were defined to facilitate accessing the tree annotation data, including get.fields for obtaining annotation features available in the tree object, get.placements for obtaining the phylogenetic placement results (i.e., output of pplacer, EPA, etc.), get.subs for obtaining the genetic substitutions from parent node to child node, and get.tipseq for getting the tip sequences. The S3 class, phylo, which was defined in ape (Paradis, Claude, and Strimmer 2004) package, is widely used in R community and many packages. As treeio uses S4 class, to enable those available R packages to analyze the tree imported by treeio, treeio provides as.phylo function to convert treeio-generated tree object to phylo object that only contains tree structure without annotation data. In the other way, treeio also provides as.treedata function to convert phylo object with evolutionary analysis result (e.g., bootstrap values calculated by ape or ancestral states inferred by phangorn (Schliep 2011) etc) to be stored as a treedata S4 object, making it easy to map the data to the tree structure and to be visualized using ggtree. To allow integration of different kinds of data in phylogenetic tree, treeio provides merge_tree function (details in section 2.2.1) for combining evolutionary statistics/evidences imported from different sources including those common tree files and outputs from analysis programs (Table 1.1). There are other information, such as sampling location, taxonomy information, experimental result and evolutionary traits, etc. that are stored in separate files with user-defined format. In treeio, we could read in these data from the users’ files using standard R IO functions, and attach them to the tree object by the full_join method defined in our treeio package (see also the %&lt;+% operator defined in ggtree). After attaching, the data will become the attributes associated with nodes or branches, which can be compared with other data incorporated, or can be visually displayed on the tree. To facilitate storing the merged data into a single file, treeio implemented write.baset and write.jtree function to export treedata object for storing complex data associated with the phylogenetic tree (see Chapter 3). 1.3.2 Function Demonstration 1.3.2.1 Parsing BEAST output file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) beast ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. Since % is not a valid character in names, all the feature names that contain x% will convert to 0.x. For example, length_95%_HPD will be changed to length_0.95_HPD. Not only tree structure but also all the features inferred by BEAST will be stored in the S4 object. These features can be used for tree annotation (Figure 5.7). 1.3.2.2 Parsing MEGA output MEGA (Kumar, Stecher, and Tamura 2016) supports exporting trees in three distinct formats: Newick, tabular and Nexus. The Newick file can be parsed using the read.tree or read.newick functions. MEGA Nexus file is similar to BEAST Nexus and treeio provides read.mega function to parse the tree. file &lt;- system.file(&quot;extdata/MEGA7&quot;, &quot;mtCDNA_timetree.nex&quot;, package = &quot;treeio&quot;) read.mega(file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/MEGA7/mtCDNA_timetree.nex&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 7 tips and 6 internal nodes. ## ## Tip labels: ## homo_sapiens, chimpanzee, bonobo, gorilla, orangutan, sumatran, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;branch_length&#39;, &#39;data_coverage&#39;, &#39;rate&#39;, &#39;reltime&#39;, ## &#39;reltime_0.95_CI&#39;, &#39;reltime_stderr&#39;. The tabular output contains tree and associated information (divergence time in this example) in a tabular flat text file. The read.mega_tabular function can parse the tree with data simultaneously. file &lt;- system.file(&quot;extdata/MEGA7&quot;, &quot;mtCDNA_timetree_tabular.txt&quot;, package = &quot;treeio&quot;) read.mega_tabular(file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/MEGA7/mtCDNA_timetree_tabular.txt&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 7 tips and 6 internal nodes. ## ## Tip labels: ## chimpanzee, bonobo, homo sapiens, gorilla, orangutan, sumatran, ... ## Node labels: ## [1] &quot;&quot; &quot;&quot; &quot;demoLabel2&quot; &quot;&quot; ## [5] &quot;&quot; &quot;&quot; ## ## Rooted; no branch lengths. ## ## with the following features available: ## &#39;RelTime&#39;, &#39;CI_Lower&#39;, &#39;CI_Upper&#39;, &#39;Rate&#39;, ## &#39;Data Coverage&#39;. 1.3.2.3 Parsing MrBayes output file &lt;- system.file(&quot;extdata/MrBayes&quot;, &quot;Gq_nxs.tre&quot;, package=&quot;treeio&quot;) read.mrbayes(file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/MrBayes/Gq_nxs.tre&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 12 tips and 10 internal nodes. ## ## Tip labels: ## B_h, B_s, G_d, G_k, G_q, G_s, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;length_0.95HPD&#39;, &#39;length_mean&#39;, &#39;length_median&#39;, &#39;prob&#39;, ## &#39;prob_range&#39;, &#39;prob_stddev&#39;, &#39;prob_percent&#39;, &#39;prob+-sd&#39;. 1.3.2.4 Parsing PAML output The read.paml_rst function can parse rst file from BASEML and CODEML. The only difference is the space in the sequences. For BASEML, each ten bases are separated by one space, while for CODEML, each three bases (triplet) are separated by one space. brstfile &lt;- system.file(&quot;extdata/PAML_Baseml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) brst &lt;- read.paml_rst(brstfile) brst ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Baseml/rst&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. Similarly, we can parse the rst file from CODEML. crstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) ## type can be one of &quot;Marginal&quot; or &quot;Joint&quot; crst &lt;- read.paml_rst(crstfile, type = &quot;Joint&quot;) crst ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/rst&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. Ancestral sequences inferred by BASEML or CODEML via marginal or joint ML reconstruction methods will be stored in the S4 object and mapped to tree nodes. treeio will automatically determine the substitutions between the sequences at the both ends of each branch. Amino acid substitution will also be determined by translating nucleotide sequences to amino acid sequences. These computed substitutions will also be stored in the S4 object for efficient tree annotation later (Figure 5.9). CODEML infers selection pressure and estimated dN/dS, dN and dS. These information are stored in output file mlc, which can be parsed by read.codeml_mlc function. mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc &lt;- read.codeml_mlc(mlcfile) mlc ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. In previous session, we separately parsed rst and mlc files. However, they can also be parsed together using read.codeml function. ## tree can be one of &quot;rst&quot; or &quot;mlc&quot; to specify ## using tree from which file as base tree in the object ml &lt;- read.codeml(crstfile, mlcfile, tree = &quot;mlc&quot;) ml ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/rst&#39;, ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, ## &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. All the features in both rst and mlc files were imported into a single S4 object and hence are available for further annotation and visualization. For example, we can annotate and display both dN/dS (from mlc file) and amino acid substitutions (derived from rst file) on the same phylogenetic tree (Yu et al. 2017). 1.3.2.5 Parsing HyPhy output Ancestral sequences inferred by HyPhy are stored in the Nexus output file, which contains the tree topology and ancestral sequences. To parse this data file, users can use the read.hyphy.seq function. ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) read.hyphy.seq(ancseq) ## 13 DNA sequences in binary format stored in a list. ## ## All sequences of same length: 2148 ## ## Labels: ## Node1 ## Node2 ## Node3 ## Node4 ## Node5 ## Node12 ## ... ## ## Base composition: ## a c g t ## 0.335 0.208 0.237 0.220 ## (Total: 27.92 kb) To map the sequences on the tree, user shall also provide an internal-node-labelled tree. If users want to determine substitution, they need also provide tip sequences. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) hy ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/HYPHY/labelledtree.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## Node labels: ## Node1, Node2, Node3, Node4, Node5, Node12, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. 1.3.2.6 Parsing r8s output r8s uses parametric, semiparametric and nonparametric methods to relax molecular clock to allow better estimations of divergence times and evolution rates (Sanderson 2003). It outputs three trees in log file, namely TREE, RATO and PHYLO for time tree, rate tree and absolute substitution tree respectively. Time tree is scaled by divergence time, rate tree is scaled by substitution rate and absolute substitution tree is scaled by absolute number of substitution. After parsing the file, all these three trees are stored in a multiPhylo object. r8s &lt;- read.r8s(system.file(&quot;extdata/r8s&quot;, &quot;H3_r8s_output.log&quot;, package=&quot;treeio&quot;)) r8s ## 3 phylogenetic trees 1.3.2.7 Parsing output of RAxML bootstraping analysis RAxML bootstraping analysis output a Newick tree text that is not standard as it stores bootstrap values inside square brackets after branch lengths. This file usually cannot be parsed by traditional Newick parser, such as ape::read.tree. The function read.raxml can read such file and stored the bootstrap as an additional features, which can be used to display on the tree or used to color tree branches, etc.. raxml_file &lt;- system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;) raxml &lt;- read.raxml(raxml_file) raxml ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/RAxML/RAxML_bipartitionsBranchLabels.H3&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 64 tips and 62 internal nodes. ## ## Tip labels: ## A_Hokkaido_M1_2014_H3N2_2014, A_Czech_Republic_1_2014_H3N2_2014, FJ532080_A_California_09_2008_H3N2_2008, EU199359_A_Pennsylvania_05_2007_H3N2_2007, EU857080_A_Hong_Kong_CUHK69904_2006_H3N2_2006, EU857082_A_Hong_Kong_CUHK7047_2005_H3N2_2005, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;bootstrap&#39;. 1.3.2.8 Parsing NHX tree NHX (New Hampshire eXtended) format is an extension of Newick by introducing NHX tags. NHX is commonly used in phylogenetics software (including PHYLDOG (Boussau et al. 2013), RevBayes (Höhna et al. 2014)) for storing statistical inferences. The following codes imported a NHX tree with associated data inferred by PHYLDOG. nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) nhx ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;. 1.3.2.9 Parsing Phylip tree Phylip format contains multiple sequence alignment of taxa in Phylip sequence format with corresponding Newick tree text that was built from taxon sequences. Multiple sequence alignment can be sorted based on the tree structure and displayed at the right hand side of the tree using ggtree (see also the msaplot function). phyfile &lt;- system.file(&quot;extdata&quot;, &quot;sample.phy&quot;, package=&quot;treeio&quot;) phylip &lt;- read.phylip(phyfile) phylip ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/sample.phy&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## ## Unrooted; no branch lengths. 1.3.2.10 Parsing EPA and pplacer output EPA (Berger, Krompass, and Stamatakis 2011b) and PPLACER (Frederick A Matsen, Kodner, and Armbrust 2010) have common output file format, jplace, which can be parsed by read.jplace() function. jpf &lt;- system.file(&quot;extdata/EPA.jplace&quot;, package=&quot;treeio&quot;) jp &lt;- read.jplace(jpf) print(jp) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/EPA.jplace&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 493 tips and 492 internal nodes. ## ## Tip labels: ## CIR000447A, CIR000479, CIR000078, CIR000083, CIR000070, CIR000060, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;nplace&#39;. The number of evolutionary placement on each branch will be calculated and stored as the nplace feature, which can be mapped to line size and/or color using ggtree (Yu et al. 2017). 1.3.2.11 Parsing jtree format The jtree is a JSON based format that was defined in this treeio package to support tree data inter change (see session 3.3). Phylogenetic tree with associated data can be exported to a single jtree file using write.jtree function. The jtree can be easily parsed using any JSON parser. The jtree format contains three keys: tree, data and metadata. The tree value contains tree text extended from Newick tree format by putting the edge number in curly braces after branch length. The data value contains node/branch-specific data, while metadata value contains additional meta information. jtree_file &lt;- tempfile(fileext = &#39;.jtree&#39;) write.jtree(beast, file = jtree_file) read.jtree(file = jtree_file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/tmp/RtmpUfeAdI/file2ed015ff366f.jtree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## K_2013, N_2010, D_1987, L_1980, J_1983, G_1992, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_range&#39;, &#39;length&#39;, ## &#39;length_0.95_HPD&#39;, &#39;length_median&#39;, &#39;length_range&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, ## &#39;height_median&#39;, &#39;posterior&#39;. 1.3.3 Getting information from treedata object After the tree was imported, users may want to extract information that stored in the treedata object. treeio provides several accessor methods to extract tree structure, features/attributes that stored in the object and their corresponding values. The get.tree or as.phylo methods can convert the treedata object to phylo object which is the fundamental tree object in the R community and many packages work with phylo object. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) # or get.tree as.phylo(beast_tree) ## ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. The get.fields method return a vector of features/attributes that stored in the object and associated with the phylogeny. get.fields(beast_tree) ## [1] &quot;height&quot; &quot;height_0.95_HPD&quot; &quot;height_median&quot; ## [4] &quot;height_range&quot; &quot;length&quot; &quot;length_0.95_HPD&quot; ## [7] &quot;length_median&quot; &quot;length_range&quot; &quot;posterior&quot; ## [10] &quot;rate&quot; &quot;rate_0.95_HPD&quot; &quot;rate_median&quot; ## [13] &quot;rate_range&quot; The get.data method return a tibble of all the associated data. get.data(beast_tree) ## # A tibble: 151 x 14 ## height height_0.95_HPD height_median height_range length ## &lt;dbl&gt; &lt;list&gt; &lt;dbl&gt; &lt;list&gt; &lt;dbl&gt; ## 1 19 &lt;dbl [2]&gt; 19 &lt;dbl [2]&gt; 2.34 ## 2 17 &lt;dbl [2]&gt; 17 &lt;dbl [2]&gt; 1.18 ## 3 14 &lt;dbl [2]&gt; 14 &lt;dbl [2]&gt; 0.966 ## 4 12 &lt;dbl [2]&gt; 12 &lt;dbl [2]&gt; 1.87 ## 5 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 2.93 ## 6 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; 0.827 ## 7 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; 0.834 ## 8 10.8 &lt;dbl [2]&gt; 10.8 &lt;dbl [2]&gt; 0.233 ## 9 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 1.28 ## 10 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 0.414 ## # … with 141 more rows, and 9 more variables: ## # length_0.95_HPD &lt;list&gt;, length_median &lt;dbl&gt;, ## # length_range &lt;list&gt;, posterior &lt;dbl&gt;, rate &lt;dbl&gt;, ## # rate_0.95_HPD &lt;list&gt;, rate_median &lt;dbl&gt;, ## # rate_range &lt;list&gt;, node &lt;int&gt; If users are only interesting a subset of the features/attributes return by get.fields, they can extract the information from the output of get.data or directly subset the data by [ or [[. beast_tree[, c(&quot;node&quot;, &quot;height&quot;)] ## # A tibble: 151 x 2 ## node height ## &lt;int&gt; &lt;dbl&gt; ## 1 10 19 ## 2 9 17 ## 3 36 14 ## 4 31 12 ## 5 29 9 ## 6 28 10 ## 7 39 10 ## 8 90 10.8 ## 9 16 9 ## 10 2 9 ## # … with 141 more rows head(beast_tree[[&quot;height_median&quot;]]) ## [1] 19 17 14 12 9 10 1.4 Summary Software tools for inferring molecular evolution (e.g., ancestral states, molecular dating and selection pressure, etc.) are proliferating, but there is no single data format that is used by all different programs and capable to store different types of phylogenetic data. Most of the software packages have their own unique output formats and these formats are not compatible with each other. Parsing software outputs is challenging, which restricts the joint analysis using different tools. The treeio provides a set of functions (Table 1.1) for parsing various types of phylogenetic data files. These phylogenetic data can be integrated together that allows further exploration and comparison. Until now, most software tools in field of molecular evolution are isolated and often not fully compatible with each other for input and output files. All these software tools are designed to do their own analysis and the outputs are often not readable in other software. There is no software tool that was particularly designed to unify the inference data from different analysis programs. An efficient incorporation of the different inference data can compare and verify between methods, and comprehend the understanding of the study target at different aspects and angles, which may discover new systematic patterns and bring new insights to generate new hypothesis. As phylogenetic trees are growing in its application to identify patterns in evolutionary context, more different disciplines are employing phylogenetic trees in their research. For example, spatial ecologists may map the geographical positions of the organisms to their phylogenetic trees to understand the biogeography of the species (Schön et al. 2015); disease epidemiologists may incorporate the pathogen sampling time and locations into the phylogenetic analysis to infer the disease transmission dynamics in spatiotemporal space (He et al. 2013); microbiologists may determine the pathogenicity of different pathogen strains and map them into their phylogenetic trees to identify the genetic determinants of the pathogenicity (Bosi et al. 2016); genomic scientists may use the phylogenetic trees to help taxonomically classify their metagenomic sequence data (Gupta and Sharma 2015). A robust tool such as treeio to import and map different types of data into the phylogenetic tree is important to facilitate these phylogenetics-related research, or a.k.a ‘phylodynamics’. Such tool could also help integrate different metadata (time, geography, genotype, epidemiological information) and analysis results (selective pressure, evolutionary rates) at the highest level and provide a comprehensive understanding of the study organisms. In the field of influenza research, there have been such attemps of studying phylodynamics of the influenza virus by mapping different meta-data and analysis results on the same phylogenetic tree and evolutionary time scale (Lam et al. 2015). References "],
["chapter2.html", "Chapter 2 Manipulating Tree with Data 2.1 Manipulating tree data using tidy interface 2.2 Data Integration 2.3 Rescaling Tree Branches 2.4 Subsetting Tree with Data 2.5 Manipulating tree data for visualization 2.6 Summary", " Chapter 2 Manipulating Tree with Data 2.1 Manipulating tree data using tidy interface All the tree data parsed/merged by treeio can be converted to tidy data frame using the tidytree package. The tidytree package provides tidy interfaces to manipulate tree with associated data. For instances, external data can be linked to phylogeny or evolutionary data obtained from different sources can be merged using tidyverse verbs. After the tree data was manipulated, it can be converted back to treedata object and exported to a single tree file, further analyzed in R or visualized using ggtree (Yu et al. 2017). 2.1.1 The phylo object The phylo class defined in ape is fundamental for phylogenetic analysis in R. Most of the R packages in this field rely extensively on phylo object. The tidytree package provides as_tibble method to convert the phylo object to tidy data frame, a tbl_tree object. library(ape) set.seed(2017) tree &lt;- rtree(4) tree ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t4&quot; &quot;t1&quot; &quot;t3&quot; &quot;t2&quot; ## ## Rooted; includes branch lengths. x &lt;- as_tibble(tree) x ## # A tibble: 7 x 4 ## parent node branch.length label ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5 1 0.435 t4 ## 2 7 2 0.674 t1 ## 3 7 3 0.00202 t3 ## 4 6 4 0.0251 t2 ## 5 5 5 NA &lt;NA&gt; ## 6 5 6 0.472 &lt;NA&gt; ## 7 6 7 0.274 &lt;NA&gt; The tbl_tree object can be converted back to a phylo object. as.phylo(x) ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t4&quot; &quot;t1&quot; &quot;t3&quot; &quot;t2&quot; ## ## Rooted; includes branch lengths. Using tbl_tree object makes tree and data manipulation more effective and easier. For example, we can link evolutionary trait to phylogeny using dplyr verbs full_join: d &lt;- tibble(label = paste0(&#39;t&#39;, 1:4), trait = rnorm(4)) y &lt;- full_join(x, d, by = &#39;label&#39;) y ## # A tibble: 7 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 1 0.435 t4 0.943 ## 2 7 2 0.674 t1 -0.171 ## 3 7 3 0.00202 t3 0.570 ## 4 6 4 0.0251 t2 -0.283 ## 5 5 5 NA &lt;NA&gt; NA ## 6 5 6 0.472 &lt;NA&gt; NA ## 7 6 7 0.274 &lt;NA&gt; NA 2.1.2 The treedata object The tidytree package defines treedata class to store phylogenetic tree with associated data. After mapping external data to the tree structure, the tbl_tree object can be converted to a treedata object. as.treedata(y) ## &#39;treedata&#39; S4 object&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t4&quot; &quot;t1&quot; &quot;t3&quot; &quot;t2&quot; ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;trait&#39;. The treedata class is also used in treeio package to store evolutionary evidences inferred by commonly used software (BEAST, EPA, HYPHY, MrBayes, PAML, PHYLDOG, pplacer, r8s, RAxML and RevBayes, etc.) (see details in Chapter 1). The tidytree package also provides as_tibble to convert treedata object to a tidy data frame. The phylogentic tree structure and the evolutionary inferences were stored in the tbl_tree object, making it consistent and easier for manipulating evolutionary statistics inferred by different software as well as linking external data to the same tree structure. y %&gt;% as.treedata %&gt;% as_tibble ## # A tibble: 7 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 1 0.435 t4 0.943 ## 2 7 2 0.674 t1 -0.171 ## 3 7 3 0.00202 t3 0.570 ## 4 6 4 0.0251 t2 -0.283 ## 5 5 5 NA &lt;NA&gt; NA ## 6 5 6 0.472 &lt;NA&gt; NA ## 7 6 7 0.274 &lt;NA&gt; NA 2.1.3 Access related nodes dplyr verbs can be applied to tbl_tree directly to manipulate tree data. In addition, tidytree provides several verbs to filter related nodes, including child, parent, offspring, ancestor, sibling and MRCA. These verbs accept a tbl_tree and a selected node which can be node number or label. child(y, 5) ## # A tibble: 2 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 1 0.435 t4 0.943 ## 2 5 6 0.472 &lt;NA&gt; NA parent(y, 2) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6 7 0.274 &lt;NA&gt; NA offspring(y, 5) ## # A tibble: 6 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 1 0.435 t4 0.943 ## 2 7 2 0.674 t1 -0.171 ## 3 7 3 0.00202 t3 0.570 ## 4 6 4 0.0251 t2 -0.283 ## 5 5 6 0.472 &lt;NA&gt; NA ## 6 6 7 0.274 &lt;NA&gt; NA ancestor(y, 2) ## # A tibble: 3 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 5 NA &lt;NA&gt; NA ## 2 5 6 0.472 &lt;NA&gt; NA ## 3 6 7 0.274 &lt;NA&gt; NA sibling(y, 2) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 3 0.00202 t3 0.570 MRCA(y, 2, 3) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6 7 0.274 &lt;NA&gt; NA All these methods also implemented in treeio for working with phylo and treedata objects. You can try accessing related nodes using the tree object. For instance, the following command will output child nodes of the selected internal node 5: child(tree, 5) ## [1] 1 6 Beware that the methods work for tree objects output related node numbers, while the methods implemented for tbl_tree object output a tibble object that contains related information. 2.2 Data Integration 2.2.1 Combining tree data The treeio package serves as an infrastructure that enables various types of phylogenetic data inferred from common analysis programs to be imported and used in R. For instance dN/dS or ancestral sequences estimated by CODEML, and clade support values (posterior) inferred by BEAST/MrBayes. In addition, treeio package supports linking external data to phylogeny. It brings these external phylogenetic data (either from software output or exteranl sources) to the R community and make it available for further analysis in R. Furthermore, treeio can combine multiple phylogenetic trees together into one with their node/branch-specific attribute data. Essentially, as a result, one such attribute (e.g., substitution rate) can be mapped to another attribute (e.g., dN/dS) of the same node/branch for comparison and further computations (Yu et al. 2017). A previously published data set, seventy-six H3 hemagglutinin gene sequences of a lineage containing swine and human influenza A viruses (Liang et al. 2014), was here to demonstrate the utilities of comparing evolutionary statistics inferred by different software. The dataset was re-analyzed by BEAST for timescale estimation and CODEML for synonymous and non-synonymous substitution estimation. In this example, we first parsed the outputs from BEAST using read.beast and from CODEML using read.codeml into two treedata objects. Then the two objects containing separate sets of node/branch-specific data were merged via the merge_tree function. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) rst_file &lt;- system.file(&quot;examples/rst&quot;, package=&quot;ggtree&quot;) mlc_file &lt;- system.file(&quot;examples/mlc&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) codeml_tree &lt;- read.codeml(rst_file, mlc_file) merged_tree &lt;- merge_tree(beast_tree, codeml_tree) merged_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;, ## &#39;/home/ygc/R/library/ggtree/examples/rst&#39;, ## &#39;/home/ygc/R/library/ggtree/examples/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;subs&#39;, ## &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, ## &#39;S_x_dS&#39;. After merging the beast_tree and codeml_tree objects, all node/branch-specific data imported from BEAST and CODEML output files are all available in the merged_tree object. The tree object was converted to tidy data frame using tidytree package and visualized as hexbin scatterplot of dN/dS, dN and dS inferred by CODEML versus rate (substitution rate in unit of substitutions/site/year) inferred by BEAST on the same branches. library(dplyr) df &lt;- merged_tree %&gt;% as_tibble() %&gt;% select(dN_vs_dS, dN, dS, rate) %&gt;% subset(dN_vs_dS &gt;=0 &amp; dN_vs_dS &lt;= 1.5) %&gt;% tidyr::gather(type, value, dN_vs_dS:dS) df$type[df$type == &#39;dN_vs_dS&#39;] &lt;- &#39;dN/dS&#39; df$type &lt;- factor(df$type, levels=c(&quot;dN/dS&quot;, &quot;dN&quot;, &quot;dS&quot;)) ggplot(df, aes(rate, value)) + geom_hex() + facet_wrap(~type, scale=&#39;free_y&#39;) Figure 2.1: Correlation of dN/dS, dN and dS versus substitution rate. After merging the BEAST and CodeML outputs, the branch-specific estimates (substitution rate, dN/dS , dN and dS) from the two analysis programs are compared on the same branch basis. The associations of dN/dS, dN and dS vs. rate are visualized in hexbin scatter plots. The output is illustrated in Fig. 2.1. We can then test the association of these node/branch-specific data using Pearson correlation, which in this case showed that dN and dS, but not dN/dS are significantly (p-values) associated with rate. Using merge_tree, we are able to compare analysis results using identical model from different software packages or different models using different or identical software. It also allows users to integrate different analysis finding from different software packages. Merging tree data is not restricted to software findings, associating external data to analysis findings is also granted. The merge_tree function is chainable and allows several tree objects to be merged into one. phylo &lt;- as.phylo(beast_tree) N &lt;- Nnode2(phylo) d &lt;- tibble(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N)) fake_tree &lt;- treedata(phylo = phylo, data = d) triple_tree &lt;- merge_tree(merged_tree, fake_tree) triple_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;, ## &#39;/home/ygc/R/library/ggtree/examples/rst&#39;, ## &#39;/home/ygc/R/library/ggtree/examples/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;subs&#39;, ## &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, ## &#39;S_x_dS&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. The triple_tree object showed above contains analysis results obtained from BEAST and CODEML, and evolutionary trait from external sources. All these information can be used to annotate the tree using ggtree (Yu et al. 2017). 2.2.2 Linking external data to phylogeny In addition to analysis findings that are associated with the tree as we showed above, there is a wide range of heterogeneous data, including phenotypic data, experimental data and clinical data etc., that need to be integrated and linked to phylogeny. For example, in the study of viral evolution, tree nodes may associated with epidemiological information, such as location, age and subtype. Functional annotations may need to be mapped on gene trees for comparative genomics studies. To facilitate data integration, treeio provides full_join method to link external data to phylogeny and stored in either phylo or treedata object. Beware that linking external data to a phylo object will produce a treedata object to store the input phylo with associated data. The full_join methods can also be used at tidy data frame level (i.e. tbl_tree object described previously) and at ggtree level (described in session 7.1) (Yu et al. 2018). The following example calculated bootstrap values and merging that values with the tree (a phylo object) by matching their node numbers. library(ape) data(woodmouse) d &lt;- dist.dna(woodmouse) tr &lt;- nj(d) bp &lt;- boot.phylo(tr, woodmouse, function(x) nj(dist.dna(x))) ## Running bootstraps: 100 / 100 ## Calculating bootstrap values... done. bp2 &lt;- tibble(node=1:Nnode(tr) + Ntip(tr), bootstrap = bp) full_join(tr, bp2, by=&quot;node&quot;) ## &#39;treedata&#39; S4 object&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## No305, No304, No306, No0906S, No0908S, No0909S, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;bootstrap&#39;. Another example demonstrates merging evolutionary trait with the tree (a treedata object) by matching their tip labels. file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) x &lt;- tibble(label = as.phylo(beast)$tip.label, trait = rnorm(Ntip(beast))) full_join(beast, x, by=&quot;label&quot;) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;trait&#39;. Manipulating tree object is frustrated with the fragmented functions available for working with phylo object, not to mention linking external data to the phylogeny structure. With treeio package, it is easy to combine tree data from various sources. In addition, with tidytree package (session 2.1), manipulating tree is more easier using tidy data principles and consistent with tools already in wide use, including dplyr, tidyr, ggplot2 and ggtree. 2.2.3 Grouping taxa The groupOTU and groupClade methods are designed for adding taxa grouping information to the input tree object. The methods were implemented in tidytree, treeio and ggtree respectively to support adding grouping information at tbl_tree, phylo and treedata, and ggtree levels. These grouping information can be used directly in tree visualization (e.g. coloring tree based on grouping) with ggtree (Figure 6.5). 2.2.3.1 groupClade The groupClade method accepts an internal node or a vector of internal nodes to add grouping information of clade/clades. nwk &lt;- &#39;(((((((A:4,B:4):6,C:5):8,D:6):3,E:21):10,((F:4,G:12):14,H:8):13):13,((I:5,J:2):30,(K:11,L:11):2):17):4,M:56);&#39; tree &lt;- read.tree(text=nwk) groupClade(as_tibble(tree), c(17, 21)) ## # A tibble: 25 x 5 ## parent node branch.length label group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 20 1 4 A 1 ## 2 20 2 4 B 1 ## 3 19 3 5 C 1 ## 4 18 4 6 D 1 ## 5 17 5 21 E 1 ## 6 22 6 4 F 2 ## 7 22 7 12 G 2 ## 8 21 8 8 H 2 ## 9 24 9 5 I 0 ## 10 24 10 2 J 0 ## # … with 15 more rows 2.2.3.2 groupOTU set.seed(2017) tr &lt;- rtree(4) x &lt;- as_tibble(tr) ## the input nodes can be node ID or label groupOTU(x, c(&#39;t1&#39;, &#39;t4&#39;), group_name = &quot;fake_group&quot;) ## # A tibble: 7 x 5 ## parent node branch.length label fake_group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 5 1 0.435 t4 1 ## 2 7 2 0.674 t1 1 ## 3 7 3 0.00202 t3 0 ## 4 6 4 0.0251 t2 0 ## 5 5 5 NA &lt;NA&gt; 1 ## 6 5 6 0.472 &lt;NA&gt; 1 ## 7 6 7 0.274 &lt;NA&gt; 1 Both groupClade() and groupOTU() work with tbl_tree, phylo and treedata, and ggtree objects. Here is an example of using groupOTU() with phylo tree object. groupOTU(tr, c(&#39;t1&#39;, &#39;t4&#39;), group_name = &quot;fake_group&quot;) %&gt;% as_tibble ## # A tibble: 7 x 5 ## parent node branch.length label fake_group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 5 1 0.435 t4 1 ## 2 7 2 0.674 t1 1 ## 3 7 3 0.00202 t3 0 ## 4 6 4 0.0251 t2 0 ## 5 5 5 NA &lt;NA&gt; 1 ## 6 5 6 0.472 &lt;NA&gt; 1 ## 7 6 7 0.274 &lt;NA&gt; 1 Another example of working with ggtree object can be found in session 6.5. The groupOTU will trace back from input nodes to most recent common ancestor. In this example, nodes 2, 3, 7 and 6 (2 (t1) -&gt; 7 -&gt; 6 and 3 (t4) -&gt; 6) are grouping together. Related OTUs are grouping together and they are not necessarily within a clade. They can be monophyletic (clade), polyphyletic or paraphyletic. cls &lt;- list(c1=c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), c2=c(&quot;F&quot;, &quot;G&quot;, &quot;H&quot;), c3=c(&quot;L&quot;, &quot;K&quot;, &quot;I&quot;, &quot;J&quot;), c4=&quot;M&quot;) as_tibble(tree) %&gt;% groupOTU(cls) ## # A tibble: 25 x 5 ## parent node branch.length label group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 20 1 4 A c1 ## 2 20 2 4 B c1 ## 3 19 3 5 C c1 ## 4 18 4 6 D c1 ## 5 17 5 21 E c1 ## 6 22 6 4 F c2 ## 7 22 7 12 G c2 ## 8 21 8 8 H c2 ## 9 24 9 5 I c3 ## 10 24 10 2 J c3 ## # … with 15 more rows If there are conflicts when tracing back to mrca, user can set overlap parameter to “origin” (the first one counts), “overwrite” (default, the last one counts) or “abandon” (un-selected for grouping)8. 2.3 Rescaling Tree Branches Phylogenetic data can be merged for joint analysis (Figure 2.1). They can be displayed on the same tree structure as more complex annotation to help visually inspection of their evolutionary patterns. All the numerical data stored in treedata object can be used to re-scale tree branches. For example, CodeML infers dN/dS, dN and dS, all these statistics can be used as branch lengths. All these values can also be used to color the tree (session 4.3.4) and can be project to vertical dimension to create two-dimensional tree or phenogram (session 4.2.2 and Figure 4.5 and 4.11). p1 &lt;- ggtree(merged_tree) + theme_tree2() p2 &lt;- ggtree(rescale_tree(merged_tree, &#39;dN&#39;)) + theme_tree2() p3 &lt;- ggtree(rescale_tree(merged_tree, &#39;rate&#39;)) + theme_tree2() cowplot::plot_grid(p1, p2, p3, ncol=3, labels = LETTERS[1:3]) Figure 2.2: Re-scaling tree branches. The tree with branches scaled in time (year from the root) (A). The tree was re-scaled using dN as branch lengths (B). The tree was re-scaled using substitution rates (C). 2.4 Subsetting Tree with Data 2.4.1 Removing tips in a phylogenetic tree Sometimes we want to remove selected tips from a phylogenetic tree. This is due to several reasons, including low sequence quality, errors in sequence assembly, an alignment error in part of the sequence and an error in phylogenetic inference etc. Let’s say that we want to remove three tips (colored by red) from the tree (Figure 2.3A), the drop.tip() method removes specified tips and update tree (Figure 2.3B). All associated data will be maintained in the updated tree. f &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(f) to_drop &lt;- c(&quot;Physonect_sp_@2066767&quot;, &quot;Lychnagalma_utricularia@2253871&quot;, &quot;Kephyes_ovata@2606431&quot;) p1 &lt;- ggtree(nhx) + geom_tiplab(aes(color = label %in% to_drop)) + scale_color_manual(values=c(&quot;black&quot;, &quot;red&quot;)) + xlim(0, 0.8) nhx_reduced &lt;- drop.tip(nhx, to_drop) p2 &lt;- ggtree(nhx_reduced) + geom_tiplab() + xlim(0, 0.8) plot_grid(p1, p2, ncol=2, labels = c(&quot;A&quot;, &quot;B&quot;)) Figure 2.3: Removing tips from tree. Original tree with three tips (colored by red) to remove (A). Updated tree that removed selected tips (B). 2.4.2 Subsetting tree by tip label Tree can be large and difficult to look at only the portions of interest. The tree_subset() function was created in treeio package to extract a subset of the tree portion while still maintaining the structure of the tree portion. The beast_tree in Figure 2.4A is slighly crowded. Obviously, we can make the figure taller to allow more space for the labels (similar to use “Expansion” slider in FigTree) or we can make the text smaller. However, these solutions are not always applicable when you have a lot of tips (e.g. hundreds or thousands of tips). In particuarly, when you are only interested in the portion of the tree around a particular tip, you certainly don’t want to explore a large tree to find centain species you are interested in. Let’s say you are interested in tip A/Swine/HK/168/2012 from the tree (Figure 2.4A) and you want to look at the immediate relatives of this tip. The tree_subset() function allows for you to look at the portions of the tree that are of interest. By default, tree_subset() will internally call groupOTU() to assign group specified tip from the rest of other tips (Figure 2.4B). Additionally, the branch lengths and related associated data are maintained after subsetting (Figure 2.4C). The root of the tree is always anchored at zero for the subset tree by default and all the distances are relative to this root. If you want all the distances are relative to the original root, you can specify the root position (by root.position parameter) to the root edge of the subset tree, which is the sum of branch lengths from the original root to the root of the subset tree (Figure 2.4D and E). beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) p1 = ggtree(beast_tree) + geom_tiplab() + xlim(0, 40) + theme_tree2() tree2 = tree_subset(beast_tree, &quot;A/Swine/HK/168/2012&quot;, levels_back=4) p2 &lt;- ggtree(tree2, aes(color=group)) + scale_color_manual(values = c(&quot;black&quot;, &quot;red&quot;)) + geom_tiplab() + xlim(0, 4) + theme_tree2() p3 &lt;- ggtree(tree2, aes(color=group)) + geom_tiplab(hjust = -.1) + xlim(0, 5) + geom_point(aes(fill = rate), shape = 21, size = 4) + scale_color_manual(values = c(&quot;black&quot;, &quot;red&quot;), guide = FALSE) + scale_fill_continuous(low = &#39;blue&#39;, high = &#39;red&#39;) + theme_tree2() + theme(legend.position = &#39;right&#39;) p4 &lt;- ggtree(tree2, aes(color=group), root.position = as.phylo(tree2)$root.edge) + geom_tiplab() + xlim(18, 24) + scale_color_manual(values = c(&quot;black&quot;, &quot;red&quot;)) + theme_tree2() p5 &lt;- ggtree(tree2, aes(color=group), root.position = as.phylo(tree2)$root.edge) + geom_rootedge() + geom_tiplab() + xlim(0, 40) + scale_color_manual(values = c(&quot;black&quot;, &quot;red&quot;)) + theme_tree2() plot_grid(p2, p3, p4, p5, ncol=2, labels=LETTERS[2:5]) %&gt;% plot_grid(p1, ., ncol=2, labels=c(&quot;A&quot;, &quot;&quot;), rel_widths=c(.5, 1)) Figure 2.4: Subsetting tree for specific tip. The original tree (A). The subset tree (B). Subset tree with data (C). Visualize the subset tree relative to original position, without root edge (D) and with root edge (E). 2.4.3 Subsetting tree by internal node number If you are interesting at certain clade, you can specify the input node as an internal node number. The tree_subset() function will take the clade as a whole and also trace back to particular levels to look at the immediate relatives of the clade (Figure 2.5A and B). We can use tree_subset to zoom in selected portions and plot a whole tree with the portion of it, that is similar to the ape::zoom() function to explore very large tree (Figure 2.5C and D). clade &lt;- tree_subset(beast_tree, node=121, levels_back=0) clade2 &lt;- tree_subset(beast_tree, node=121, levels_back=2) p1 &lt;- ggtree(clade) + geom_tiplab() + xlim(0, 5) p2 &lt;- ggtree(clade2, aes(color=group)) + geom_tiplab() + xlim(0, 8) + scale_color_manual(values=c(&quot;black&quot;, &quot;red&quot;)) library(ape) library(tidytree) library(treeio) data(chiroptera) nodes &lt;- grep(&quot;Plecotus&quot;, chiroptera$tip.label) chiroptera &lt;- groupOTU(chiroptera, nodes) clade &lt;- MRCA(chiroptera, nodes) x &lt;- tree_subset(chiroptera, clade, levels_back = 0) p3 &lt;- ggtree(chiroptera, aes(colour = group)) + scale_color_manual(values=c(&quot;black&quot;, &quot;red&quot;)) + theme(legend.position = &quot;none&quot;) p4 &lt;- ggtree(x) + geom_tiplab() + xlim(0, 5) plot_grid(p1, p2, p3, p4, ncol=2, labels=LETTERS[1:4]) Figure 2.5: Subsetting tree for specific clade. Extracting a clade (A). Extracting a clade and trace back to look at its immediate relatives (B). Viewing a very large tree (C) and a selected portion of it (D). 2.5 Manipulating tree data for visualization Tree visualization is supported by ggtree. Although ggtree implemented several methods for visual exploration of tree with data, you may want to do something that is not supported directly. In this case, you need to manipulate tree data with node coordination positions that used for visualization. This is quite easy with ggtree. User can use foritfy() method which internally call tidytree::as_tibble() to convert the tree to tidy data frame and add columns of coordination positions (i.e. x, y, branch and angle) that are used to plot the tree. You can also access the data via ggtree(tree)$data. Here is an example to plot two trees face to face that is similar to a ape::cophyloplot(). library(dplyr) library(ggtree) x &lt;- rtree(30) y &lt;- rtree(30) p1 &lt;- ggtree(x) p2 &lt;- ggtree(y) d1 &lt;- p1$data d2 &lt;- p2$data ## reverse x-axis and ## set offset to make the tree in the right hand side of the first tree d2$x &lt;- max(d2$x) - d2$x + max(d1$x) + 1 pp &lt;- p1 + geom_tiplab() + geom_tree(data=d2) + geom_tiplab(data = d2, hjust=1) dd &lt;- bind_rows(d1, d2) %&gt;% filter(!is.na(label)) pp + geom_line(aes(x, y, group=label), data=dd, color=&#39;grey&#39;) Figure 2.6: Plot two phylogenetic trees face to face. Plotting a tree using ggtree() (left hand side) and subsequently add another layer of tree by geom_tree() (right hand side). The relative positions of the plotted trees can be manual adjusted and adding layers to each of the tree (e.g. tip labels) is independent. It is quite easy to plot multiple trees and connect taxa in one figure. For instance, plotting trees contructed from all internal gene segments of influenza virus and connecting equivalent strans across the trees (Venkatesh et al. 2018). z &lt;- rtree(30) d2 &lt;- fortify(y) d3 &lt;- fortify(z) d2$x &lt;- d2$x + max(d1$x) + 1 d3$x &lt;- d3$x + max(d2$x) + 1 dd = bind_rows(d1, d2, d3) %&gt;% filter(!is.na(label)) p1 + geom_tree(data = d2) + geom_tree(data = d3) + geom_tiplab(data=d3) + geom_line(aes(x, y, group=label, color=node &lt; 15), data=dd, alpha=.3) Figure 2.7: Plot multiple phylogenetic trees side by side. Plotting a tree using ggtree() and subsequently add multiple layers of trees by geom_tree(). 2.6 Summary The treeio package allows us to import diverse phylogeny associated data into R. However, phylogenetic tree is stored in way to facilitate computational processing which is not human fridenly and need expertise to manipulate and explore tree data. The tidytree package provides tidy interface for exploring tree data, while ggtree provides a set of utilitise to visualize and explore tree data using grammar of graphics. This full suit of packages make it easy for ordinary users to interact with tree data, and allow us to integrate phylogeny associated data from different sources (e.g. experimental result or analysis finding), which creates the possibility of comparative study. References "],
["chapter3.html", "Chapter 3 Exporting tree with data 3.1 Introduction 3.2 Exporting Tree Data to BEAST Nexus Format 3.3 Exporting Tree Data to jtree Format 3.4 Summary", " Chapter 3 Exporting tree with data 3.1 Introduction The treeio package supports parsing various phylogenetic tree file formats including software outputs that contain evolutionary evidences. Some of the formats are just log file (e.g. PAML and r8s outputs), while some of the others are non-standard formats (e.g. BEAST and MrBayes outputs that introduce square bracket, which was reserved to store comment in standard Nexus format, to store inferences). With treeio, we are now able to parse these files to extract phylogenetic tree and map associated data on the tree structure. Exporting tree structure is easy, users can use as.phyo method defined treeio to convert treedata object to phylo object then using write.tree or write.nexus implemented in ape package (Paradis, Claude, and Strimmer 2004) to export the tree structure as Newick text or Nexus file. This is quite useful for converting non-standard formats to standard format and for extracting tree from software outputs, such as log file. However, exporting tree with associated data is still challenging. These associated data can be parsed from analysis programs or obtained from external sources (e.g. phenotypic data, experimental data and clinical data). The major obstacle here is that there is no standard format that designed for storing tree with data. NeXML (Vos et al. 2012) maybe the most flexible format, however it is currently not widely supported. Most of the analysis programs in this field rely extensively on Newick string and Nexus format. In my opinion, although BEAST Nexus format9 may not be the best solution, it is currently a good approach for storing heterogeneous associated data. The beauty of the format is that all the annotate elements are stored within square bracket, which is reserved for comments. So that the file can be parsed as standard Nexus by ignoring annotate elements and existing programs should be able to read them. 3.2 Exporting Tree Data to BEAST Nexus Format 3.2.1 Exporting/converting software output The treeio package provides write.beast to export treedata object as BEAST Nexus file (Bouckaert et al. 2014). With treeio, it is easy to convert software output to BEAST format if the output can be parsed by treeio (see Chapter 1). For example, we can convert NHX file to BEAST file and use NHX tags to color the tree using FigTree10 (Figure 3.1A) or convert CODEML output and use dN/dS, dN or dS to color the tree in FigTree (Figure 3.1B). Here is an example of converting NHX file to BEAST format: nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) # write.beast(nhx, file = &quot;phyldog.tree&quot;) write.beast(nhx) #NEXUS [R-package treeio, Fri Aug 30 11:34:38 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;Ev=S,S=58,ND=0]:0.0682841,(2[&amp;Ev=S,S=69,ND=1]:0.0193941,3[&amp;Ev=S,S=70,ND=2]:0.0121378)[&amp;Ev=S,S=60,ND=3]:0.0217782)[&amp;Ev=S,S=36,ND=4]:0.0607598,((4[&amp;Ev=S,S=31,ND=9]:0.11832,(((5[&amp;Ev=S,S=37,ND=10]:0.0144549,6[&amp;Ev=S,S=38,ND=11]:0.0149723)[&amp;Ev=S,S=33,ND=12]:0.0925388,7[&amp;Ev=S,S=61,ND=13]:0.077429)[&amp;Ev=S,S=24,ND=14]:0.0274637,(8[&amp;Ev=S,S=52,ND=15]:0.0761163,((9[&amp;Ev=S,S=53,ND=16]:0.0906068,10[&amp;Ev=S,S=54,ND=17]:1e-06)[&amp;Ev=S,S=45,ND=18]:1e-06,((11[&amp;Ev=S,S=65,ND=19]:0.120851,12[&amp;Ev=S,S=71,ND=20]:0.133939)[&amp;Ev=S,S=56,ND=21]:1e-06,13[&amp;Ev=S,S=64,ND=22]:0.0693814)[&amp;Ev=S,S=46,ND=23]:1e-06)[&amp;Ev=S,S=40,ND=24]:0.0333823)[&amp;Ev=S,S=35,ND=25]:1e-06)[&amp;Ev=D,S=24,ND=26]:0.0431861)[&amp;Ev=S,S=19,ND=27]:1e-06,14[&amp;Ev=S,S=26,ND=28]:0.22283)[&amp;Ev=S,S=17,ND=29]:0.0292362)[&amp;Ev=D,S=17,ND=8]:0.185603,(15[&amp;Ev=S,S=16,ND=5]:0.0621782,16[&amp;Ev=S,S=15,ND=6]:0.332505)[&amp;Ev=S,S=12,ND=7]:0.185603)[&amp;Ev=S,S=9,ND=30]; END; Another example of converting CodeML output to BEAST format: mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) ml &lt;- read.codeml_mlc(mlcfile) # write.beast(ml, file = &quot;codeml.tree&quot;) write.beast(ml) #NEXUS [R-package treeio, Fri Aug 30 11:34:38 2019] BEGIN TAXA; DIMENSIONS NTAX = 15; TAXLABELS A B C D E F G H I J K L M N O ; END; BEGIN TREES; TRANSLATE 1 A, 2 B, 3 C, 4 D, 5 E, 6 F, 7 G, 8 H, 9 I, 10 J, 11 K, 12 L, 13 M, 14 N, 15 O ; TREE * UNTITLED = [&amp;U] (11[&amp;t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0224,dN=0.002,dS=0.0878,N_x_dN=3,S_x_dS=55.6]:0.081785,14[&amp;t=0.062,N=1514.9,S=633.1,dN_vs_dS=0.0095,dN=7e-04,dS=0.0689,N_x_dN=1,S_x_dS=43.6]:0.062341,(4[&amp;t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0385,dN=0.0033,dS=0.0849,N_x_dN=5,S_x_dS=53.8]:0.082021,(12[&amp;t=0.006,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0062,N_x_dN=0,S_x_dS=3.9]:0.005508,(10[&amp;t=0.014,N=1514.9,S=633.1,dN_vs_dS=0.0457,dN=7e-04,dS=0.0143,N_x_dN=1,S_x_dS=9]:0.013996,(7[&amp;t=0.046,N=1514.9,S=633.1,dN_vs_dS=0.1621,dN=0.006,dS=0.0373,N_x_dN=9.2,S_x_dS=23.6]:0.045746,((3[&amp;t=0.028,N=1514.9,S=633.1,dN_vs_dS=0.0461,dN=0.0013,dS=0.0282,N_x_dN=2,S_x_dS=17.9]:0.02773,(5[&amp;t=0.031,N=1514.9,S=633.1,dN_vs_dS=0.0641,dN=0.002,dS=0.0305,N_x_dN=3,S_x_dS=19.3]:0.031104,15[&amp;t=0.048,N=1514.9,S=633.1,dN_vs_dS=0.0538,dN=0.0026,dS=0.0485,N_x_dN=4,S_x_dS=30.7]:0.048389)23[&amp;t=0.008,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0094,N_x_dN=0,S_x_dS=6]:0.008328)22[&amp;t=0.016,N=1514.9,S=633.1,dN_vs_dS=0.0395,dN=7e-04,dS=0.0165,N_x_dN=1,S_x_dS=10.4]:0.015959,(8[&amp;t=0.021,N=1514.9,S=633.1,dN_vs_dS=0.1028,dN=0.002,dS=0.0191,N_x_dN=3,S_x_dS=12.1]:0.021007,(9[&amp;t=0.015,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0167,N_x_dN=0,S_x_dS=10.6]:0.014739,(2[&amp;t=0.032,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0358,N_x_dN=0,S_x_dS=22.7]:0.031643,(1[&amp;t=0.01,N=1514.9,S=633.1,dN_vs_dS=0.0646,dN=7e-04,dS=0.0101,N_x_dN=1,S_x_dS=6.4]:0.01034,(6[&amp;t=0.007,N=1514.9,S=633.1,dN_vs_dS=0.298,dN=0.0013,dS=0.0044,N_x_dN=2,S_x_dS=2.8]:0.006649,13[&amp;t=0.009,N=1514.9,S=633.1,dN_vs_dS=0.0738,dN=7e-04,dS=0.0088,N_x_dN=1,S_x_dS=5.6]:0.009195)28[&amp;t=0.028,N=1514.9,S=633.1,dN_vs_dS=0.0453,dN=0.0013,dS=0.0289,N_x_dN=2,S_x_dS=18.3]:0.028303)27[&amp;t=0.008,N=1514.9,S=633.1,dN_vs_dS=0.0863,dN=7e-04,dS=0.0076,N_x_dN=1,S_x_dS=4.8]:0.008072)26[&amp;t=0.003,N=1514.9,S=633.1,dN_vs_dS=1.5591,dN=0.0013,dS=8e-04,N_x_dN=2,S_x_dS=0.5]:0.0035)25[&amp;t=0.02,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.023,N_x_dN=0,S_x_dS=14.6]:0.020359)24[&amp;t=0.001,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=6e-04,N_x_dN=0,S_x_dS=0.4]:0.000555)21[&amp;t=0.024,N=1514.9,S=633.1,dN_vs_dS=0.0549,dN=0.0013,dS=0.0237,N_x_dN=2,S_x_dS=15]:0.023675)20[&amp;t=0.046,N=1514.9,S=633.1,dN_vs_dS=0.0419,dN=0.002,dS=0.047,N_x_dN=3,S_x_dS=29.8]:0.045745)19[&amp;t=0.015,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0166,N_x_dN=0,S_x_dS=10.5]:0.014684)18[&amp;t=0.059,N=1514.9,S=633.1,dN_vs_dS=0.0964,dN=0.0053,dS=0.0545,N_x_dN=8,S_x_dS=34.5]:0.059308)17[&amp;t=0.232,N=1514.9,S=633.1,dN_vs_dS=0.0129,dN=0.0033,dS=0.2541,N_x_dN=5,S_x_dS=160.9]:0.231628)16; END; Figure 3.1: Visualizing BEAST file in FigTree. Directly visualizing NHX file (A) and CodeML output (B) in FigTree is not supported. treeio can convert these files to BEAST compatible NEXUS format which can be directly opened in FigTree and visualized annotated data. 3.2.2 Combining tree with external data Using the utilities provided by tidytree and treeio, it is easy to link external data onto the corresponding phylogeny. The write.beast function enable users to export the tree with external data to a single tree file. phylo &lt;- as.phylo(nhx) ## print the newick text write.tree(phylo) [1] &quot;(((Prayidae_D27SS7@2825365:0.0682841,(Kephyes_ovata@2606431:0.0193941,Chuniphyes_multidentata@1277217:0.0121378):0.0217782):0.0607598,((Apolemia_sp_@1353964:0.11832,(((Bargmannia_amoena@263997:0.0144549,Bargmannia_elongata@946788:0.0149723):0.0925388,Physonect_sp_@2066767:0.077429):0.0274637,(Stephalia_dilata@2960089:0.0761163,((Frillagalma_vityazi@1155031:0.0906068,Resomia_ornicephala@3111757:1e-06):1e-06,((Lychnagalma_utricularia@2253871:0.120851,Nanomia_bijuga@717864:0.133939):1e-06,Cordagalma_sp_@1525873:0.0693814):1e-06):0.0333823):1e-06):0.0431861):1e-06,Rhizophysa_filiformis@3073669:0.22283):0.0292362):0.185603,(Hydra_magnipapillata@52244:0.0621782,Ectopleura_larynx@3556167:0.332505):0.185603);&quot; N &lt;- Nnode2(phylo) fake_data &lt;- tibble(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N)) fake_tree &lt;- full_join(phylo, fake_data, by = &quot;node&quot;) write.beast(fake_tree) #NEXUS [R-package treeio, Fri Aug 30 11:34:41 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;fake_trait=-0.118140158479532,another_trait=0.358319966588169]:0.0682841,(2[&amp;fake_trait=-1.02308336346315,another_trait=0.178163790609688]:0.0193941,3[&amp;fake_trait=0.103599672229184,another_trait=0.93473564600572]:0.0121378)[&amp;fake_trait=-0.59581303574252,another_trait=0.922105083474889]:0.0217782)[&amp;fake_trait=-0.300012313113108,another_trait=0.119739749003202]:0.0607598,(14[&amp;fake_trait=0.589053316158453,another_trait=0.565819646697491]:0.22283,(4[&amp;fake_trait=-0.765460180119788,another_trait=0.888429019600153]:0.11832,((7[&amp;fake_trait=-0.306908277375037,another_trait=0.650574740953743]:0.077429,(5[&amp;fake_trait=-0.357587376956114,another_trait=0.547185462666675]:0.0144549,6[&amp;fake_trait=0.582576884787801,another_trait=0.00538489152677357]:0.0149723)[&amp;fake_trait=1.68690137848482,another_trait=0.634304485516623]:0.0925388)[&amp;fake_trait=1.00444824814337,another_trait=0.420116872293875]:0.0274637,(8[&amp;fake_trait=1.10912385375853,another_trait=0.583255837904289]:0.0761163,((9[&amp;fake_trait=-0.707380205642954,another_trait=0.808900895994157]:0.0906068,10[&amp;fake_trait=0.838100693609065,another_trait=0.0142157829832286]:1e-06)[&amp;fake_trait=-0.509864481867074,another_trait=0.939013464609161]:1e-06,(13[&amp;fake_trait=1.56583127248603,another_trait=0.0454649559687823]:0.0693814,(11[&amp;fake_trait=1.45882763141046,another_trait=0.516774294432253]:0.120851,12[&amp;fake_trait=2.43471798636817,another_trait=0.00467536062933505]:0.133939)[&amp;fake_trait=-1.07656365665571,another_trait=0.518969761673361]:1e-06)[&amp;fake_trait=-1.48426105861817,another_trait=0.044428545050323]:1e-06)[&amp;fake_trait=0.409198668366587,another_trait=0.538205695804209]:0.0333823)[&amp;fake_trait=-0.692527146833782,another_trait=0.58515489147976]:1e-06)[&amp;fake_trait=-1.41216094329287,another_trait=0.935482121771201]:0.0431861)[&amp;fake_trait=1.65980403458888,another_trait=0.125082567567006]:1e-06)[&amp;fake_trait=0.476325081878056,another_trait=0.262554442277178]:0.0292362)[&amp;fake_trait=1.15832764983724,another_trait=0.646949481917545]:0.185603,(15[&amp;fake_trait=0.704447323258862,another_trait=0.663062628591433]:0.0621782,16[&amp;fake_trait=-0.659190065346089,another_trait=0.505218442762271]:0.332505)[&amp;fake_trait=-1.04282102019802,another_trait=0.641324875177816]:0.185603)[&amp;fake_trait=-0.479609047683268,another_trait=0.519890103489161]; END; After merging, the fake_trait and another_trait stored in fake_data will be linked to the tree, phylo, and store in the treedata object, the fake_tree. The write.beast() function export the tree with associated data to a single BEAST format file. The associated data can be used to visualized the tree using ggtree (Figure 5.7) or FigTree (Figure 3.1). 3.2.3 Merging tree data from different sources Not only Newick tree text can be combined with associated data, but also tree data obtained from software output can be combined with external data, as well as different tree objects can be merged together (for details, see Chapter 2). ## combine tree object with data tree_with_data &lt;- full_join(nhx, fake_data, by = &quot;node&quot;) tree_with_data ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. ## merge two tree object tree2 &lt;- merge_tree(nhx, fake_tree) tree2 ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. identical(tree_with_data, tree2) ## [1] TRUE After merging data from different sources, the tree with the associated data can be exported into a single file. write.beast(tree2) #NEXUS [R-package treeio, Fri Aug 30 11:34:41 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;Ev=S,S=58,ND=0,fake_trait=-0.118140158479532,another_trait=0.358319966588169]:0.0682841,(2[&amp;Ev=S,S=69,ND=1,fake_trait=-1.02308336346315,another_trait=0.178163790609688]:0.0193941,3[&amp;Ev=S,S=70,ND=2,fake_trait=0.103599672229184,another_trait=0.93473564600572]:0.0121378)[&amp;Ev=S,S=60,ND=3,fake_trait=-0.59581303574252,another_trait=0.922105083474889]:0.0217782)[&amp;Ev=S,S=36,ND=4,fake_trait=-0.300012313113108,another_trait=0.119739749003202]:0.0607598,((4[&amp;Ev=S,S=31,ND=9,fake_trait=-0.765460180119788,another_trait=0.888429019600153]:0.11832,(((5[&amp;Ev=S,S=37,ND=10,fake_trait=-0.357587376956114,another_trait=0.547185462666675]:0.0144549,6[&amp;Ev=S,S=38,ND=11,fake_trait=0.582576884787801,another_trait=0.00538489152677357]:0.0149723)[&amp;Ev=S,S=33,ND=12,fake_trait=1.68690137848482,another_trait=0.634304485516623]:0.0925388,7[&amp;Ev=S,S=61,ND=13,fake_trait=-0.306908277375037,another_trait=0.650574740953743]:0.077429)[&amp;Ev=S,S=24,ND=14,fake_trait=1.00444824814337,another_trait=0.420116872293875]:0.0274637,(8[&amp;Ev=S,S=52,ND=15,fake_trait=1.10912385375853,another_trait=0.583255837904289]:0.0761163,((9[&amp;Ev=S,S=53,ND=16,fake_trait=-0.707380205642954,another_trait=0.808900895994157]:0.0906068,10[&amp;Ev=S,S=54,ND=17,fake_trait=0.838100693609065,another_trait=0.0142157829832286]:1e-06)[&amp;Ev=S,S=45,ND=18,fake_trait=-0.509864481867074,another_trait=0.939013464609161]:1e-06,((11[&amp;Ev=S,S=65,ND=19,fake_trait=1.45882763141046,another_trait=0.516774294432253]:0.120851,12[&amp;Ev=S,S=71,ND=20,fake_trait=2.43471798636817,another_trait=0.00467536062933505]:0.133939)[&amp;Ev=S,S=56,ND=21,fake_trait=-1.07656365665571,another_trait=0.518969761673361]:1e-06,13[&amp;Ev=S,S=64,ND=22,fake_trait=1.56583127248603,another_trait=0.0454649559687823]:0.0693814)[&amp;Ev=S,S=46,ND=23,fake_trait=-1.48426105861817,another_trait=0.044428545050323]:1e-06)[&amp;Ev=S,S=40,ND=24,fake_trait=0.409198668366587,another_trait=0.538205695804209]:0.0333823)[&amp;Ev=S,S=35,ND=25,fake_trait=-0.692527146833782,another_trait=0.58515489147976]:1e-06)[&amp;Ev=D,S=24,ND=26,fake_trait=-1.41216094329287,another_trait=0.935482121771201]:0.0431861)[&amp;Ev=S,S=19,ND=27,fake_trait=1.65980403458888,another_trait=0.125082567567006]:1e-06,14[&amp;Ev=S,S=26,ND=28,fake_trait=0.589053316158453,another_trait=0.565819646697491]:0.22283)[&amp;Ev=S,S=17,ND=29,fake_trait=0.476325081878056,another_trait=0.262554442277178]:0.0292362)[&amp;Ev=D,S=17,ND=8,fake_trait=1.15832764983724,another_trait=0.646949481917545]:0.185603,(15[&amp;Ev=S,S=16,ND=5,fake_trait=0.704447323258862,another_trait=0.663062628591433]:0.0621782,16[&amp;Ev=S,S=15,ND=6,fake_trait=-0.659190065346089,another_trait=0.505218442762271]:0.332505)[&amp;Ev=S,S=12,ND=7,fake_trait=-1.04282102019802,another_trait=0.641324875177816]:0.185603)[&amp;Ev=S,S=9,ND=30,fake_trait=-0.479609047683268,another_trait=0.519890103489161]; END; The output BEAST Nexus file can be imported into R using the read.beast function and all the associated data can be used to annotate the tree using ggtree (Yu et al. 2017). outfile &lt;- tempfile(fileext = &quot;.tree&quot;) write.beast(tree2, file = outfile) read.beast(outfile) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/tmp/RtmpUfeAdI/file2ed07b7afbab.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;another_trait&#39;, &#39;Ev&#39;, &#39;fake_trait&#39;, &#39;ND&#39;, &#39;S&#39;. 3.3 Exporting Tree Data to jtree Format The treeio package provides write.beast to export treedata to BEAST Nexus file. This is quite useful to convert file format, combine tree with data and merging tree data from different sources as we demonstrated in session 3.2. The treeio package also supplies read.beast function to parse output file of write.beast. Although with treeio, the R community has the ability to manipulate BEAST Nexus format and process tree data, there is still lacking library/package for parsing BEAST file in other programming language. JSON (JavaScript Object Notation) is a lightweight data-interchange format and widely supported in almost all modern programming languages. To make it easy to import tree with data in other programming languages, treeio supports exporting tree with data in jtree format, which is JSON-based and can be easy to parse using any languages that supports JSON. write.jtree(tree2) { &quot;tree&quot;: &quot;(((Prayidae_D27SS7@2825365:0.0682841{1},(Kephyes_ovata@2606431:0.0193941{2},Chuniphyes_multidentata@1277217:0.0121378{3}):0.0217782{20}):0.0607598{19},((Apolemia_sp_@1353964:0.11832{4},(((Bargmannia_amoena@263997:0.0144549{5},Bargmannia_elongata@946788:0.0149723{6}):0.0925388{25},Physonect_sp_@2066767:0.077429{7}):0.0274637{24},(Stephalia_dilata@2960089:0.0761163{8},((Frillagalma_vityazi@1155031:0.0906068{9},Resomia_ornicephala@3111757:1{10}e-06):1{28}e-06,((Lychnagalma_utricularia@2253871:0.120851{11},Nanomia_bijuga@717864:0.133939{12}):1{30}e-06,Cordagalma_sp_@1525873:0.0693814{13}):1{29}e-06):0.0333823{27}):1{26}e-06):0.0431861{23}):1{22}e-06,Rhizophysa_filiformis@3073669:0.22283{14}):0.0292362{21}):0.185603{18},(Hydra_magnipapillata@52244:0.0621782{15},Ectopleura_larynx@3556167:0.332505{16}):0.185603{31}){17};&quot;, &quot;data&quot;:[ { &quot;edge_num&quot;: 1, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;58&quot;, &quot;ND&quot;: 0, &quot;fake_trait&quot;: -0.1181, &quot;another_trait&quot;: 0.3583 }, { &quot;edge_num&quot;: 2, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;69&quot;, &quot;ND&quot;: 1, &quot;fake_trait&quot;: -1.0231, &quot;another_trait&quot;: 0.1782 }, { &quot;edge_num&quot;: 3, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;70&quot;, &quot;ND&quot;: 2, &quot;fake_trait&quot;: 0.1036, &quot;another_trait&quot;: 0.9347 }, { &quot;edge_num&quot;: 4, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;31&quot;, &quot;ND&quot;: 9, &quot;fake_trait&quot;: -0.7655, &quot;another_trait&quot;: 0.8884 }, { &quot;edge_num&quot;: 5, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;37&quot;, &quot;ND&quot;: 10, &quot;fake_trait&quot;: -0.3576, &quot;another_trait&quot;: 0.5472 }, { &quot;edge_num&quot;: 6, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;38&quot;, &quot;ND&quot;: 11, &quot;fake_trait&quot;: 0.5826, &quot;another_trait&quot;: 0.0054 }, { &quot;edge_num&quot;: 7, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;61&quot;, &quot;ND&quot;: 13, &quot;fake_trait&quot;: -0.3069, &quot;another_trait&quot;: 0.6506 }, { &quot;edge_num&quot;: 8, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;52&quot;, &quot;ND&quot;: 15, &quot;fake_trait&quot;: 1.1091, &quot;another_trait&quot;: 0.5833 }, { &quot;edge_num&quot;: 9, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;53&quot;, &quot;ND&quot;: 16, &quot;fake_trait&quot;: -0.7074, &quot;another_trait&quot;: 0.8089 }, { &quot;edge_num&quot;: 10, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;54&quot;, &quot;ND&quot;: 17, &quot;fake_trait&quot;: 0.8381, &quot;another_trait&quot;: 0.0142 }, { &quot;edge_num&quot;: 11, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;65&quot;, &quot;ND&quot;: 19, &quot;fake_trait&quot;: 1.4588, &quot;another_trait&quot;: 0.5168 }, { &quot;edge_num&quot;: 12, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;71&quot;, &quot;ND&quot;: 20, &quot;fake_trait&quot;: 2.4347, &quot;another_trait&quot;: 0.0047 }, { &quot;edge_num&quot;: 13, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;64&quot;, &quot;ND&quot;: 22, &quot;fake_trait&quot;: 1.5658, &quot;another_trait&quot;: 0.0455 }, { &quot;edge_num&quot;: 14, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;26&quot;, &quot;ND&quot;: 28, &quot;fake_trait&quot;: 0.5891, &quot;another_trait&quot;: 0.5658 }, { &quot;edge_num&quot;: 15, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;16&quot;, &quot;ND&quot;: 5, &quot;fake_trait&quot;: 0.7044, &quot;another_trait&quot;: 0.6631 }, { &quot;edge_num&quot;: 16, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;15&quot;, &quot;ND&quot;: 6, &quot;fake_trait&quot;: -0.6592, &quot;another_trait&quot;: 0.5052 }, { &quot;edge_num&quot;: 17, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;9&quot;, &quot;ND&quot;: 30, &quot;fake_trait&quot;: -0.4796, &quot;another_trait&quot;: 0.5199 }, { &quot;edge_num&quot;: 18, &quot;Ev&quot;: &quot;D&quot;, &quot;S&quot;: &quot;17&quot;, &quot;ND&quot;: 8, &quot;fake_trait&quot;: 1.1583, &quot;another_trait&quot;: 0.6469 }, { &quot;edge_num&quot;: 19, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;36&quot;, &quot;ND&quot;: 4, &quot;fake_trait&quot;: -0.3, &quot;another_trait&quot;: 0.1197 }, { &quot;edge_num&quot;: 20, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;60&quot;, &quot;ND&quot;: 3, &quot;fake_trait&quot;: -0.5958, &quot;another_trait&quot;: 0.9221 }, { &quot;edge_num&quot;: 21, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;17&quot;, &quot;ND&quot;: 29, &quot;fake_trait&quot;: 0.4763, &quot;another_trait&quot;: 0.2626 }, { &quot;edge_num&quot;: 22, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;19&quot;, &quot;ND&quot;: 27, &quot;fake_trait&quot;: 1.6598, &quot;another_trait&quot;: 0.1251 }, { &quot;edge_num&quot;: 23, &quot;Ev&quot;: &quot;D&quot;, &quot;S&quot;: &quot;24&quot;, &quot;ND&quot;: 26, &quot;fake_trait&quot;: -1.4122, &quot;another_trait&quot;: 0.9355 }, { &quot;edge_num&quot;: 24, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;24&quot;, &quot;ND&quot;: 14, &quot;fake_trait&quot;: 1.0044, &quot;another_trait&quot;: 0.4201 }, { &quot;edge_num&quot;: 25, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;33&quot;, &quot;ND&quot;: 12, &quot;fake_trait&quot;: 1.6869, &quot;another_trait&quot;: 0.6343 }, { &quot;edge_num&quot;: 26, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;35&quot;, &quot;ND&quot;: 25, &quot;fake_trait&quot;: -0.6925, &quot;another_trait&quot;: 0.5852 }, { &quot;edge_num&quot;: 27, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;40&quot;, &quot;ND&quot;: 24, &quot;fake_trait&quot;: 0.4092, &quot;another_trait&quot;: 0.5382 }, { &quot;edge_num&quot;: 28, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;45&quot;, &quot;ND&quot;: 18, &quot;fake_trait&quot;: -0.5099, &quot;another_trait&quot;: 0.939 }, { &quot;edge_num&quot;: 29, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;46&quot;, &quot;ND&quot;: 23, &quot;fake_trait&quot;: -1.4843, &quot;another_trait&quot;: 0.0444 }, { &quot;edge_num&quot;: 30, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;56&quot;, &quot;ND&quot;: 21, &quot;fake_trait&quot;: -1.0766, &quot;another_trait&quot;: 0.519 }, { &quot;edge_num&quot;: 31, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;12&quot;, &quot;ND&quot;: 7, &quot;fake_trait&quot;: -1.0428, &quot;another_trait&quot;: 0.6413 } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;R-package treeio&quot;, &quot;data&quot;: &quot;Fri Aug 30 11:34:41 2019&quot;} } The jtree format is based on JSON and can be parsed using JSON parser. jtree_file &lt;- tempfile(fileext = &#39;.jtree&#39;) write.jtree(tree2, file = jtree_file) jsonlite::fromJSON(jtree_file) $tree [1] &quot;(((Prayidae_D27SS7@2825365:0.0682841{1},(Kephyes_ovata@2606431:0.0193941{2},Chuniphyes_multidentata@1277217:0.0121378{3}):0.0217782{20}):0.0607598{19},((Apolemia_sp_@1353964:0.11832{4},(((Bargmannia_amoena@263997:0.0144549{5},Bargmannia_elongata@946788:0.0149723{6}):0.0925388{25},Physonect_sp_@2066767:0.077429{7}):0.0274637{24},(Stephalia_dilata@2960089:0.0761163{8},((Frillagalma_vityazi@1155031:0.0906068{9},Resomia_ornicephala@3111757:1{10}e-06):1{28}e-06,((Lychnagalma_utricularia@2253871:0.120851{11},Nanomia_bijuga@717864:0.133939{12}):1{30}e-06,Cordagalma_sp_@1525873:0.0693814{13}):1{29}e-06):0.0333823{27}):1{26}e-06):0.0431861{23}):1{22}e-06,Rhizophysa_filiformis@3073669:0.22283{14}):0.0292362{21}):0.185603{18},(Hydra_magnipapillata@52244:0.0621782{15},Ectopleura_larynx@3556167:0.332505{16}):0.185603{31}){17};&quot; $data edge_num Ev S ND fake_trait another_trait 1 1 S 58 0 -0.1181 0.3583 2 2 S 69 1 -1.0231 0.1782 3 3 S 70 2 0.1036 0.9347 4 4 S 31 9 -0.7655 0.8884 5 5 S 37 10 -0.3576 0.5472 6 6 S 38 11 0.5826 0.0054 7 7 S 61 13 -0.3069 0.6506 8 8 S 52 15 1.1091 0.5833 9 9 S 53 16 -0.7074 0.8089 10 10 S 54 17 0.8381 0.0142 11 11 S 65 19 1.4588 0.5168 12 12 S 71 20 2.4347 0.0047 13 13 S 64 22 1.5658 0.0455 14 14 S 26 28 0.5891 0.5658 15 15 S 16 5 0.7044 0.6631 16 16 S 15 6 -0.6592 0.5052 17 17 S 9 30 -0.4796 0.5199 18 18 D 17 8 1.1583 0.6469 19 19 S 36 4 -0.3000 0.1197 20 20 S 60 3 -0.5958 0.9221 21 21 S 17 29 0.4763 0.2626 22 22 S 19 27 1.6598 0.1251 23 23 D 24 26 -1.4122 0.9355 24 24 S 24 14 1.0044 0.4201 25 25 S 33 12 1.6869 0.6343 26 26 S 35 25 -0.6925 0.5852 27 27 S 40 24 0.4092 0.5382 28 28 S 45 18 -0.5099 0.9390 29 29 S 46 23 -1.4843 0.0444 30 30 S 56 21 -1.0766 0.5190 31 31 S 12 7 -1.0428 0.6413 $metadata $metadata$info [1] &quot;R-package treeio&quot; $metadata$data [1] &quot;Fri Aug 30 11:34:41 2019&quot; The jtree file can be directly imported as a treedata object using read.jtree provided also in treeio package (see also session 1.3). read.jtree(jtree_file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;/tmp/RtmpUfeAdI/file2ed06b2b0c47.jtree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. 3.4 Summary Phylogenetic tree associated data is often stored in a separate file and need expertise to map the data to the tree structure. Lacking standardization to store and represent phylogeny and associated data makes it difficult for researchers to access and integrate the phylogenetic data into their studies. The treeio package provides functions to import phylogeny with associated data from a number of sources, including analysis finding from commonly used software and external data such as experimental, clinical or meta data. These tree + data can be exported into a single file as a BEAST or jtree formats, and the output file can be parsed back to R by treeio and the data is easy to access. The input and output utilities supplied by treeio package lay the foundation for phylogenetic data integration for downstream comparative study and visualization. References "],
["chapter4.html", "Chapter 4 Phylogenetic Tree Visualization 4.1 Introduction 4.2 Visualizing Phylogenetic Tree with ggtree 4.3 Displaying Tree Components 4.4 Visualize a list of trees 4.5 Summary", " Chapter 4 Phylogenetic Tree Visualization 4.1 Introduction There are many software packages and webtools that are designed for displaying phylogenetic trees, such as TreeView (Page 2002), FigTree11, TreeDyn (Chevenet et al. 2006), Dendroscope (Huson and Scornavacca 2012), EvolView (He et al. 2016) and iTOL (Letunic and Bork 2007), etc.. Only several of them, such as FigTree, TreeDyn and iTOL, allow users to annotate the trees with coloring branches, highlighted clades and tree features. However, their pre-defined annotating functions are usually limited to some specific phylogenetic data. As phylogenetic trees are becoming more widely used in multidisciplinary studies, there is an increasing need to incorporate various types of the phylogenetic covariates and other associated data from different sources into the trees for visualizations and further analyses. For instance, influenza virus has a wide host range, diverse and dynamic genotypes and characteristic transmission behaviors that are mostly associated with the virus evolution and essentially among themselves. Therefore, in addition to standalone applications that focus on each of the specific analysis and data type, researchers studying molecular evolution need a robust and programmable platform that allows the high levels of integration and visualization of many of these different aspects of data (raw or from other primary analyses) over the phylogenetic trees to identify their associations and patterns. To fill this gap, we developed ggtree, a package for the R programming language (R Core Team 2016) released under the Bioconductor project (Gentleman et al. 2004). The ggtree is built to work with phylogenetic data object (see chapter 1 and chapter 9), and display tree graphics with ggplot2 package (Wickham 2016) that was based on the grammar of graphics (Wilkinson et al. 2005). The R language is increasingly being used in phylogenetics. However, a comprehensive package, designed for viewing and annotating phylogenetic trees, particularly with complex data integration, is not yet available. Most of the R packages in phylogenetics focus on specific statistical analyses rather than viewing and annotating the trees with more generalized phylogeny-associated data. Some packages, including ape (Paradis, Claude, and Strimmer 2004) and phytools (Revell 2012), which are capable of displaying and annotating trees, are developed using the base graphics system of R. In particular, ape is one of the fundamental package for phylogenetic analysis and data processing. However, the base graphics system is relatively difficult to extend and limits the complexity of tree figure to be displayed. OutbreakTools (Jombart et al. 2014) and phyloseq (McMurdie and Holmes 2013) extended ggplot2 to plot phylogenetic trees. The ggplot2 system of graphics allows rapid customization and exploration of design solutions. However these packages were designed for epidemiology and microbiome data respectively and did not aim to provide a general solution for tree visualization and annotation. The ggtree package also inherits versatile properties of ggplot2, and more importantly allows constructing complex tree figures by freely combining multiple layers of annotations using the tree associated data imported from different sources (see detailed in Chapter 1). 4.2 Visualizing Phylogenetic Tree with ggtree The ggtree package is designed for annotating phylogenetic trees with their associated data of different types and from various sources. These data could come from users or analysis programs, and might include evolutionary rates, ancestral sequences, etc. that are associated with the taxa from real samples, or with the internal nodes representing hypothetic ancestor strain/species, or with the tree branches indicating evolutionary time courses. For instance, the data could be the geographic positions of the sampled avian influenza viruses (informed by the survey locations) and the ancestral nodes (by phylogeographic inference) in the viral gene tree (Lam et al. 2012). The ggtree supports ggplot2’s graphical language, which allows high level of customization, is intuitive and flexible. It is notable that ggplot2 itself does not provide low-level geometric objects or other support for tree-like structures, and hence ggtree is a useful extension on that regard. Even though the other two phylogenetics-related R packages, OutbreakTools and phyloseq, are developed based on ggplot2, the most valuable part of ggplot2 syntax - adding layers of annotations - is not supported in these packages. For example, if we have plotted a tree without taxa labels, OutbreakTools and phyloseq provide no easy way for general R users, who have little knowledge about the infrastructures of these packages, to add a layer of taxa labels. The ggtree extends ggplot2 to support tree objects by implementing a geometric layer, geom_tree, to support visualizing tree structure. In ggtree, viewing a phylogenetic tree is relatively easy, via the command ggplot(tree_object) + geom_tree() + theme_tree() or ggtree(tree_object) for short. Layers of annotations can be added one by one via the + operator. To facilitate tree visualization, ggtree provides several geometric layers, including geom_treescale for adding legend of tree branch scale (genetic distance, divergence time, etc.), geom_range for displaying uncertainty of branch lengths (confidence interval or range, etc.), geom_tiplab for adding taxa label, geom_tippoint and geom_nodepoint for adding symbols of tips and internal nodes, geom_hilight for highlighting a clade with rectangle, and geom_cladelabel for annotating a selected clade with a bar and text label, etc.. A full list of geometric layers provided by ggtree are summarized in Table 5.1. To view a phylogenetic tree, we first need to parse the tree file into R. Treeio package parses diverse annotation data from different software outputs into S4 phylogenetic data objects. The ggtree mainly utilizes these S4 objects to display and annotate the tree. There are also other R packages that defined S3/S4 classes to store phylogenetic trees with domain specific associated data, including phylo4 and phylo4d defined in phylobase package, obkdata defined in OutbreakTools package, and phyloseq defined in phyloseq package (see also Chapter 9). All these tree objects are also supported in ggtree and their specific annotation data can be used to annotate the tree in ggtree. Such compatibility of ggtree facilitates the integration of data and analysis results. In addition, ggtree also supports other tree-like structure, including dendrogram. 4.2.1 Basic Tree Visualization The ggtree package extends ggplot2 (Wickham 2009) package to support viewing phylogenetic tree. It implements geom_tree layer for displaying phylogenetic tree, as shown below in Figure 4.1A. library(&quot;treeio&quot;) library(&quot;ggtree&quot;) nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) ggplot(tree, aes(x, y)) + geom_tree() + theme_tree() The function, ggtree, was implemented as a short cut to visualize a tree, and it works exactly the same as shown above. ggtree takes all the advantages of ggplot2. For example, we can change the color, size and type of the lines as we do with ggplot2 (Figure 4.1B). ggtree(tree, color=&quot;firebrick&quot;, size=1, linetype=&quot;dotted&quot;) By default, the tree is viewed in ladderize form, user can set the parameter ladderize = FALSE to disable it (Figure 4.1C). ggtree(tree, ladderize=FALSE) The branch.length is used to scale the edge, user can set the parameter branch.length = \"none\" to only view the tree topology (cladogram, Figure 4.1D) or other numerical variable to scale the tree (e.g. dN/dS, see also in Chapter 5). ggtree(tree, branch.length=&quot;none&quot;) Figure 4.1: Basic tree visualization. 4.2.2 Layouts of phylogenetic tree Viewing phylogenetic with ggtree is quite simple, just pass the tree object to ggtree function. We have developed several types of layouts for tree presentation (Figure 4.2), including rectangular (by default), slanted, circular, fan, unrooted (equal angle and daylight methods), time-scaled and 2-dimensional layouts. Here are examples of visualizing a tree with different layouts: library(ggtree) set.seed(2017-02-16) tree &lt;- rtree(50) ggtree(tree) ggtree(tree, layout=&quot;slanted&quot;) ggtree(tree, layout=&quot;circular&quot;) ggtree(tree, layout=&quot;fan&quot;, open.angle=120) ggtree(tree, layout=&quot;equal_angle&quot;) ggtree(tree, layout=&quot;daylight&quot;) ggtree(tree, branch.length=&#39;none&#39;) ggtree(tree, branch.length=&#39;none&#39;, layout=&#39;circular&#39;) ggtree(tree, layout=&quot;daylight&quot;, branch.length = &#39;none&#39;) Figure 4.2: Tree layouts. Phylogram: rectangular layout (A), slanted layout (B), circular layout (C) and fan layout (D). Unrooted: equal-angle method (E) and daylight method (F). Cladogram: rectangular layout (G), circular layout (H) and unrooted layout (I). Slanted and fan layouts for cladogram are also supported. There are also other possible layouts that can be drawn by modifying scales/coordination (Figure 4.3). ggtree(tree) + scale_x_reverse() ggtree(tree) + coord_flip() ggtree(tree) + layout_dendrogram() print(ggtree(tree), newpage=TRUE, vp=grid::viewport(angle=-30, width=.9, height=.9)) ggtree(tree, layout=&#39;slanted&#39;) + coord_flip() ggtree(tree, layout=&#39;slanted&#39;, branch.length=&#39;none&#39;) + layout_dendrogram() ggtree(tree, layout=&#39;circular&#39;) + xlim(-10, NA) ggtree(tree) + scale_x_reverse() + coord_polar(theta=&#39;y&#39;) ggtree(tree) + scale_x_reverse(limits=c(10, 0)) + coord_polar(theta=&#39;y&#39;) Figure 4.3: Derived Tree layouts. right-to-left rectangular layout (A), bottom-up rectangular layout (B), top-down rectangular layout (Dendrogram) (C), rotated rectangular layout (D), bottom-up slanted layout (E), top-down slanted layout (Cladogram) (F), circular layout (G), circular inward layout (H and I). Phylogram. Layouts of rectangular, slanted, circular and fan are supported to visualize phylogram (by default, with branch length scaled) as demonstrated in Figure 4.2A, B, C and D. Unrooted layout. Unrooted (also called ‘radial’) layout is supported by equal-angle and daylight algorithms, user can specify unrooted layout algorithm by passing “equal_angle” or “daylight” to layout parameter to visualize the tree. Equal-angle method was proposed by Christopher Meacham in PLOTREE, which was incorporated in PHYLIP (Retief 2000). This method starts from the root of the tree and allocates arcs of angle to each subtrees proportional to the number of tips in it. It iterates from root to tips and subdivides the angle allocated to a subtree into angles for its dependent subtrees. This method is fast and was implemented in many software packages. As shown in Figure 4.2E, equal angle method has a drawback that tips are tend to be clustered together and leaving many spaces unused. The daylight method starts from an initial tree built by equal angle and iteratively improves it by successively going to each interior node and swinging subtrees so that the arcs of “daylight” are equal (Figure 4.2F). This method was firstly implemented in PAUP* (Wilgenbusch and Swofford 2003). Cladogram. To visualize cladogram that without branch length scaling and only display the tree structure, branch.length is set to “none” and it works for all types of layouts (Figure 4.2G, H and I). Time-scaled layout. For time-scaled tree, the most recent sampling date must be specified via the mrsd parameter and ggtree will scaled the tree by sampling (tip) and divergence (internal node) time, and a time scale axis will be displayed under the tree by default. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + theme_tree2() Figure 4.4: Time-scaled layout. The x-axis is the timescale (in units of year). The divergence time was inferred by BEAST using molecular clock model. Two-dimensional tree layout. A two-dimensional tree is a projection of the phylogenetic tree in a space defined by the associated phenotype (numerical or categorical trait, on the y-axis) and tree branch scale (e.g., evolutionary distance, divergent time, on the x-axis). The phenotype can be a measure of certain biological characteristics of the taxa and hypothetical ancestors in the tree. This is a new layout we proposed in ggtree, which is useful to track the virus phenotypes or other behaviors (y-axis) changing with the virus evolution (x-axis). In fact, the analysis of phenotypes or genotypes over evolutionary time have been widely used for study influenza virus evolution (Neher et al. 2016), though such analysis diagrams are not tree-like, i.e., no connection between data points, unlike our two-dimensional tree layout that connect data points with the corresponding tree branches. Therefore, this new layout we provided will make such data analysis easier and more scalable for large sequence data sets of influenza viruses. In this example, we used the previous time-scaled tree of H3 human and swine influenza viruses (Figure 4.4; data published in (Liang et al. 2014)) and scaled the y-axis based on the predicted N-linked glycosylation sites (NLG) for each of the taxon and ancestral sequences of hemagglutinin proteins. The NLG sites were predicted using NetNGlyc 1.0 Server12. To scaled the y-axis, the parameter yscale in the ggtree() function is set to a numerical or categorical variable. If yscale is a categorical variable as in this example, users should specify how the categories are to be mapped to numerical values via the yscale_mapping variables. NAG_file &lt;- system.file(&quot;examples/NAG_inHA1.txt&quot;, package=&quot;ggtree&quot;) NAG.df &lt;- read.table(NAG_file, sep=&quot;\\t&quot;, header=FALSE, stringsAsFactors = FALSE) NAG &lt;- NAG.df[,2] names(NAG) &lt;- NAG.df[,1] ## separate the tree by host species tip &lt;- get.tree(beast_tree)$tip.label beast_tree &lt;- groupOTU(beast_tree, tip[grep(&quot;Swine&quot;, tip)], group_name = &quot;host&quot;) p &lt;- ggtree(beast_tree, aes(color=host), mrsd=&quot;2013-01-01&quot;, yscale = &quot;label&quot;, yscale_mapping = NAG) + theme_classic() + theme(legend.position=&#39;none&#39;) + scale_color_manual(values=c(&quot;blue&quot;, &quot;red&quot;), labels=c(&quot;human&quot;, &quot;swine&quot;)) + ylab(&quot;Number of predicted N-linked glycoslyation sites&quot;) ## (optional) add more annotations to help interpretation p + geom_nodepoint(color=&quot;grey&quot;, size=3, alpha=.8) + geom_rootpoint(color=&quot;black&quot;, size=3) + geom_tippoint(size=3, alpha=.5) + annotate(&quot;point&quot;, 1992, 5.6, size=3, color=&quot;black&quot;) + annotate(&quot;point&quot;, 1992, 5.4, size=3, color=&quot;grey&quot;) + annotate(&quot;point&quot;, 1991.6, 5.2, size=3, color=&quot;blue&quot;) + annotate(&quot;point&quot;, 1992, 5.2, size=3, color=&quot;red&quot;) + annotate(&quot;text&quot;, 1992.3, 5.6, hjust=0, size=4, label=&quot;Root node&quot;) + annotate(&quot;text&quot;, 1992.3, 5.4, hjust=0, size=4, label=&quot;Internal nodes&quot;) + annotate(&quot;text&quot;, 1992.3, 5.2, hjust=0, size=4, label=&quot;Tip nodes (blue: human; red: swine)&quot;) Figure 4.5: Two-dimensional tree layout. The trunk and other branches highlighted in red (for swine) and blue (for human). The x-axis is scaled to the branch length (in units of year) of the time-scaled tree. The y-axis is scaled to the node attribute variable, in this case the number of predicted N-linked glycosylation site (NLG) on the hemagglutinin protein. Colored circles indicate the different types of tree nodes. Note that nodes assigned the same x- (temporal) and y- (NLG) coordinates are superimposed in this representation and appear as one node, which is shaded based on the colors of all the nodes at that point. As shown in Figure 4.5, two-dimensional tree good at visualizing the change of phenotype over the evolution in the phylogenetic tree. In this example, it is shown that H3 gene of human influenza A virus maintained high level of N-linked glycosylation sites (n=8 to 9) over last two decades and dropped significantly to 5 or 6 in a separate viral lineage transmitted to swine populations and established there. It was indeed hypothesized that the human influenza virus with high level of glycosylation on the viral hemagglutinin protein provides better shielding effect to protect the antigenic sites from exposure to the herd immunity, and thus has selective advantage in human populations that maintain high level of herd immunity against the circulating human influenza virus strains. For the viral lineage that newly jumped across the species barrier and transmitted to swine population, the shielding effect of the high-level surface glycan oppositely impose selective disadvantage because the receptor-binding domain may also be shielded which greatly affect the viral fitness of the lineage that newly adapted to a new host species. Another example of two-dimensional tree can be found on Figure 4.12. 4.3 Displaying Tree Components 4.3.1 Displaying tree scale (evolution distance) To show tree scale, user can use geom_treescale() layer (Figure 4.6A). ggtree(tree) + geom_treescale() geom_treescale() supports the following parameters: x and y for tree scale position width for the length of the tree scale fontsize for the size of the text linesize for the size of the line offset for relative position of the line and the text color for color of the tree scale ggtree(tree) + geom_treescale(x=0, y=45, width=1, color=&#39;red&#39;) ggtree(tree) + geom_treescale(fontsize=6, linesize=2, offset=1) We can also use theme_tree2() to display the tree scale by adding x axis. ggtree(tree) + theme_tree2() Figure 4.6: Display tree scale. geom_treescale automatically add a scale bar for evolutionary distance (A). Users can modify color, width and position of the scale (B) as well as size of the scale bar and text and their relative position (C). Another possible solution is to enable x-axis which is useful for time-scale tree (D). Tree scale is not restricted to evolution distance, treeio can re-scale the tree with other numerical variable (details described in session 2.3). 4.3.2 Displaying nodes/tips Showing all the internal nodes and tips in the tree can be done by adding a layer of points using geom_nodepoint, geom_tippoint or geom_point. ggtree(tree) + geom_point(aes(shape=isTip, color=isTip), size=3) p &lt;- ggtree(tree) + geom_nodepoint(color=&quot;#b5e521&quot;, alpha=1/4, size=10) p + geom_tippoint(color=&quot;#FDAC4F&quot;, shape=8, size=3) Figure 4.7: Display external and internal nodes. geom_point automatically add symbolic points of all nodes (A). geom_nodepoint adds symbolic points for internal nodes and geom_tippoint adds symbolic points for external nodes (B). 4.3.3 Displaying labels Users can use geom_text or geom_label to display the node (if available) and tip labels simultaneously or geom_tiplab to only display tip labels (Figure 4.8A). p + geom_tiplab(size=3, color=&quot;purple&quot;) geom_tiplab not only supports using text or label geom to display labels, it also supports image geom to label tip with image files (see Chapter 7). A corresponding geom, geom_nodelab is also provided for displaying node labels. For circular and unrooted layout, ggtree supports rotating node labels according to the angles of the branches (Figure 4.8B). ggtree(tree, layout=&quot;circular&quot;) + geom_tiplab(aes(angle=angle), color=&#39;blue&#39;) Figure 4.8: Display external and internal nodes. geom_point automatically add symbolic points of all nodes (A). geom_nodepoint adds symbolic points for internal nodes and geom_tippoint adds symbolic points for external nodes (B). By default, the positions to display text are based on the node positions, we can change them to based on the middle of the branch/edge (by setting aes(x = branch)), which is very useful when annotating transition from parent node to child node. 4.3.4 Displaying root edge ggtree doesn’t plot root edge by default. Users can use geom_rootedge() to automatically display root edge (Figure 4.9A). If there is no root edge information, geom_rootedge() will display nothing by default (Figure 4.9B). Users can set the root edge to the tree (Figure 4.9C) or specify rootedge in geom_rootedge() (Figure 4.9D). ## with root edge = 1 tree1 &lt;- read.tree(text=&#39;((A:1,B:2):3,C:2):1;&#39;) ggtree(tree1) + geom_tiplab() + geom_rootedge() ## without root edge tree2 &lt;- read.tree(text=&#39;((A:1,B:2):3,C:2);&#39;) ggtree(tree2) + geom_tiplab() + geom_rootedge() ## setting root edge tree2$root.edge &lt;- 2 ggtree(tree2) + geom_tiplab() + geom_rootedge() ## specify length of root edge for just plotting ## this will ignore tree$root.edge ggtree(tree2) + geom_tiplab() + geom_rootedge(rootedge = 3) Figure 4.9: Display root edge. geom_rootedge supports displaying root edge if the root edge was presented (A). It shows nothing if there is no root edge (B). In this case, users can manually setting root edge for the tree (C) or just specify the length of root for plotting (D). 4.3.5 Color tree In ggtree, coloring phylogenetic tree is easy, by using aes(color=VAR) to map the color of tree based on a specific variable (numeric and category are both supported). ggtree(beast_tree, aes(color=rate)) + scale_color_continuous(low=&#39;darkgreen&#39;, high=&#39;red&#39;) + theme(legend.position=&quot;right&quot;) Figure 4.10: Color tree by continuous or discrete feature. Edges are colored by values that associated with child node. User can use any feature (if available), including clade posterior and dN/dS etc., to scale the color of the tree. If the feature is continuous numerical value, ggtree provides a continuous parameter to support plotting continuous state transition in edges. Here, we use the example provided in http://www.phytools.org/eqg2015/asr.html to demonstrate this functionality. anole.tree&lt;-read.tree(&quot;http://www.phytools.org/eqg2015/data/anole.tre&quot;) svl &lt;- read.csv(&quot;http://www.phytools.org/eqg2015/data/svl.csv&quot;, row.names=1) svl &lt;- as.matrix(svl)[,1] fit &lt;- phytools::fastAnc(anole.tree,svl,vars=TRUE,CI=TRUE) td &lt;- data.frame(node = nodeid(anole.tree, names(svl)), trait = svl) nd &lt;- data.frame(node = names(fit$ace), trait = fit$ace) d &lt;- rbind(td, nd) d$node &lt;- as.numeric(d$node) tree &lt;- full_join(anole.tree, d, by = &#39;node&#39;) ggtree(tree, aes(color=trait), layout = &#39;circular&#39;, ladderize = FALSE, continuous = TRUE, size=2) + scale_color_gradientn(colours=c(&quot;red&quot;, &#39;orange&#39;, &#39;green&#39;, &#39;cyan&#39;, &#39;blue&#39;)) + geom_tiplab(hjust = -.1) + xlim(0, 1.2) + theme(legend.position = c(.05, .85)) Figure 4.11: Continuous state transition in edges. Edges are colored by the values from ancestral trait to offspring. Besides, we can use two-dimensional tree (as demonstrated in Figure 4.5) to visualize phenotype on the vertical dimension to create the phenogram. We can use ggrepel package to repel tip labels to avoid overlapping as demonstrated in Figure A.4. ggtree(tree, aes(color=trait), continuous = TRUE, yscale = &quot;trait&quot;) + scale_color_viridis_c() + theme_minimal() Figure 4.12: Phenogram. Projecting the tree into a space defined by time (or genetic distance) on the horizontal axis and phenotype on the vertical dimension. 4.3.6 Rescale tree Most of the phylogenetic trees are scaled by evolutionary distance (substitution/site). In ggtree, users can re-scale a phylogenetic tree by any numerical variable inferred by evolutionary analysis (e.g. dN/dS). This example displays a time tree (Figure 4.13A) and the branches were rescaled by substitution rate inferred by BEAST (Figure 4.13B). library(&quot;treeio&quot;) beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) beast_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;/home/ygc/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. p1 &lt;- ggtree(beast_tree, mrsd=&#39;2013-01-01&#39;) + theme_tree2() + labs(caption=&quot;Divergence time&quot;) p2 &lt;- ggtree(beast_tree, branch.length=&#39;rate&#39;) + theme_tree2() + labs(caption=&quot;Substitution rate&quot;) The following example draw a tree inferred by CodeML (Figure 4.13C), and the branches can be rescaled by using dN/dS values (Figure 4.13D). mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc_tree &lt;- read.codeml_mlc(mlcfile) p3 &lt;- ggtree(mlc_tree) + theme_tree2() + labs(caption=&quot;nucleotide substitutions per codon&quot;) p4 &lt;- ggtree(mlc_tree, branch.length=&#39;dN_vs_dS&#39;) + theme_tree2() + labs(caption=&quot;dN/dS tree&quot;) Figure 4.13: Rescale tree branches. A time scaled tree inferred by BEAST (A) and its branches were rescaled by substitution rate (B). A tree inferred by CodeML (C) and the branches were rescaled by dN/dS values (D). In addition to specify branch.length in tree visualization, users can change branch length stored in tree object by using rescale_tree function, and the following command will display a tree that is identical to (Figure 4.13B). beast_tree2 &lt;- rescale_tree(beast_tree, branch.length=&#39;rate&#39;) ggtree(beast_tree2) + theme_tree2() 4.3.7 Modify compenents of a theme theme_tree() defined a totally blank canvas, while theme_tree2() adds phylogenetic distance (via x-axis). These two themes all accept a parameter of bgcolor that defined the background color. Users can use any theme components to the theme_tree() or theme_tree2() functions to modify them. set.seed(2019) x &lt;- rtree(30) ggtree(x, color=&quot;red&quot;) + theme_tree(&quot;steelblue&quot;) ggtree(x, color=&quot;white&quot;) + theme_tree(&quot;black&quot;) Figure 4.14: ggtree theme. Users can also use image file as tree background, see example in Appendix B. 4.4 Visualize a list of trees ggtree supports multiPhylo object and a list of trees can be viewed simultaneously. trees &lt;- lapply(c(10, 20, 40), rtree) class(trees) &lt;- &quot;multiPhylo&quot; ggtree(trees) + facet_wrap(~.id, scale=&quot;free&quot;) + geom_tiplab() Figure 4.15: Visuazlie multiPhylo object. One hundred bootstrap trees can also be view simultaneously. btrees &lt;- read.tree(system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bootstrap.H3&quot;, package=&quot;treeio&quot;)) ggtree(btrees) + facet_wrap(~.id, ncol=10) Figure 4.16: Visualize one hundred bootstrap trees. Another way to view the bootstrap trees is to merge them together to form a density tree using ggdensitree function. ggdensitree(btrees, alpha=.3, colour=&#39;steelblue&#39;) + geom_tiplab(size=3) + xlim(0, 45) Figure 4.17: DensiTree. 4.5 Summary Visualizing phylogenetic tree using ggtree is easy by using a single command ggtree(tree). The ggtree package provides several geometric layers to display tree components such as tip labels, symbolic points for both external and internal nodes, root edge, etc. Associated data can be used to rescale branch lengths, color the tree and display on the tree. All these can be done by the ggplot2 grammar of graphic syntax. ggtree also provides several layers that are specifically designed for tree annotation (see Chapter 5). References "],
["chapter5.html", "Chapter 5 Phylogenetic Tree Annotation 5.1 Visualizing and Annotating Tree using Grammar of Graphics 5.2 Layers for Tree Annotation 5.3 Tree annotation with output from evolution software 5.4 Summary", " Chapter 5 Phylogenetic Tree Annotation 5.1 Visualizing and Annotating Tree using Grammar of Graphics The ggtree is designed for more general purpose or specific type of tree visualization and annotation. It supports grammar of graphics implemented in ggplot2 and users can freely visualize/annotate a tree by combining several annotation layers. library(ggtree) treetext = &quot;(((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]): 0.05 [&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY: 0.1[&amp;&amp;NHX:S=nematode],ADHX:0.12 [&amp;&amp;NHX:S=insect]): 0.1[&amp;&amp;NHX:S=metazoa:D=N],(ADH4:0.09[&amp;&amp;NHX:S=yeast], ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast], ADH1:0.11[&amp;&amp;NHX:S=yeast]):0.1[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:D=N];&quot; tree &lt;- read.nhx(textConnection(treetext)) ggtree(tree) + geom_tiplab() + geom_label(aes(x=branch, label=S), fill=&#39;lightgreen&#39;) + geom_label(aes(label=D), fill=&#39;steelblue&#39;) + geom_text(aes(label=B), hjust=-.5) Figure 5.1: Annotating tree using grammar of graphics. The NHX tree was annotated using grammar of graphic syntax by combining different layers using + operator. Species information were labelled on the middle of the branches, Duplication events were shown on most recent common ancestor and clade bootstrap value were dispalyed near to it. Here, as an example, we visualized the tree with several layers to display annotation stored in NHX tags, including a layer of geom_tiplab to display tip labels (gene name in this case), a layer using geom_label to show species information (S tag) colored by lightgreen, a layer of duplication event information (D tag) colored by steelblue and another layer using geom_text to show bootstrap value (B tag). Layers defined in ggplot2 can be applied to ggtree directly as demonstrated in Figure 5.1 of using geom_label and geom_text. But ggplot2 does not provide graphic layers that are specific designed for phylogenetic tree annotation. For instance, layers for tip labels, tree branch scale legend, highlight or labeling clade are all unavailable. To make tree annotation more flexible, a number of layers have been implemented in ggtree (Table 5.1), enabling different ways of annotation on various parts/components of a phylogenetic tree. Table 5.1: Geom layers defined in ggtree. Layer Description geom_balance highlights the two direct descendant clades of an internal node geom_cladelabel annotate a clade with bar and text label geom_facet plot associated data in specific panel (facet) and align the plot with the tree geom_hilight highlight a clade with rectangle geom_inset add insets (subplots) to tree nodes geom_label2 modified version of geom_label, with subsetting supported geom_nodepoint annotate internal nodes with symbolic points geom_point2 modified version of geom_point, with subsetting supported geom_range bar layer to present uncertainty of evolutionary inference geom_rootpoint annotate root node with symbolic point geom_rootedge add root edge to a tree geom_segment2 modified version of geom_segment, with subsetting supported geom_strip annotate associated taxa with bar and (optional) text label geom_taxalink associate two related taxa by linking them with a curve geom_text2 modified version of geom_text, with subsetting supported geom_tiplab layer of tip labels geom_tippoint annotate external nodes with symbolic points geom_tree tree structure layer, with multiple layout supported geom_treescale tree branch scale legend 5.2 Layers for Tree Annotation 5.2.1 Colored strips ggtree (Yu et al. 2017) implements geom_cladelabel layer to annotate a selected clade with a bar indicating the clade with a corresponding label. The geom_cladelabel layer accepts a selected internal node number and label corresponding clade automatically (Figure 5.2A). To get the internal node number, please refer to Chapter 2. set.seed(2015-12-21) tree &lt;- rtree(30) p &lt;- ggtree(tree) + xlim(NA, 6) p + geom_cladelabel(node=45, label=&quot;test label&quot;) + geom_cladelabel(node=34, label=&quot;another clade&quot;) Users can set the parameter, align = TRUE, to align the clade label, offset, to adjust the position and color to set the color of bar and label text etc (Figure 5.2B). p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=TRUE, offset = .2, color=&#39;red&#39;) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=TRUE, offset = .2, color=&#39;blue&#39;) Users can change the angle of the clade label text and relative position from text to bar via the parameter offset.text. The size of the bar and text can be changed via the parameters barsize and fontsize respectively (Figure 5.2C). p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=T, angle=270, hjust=&#39;center&#39;, offset.text=.5, barsize=1.5) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, angle=45, fontsize=8) Users can also use geom_label to label the text and can set the background color by fill parameter (Figure 5.2D). p + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, geom=&#39;label&#39;, fill=&#39;lightblue&#39;) Figure 5.2: Labeling clades. geom_cladelabel also supports unrooted tree layouts (Figure 5.3A). ggtree(tree, layout=&quot;daylight&quot;) + geom_cladelabel(node=35, label=&quot;test label&quot;, angle=0, fontsize=8, offset=.5, vjust=.5) + geom_cladelabel(node=55, label=&#39;another clade&#39;, angle=-95, hjust=.5, fontsize=8) geom_cladelabel is designed for labeling Monophyletic (Clade) while there are related taxa that are not form a clade. ggtree provides geom_strip to add a strip/bar to indicate the association with optional label for Polyphyletic or Paraphyletic (Figure 5.3B). p + geom_tiplab() + geom_strip(&#39;t10&#39;, &#39;t30&#39;, barsize=2, color=&#39;red&#39;, label=&quot;associated taxa&quot;, offset.text=.1) + geom_strip(&#39;t1&#39;, &#39;t18&#39;, barsize=2, color=&#39;blue&#39;, label = &quot;another label&quot;, offset.text=.1) Figure 5.3: Labeling associated taxa. geom_cladelabel is for labeling Monophyletic and it also supports unrooted layout (A). geom_strip is designed for labeling associated taxa (Monophyletic, Polyphyletic or Paraphyletic) (B). 5.2.2 Highlight clades ggtree implements geom_hilight layer, that accepts an internal node number and add a layer of rectangle to highlight the selected clade Figure (5.4).13 nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) ggtree(tree) + geom_hilight(node=21, fill=&quot;steelblue&quot;, alpha=.6) + geom_hilight(node=17, fill=&quot;darkgreen&quot;, alpha=.6) ggtree(tree, layout=&quot;circular&quot;) + geom_hilight(node=21, fill=&quot;steelblue&quot;, alpha=.6) + geom_hilight(node=23, fill=&quot;darkgreen&quot;, alpha=.6) The geom_hilight layer also support highlighting clades for unrooted layout trees (Figure 5.4C). pg + geom_hilight(node=55) + geom_hilight(node=35, fill=&#39;darkgreen&#39;) Another way to highlight selected clades is setting the clades with different colors and/or line types as demonstrated in Figure 6.2. In addition to geom_hilight, ggtree also implements geom_balance which is designed to highlight neighboring subclades of a given internal node (Figure 5.4D). ggtree(tree) + geom_balance(node=16, fill=&#39;steelblue&#39;, color=&#39;white&#39;, alpha=0.6, extend=1) + geom_balance(node=19, fill=&#39;darkgreen&#39;, color=&#39;white&#39;, alpha=0.6, extend=1) Figure 5.4: Highlight selected clades. Rectangular layout (A), circular/fan (B) and unrooted layouts. Highlight neighboring subclades simultaneously (D). 5.2.3 Taxa connection Some evolutionary events (e.g. reassortment, horizontal gene transfer) cannot be modeled by a simple tree. ggtree provides geom_taxalink layer that allows drawing straight or curved lines between any of two nodes in the tree, allow it to represent evolutionary events by connecting taxa. ggtree(tree) + geom_tiplab() + geom_taxalink(&#39;A&#39;, &#39;E&#39;) + geom_taxalink(&#39;F&#39;, &#39;K&#39;, color=&#39;red&#39;, linetype = &#39;dashed&#39;, arrow=grid::arrow(length=grid::unit(0.02, &quot;npc&quot;))) Figure 5.5: Linking related taxa. This can be used to indicate evolutionary events such as reassortment and horozontal gene transfer. 5.2.4 Uncertainty of evolutionary inference The geom_range layer supports displaying interval (highest posterior density, confidence interval, range) as horizontal bars on tree nodes. The center of the interval will anchor to corresponding node. The center by default is the mean value of the interval (Figure 5.6A). We can set the center to estimated mean or median value (Figure 5.6B), or observed value. As the tree branch and the interval may not be in the same scale, ggtree provides scale_x_range to add second x axis for the range (Figure 5.6C). Note that x axis is disable by default theme and we need to enable it if we want to dispaly it (e.g. theme_tree2). file &lt;- system.file(&quot;extdata/MEGA7&quot;, &quot;mtCDNA_timetree.nex&quot;, package = &quot;treeio&quot;) x &lt;- read.mega(file) p1 &lt;- ggtree(x) + geom_range(&#39;reltime_0.95_CI&#39;, color=&#39;red&#39;, size=3, alpha=.3) p2 &lt;- ggtree(x) + geom_range(&#39;reltime_0.95_CI&#39;, color=&#39;red&#39;, size=3, alpha=.3, center=&#39;reltime&#39;) p3 &lt;- p2 + scale_x_range() + theme_tree2() Figure 5.6: Displaying uncertainty of evolutoinary inference. The center (mean value of the range (A) or estimated value (B)) is anchor to the tree nodes. A second x axis was used for range scaling (C). 5.3 Tree annotation with output from evolution software 5.3.1 Tree annotation using data from evolutionary analysis software Chapter 1 introduced using treeio packages to parse different tree formats and commonly used software outputs to obtain phylogeny-associated data. These imported data as S4 objects can be visualized directly using ggtree. Figure 5.1 demonstrates a tree annotated using the information (species classification, duplication event and bootstrap value) stored in NHX file. PHYLDOG and RevBayes output NHX files that can be parsed by treeio and visualized by ggtree with annotation using their inference data. Furthermore, the evolutionary data from the inference of BEAST, MrBayes and RevBayes, dN/dS values inferred by CodeML, ancestral sequences inferred by HyPhy, CodeML or BaseML and short read placement by EPA and pplacer can be used to annotate the tree directly. file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) ggtree(beast, aes(color=rate)) + geom_range(range=&#39;length_0.95_HPD&#39;, color=&#39;red&#39;, alpha=.6, size=2) + geom_nodelab(aes(x=branch, label=round(posterior, 2)), vjust=-.5, size=3) + scale_color_continuous(low=&quot;darkgreen&quot;, high=&quot;red&quot;) + theme(legend.position=c(.1, .8)) Figure 5.7: Annotating BEAST tree with length_95%_HPD and posterior. Branch length credible intervals (95% HPD) were displayed as red horizontal bars and clade posterior values were shown on the middle of branches. In Figure 5.7, the tree was visualized and annotated with posterior &gt; 0.9 and demonstrated length uncertainty (95% Highest Posterior Density (HPD) interval). Ancestral sequences inferred by HyPhy can be parsed using treeio, whereas the substitutions along each tree branch was automatically computed and stored inside the phylogenetic tree object (i.e., S4 object). The ggtree can utilize this information in the object to annotate the tree, as demonstrated in Figure 5.8. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) ggtree(hy) + geom_text(aes(x=branch, label=AA_subs), size=2, vjust=-.3, color=&quot;firebrick&quot;) Figure 5.8: Annotating tree with amino acid substitution determined by ancestral sequences inferred by HYPHY. Amino acid substitutions were displayed on the middle of branches. PAML’s BaseML and CodeML can be also used to infer ancestral sequences, whereas CodeML can infer selection pressure. After parsing this information using treeio, ggtree can integrate this information into the same tree structure and used for annotation as illustrated in Figure 5.9. rstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) ml &lt;- read.codeml(rstfile, mlcfile) ggtree(ml, aes(color=dN_vs_dS), branch.length=&#39;dN_vs_dS&#39;) + scale_color_continuous(name=&#39;dN/dS&#39;, limits=c(0, 1.5), oob=scales::squish, low=&#39;darkgreen&#39;, high=&#39;red&#39;) + geom_text(aes(x=branch, label=AA_subs), vjust=-.5, color=&#39;steelblue&#39;, size=2) + theme_tree2(legend.position=c(.9, .3)) Figure 5.9: Annotating tree with animo acid substitution and dN/dS inferred by CodeML. Branches were rescaled and colored by dN/dS values and amino acid substitutions were displayed on the middle of branches. Not only all the tree data that parsed by treeio can be used to visualize and annotate phylogenetic tree using ggtree, but also other tree and tree-like objects defined in R community are supported. The ggtree plays an unique role in R ecosystem to facilitate phylogenetic analysis and it can be easily integrated into other packages and pipelines. For more details, please refer to chapter 9. In addition to direct support of tree objects, ggtree also allow users to plot tree with different types of external data (see also chapter 7 and (Yu et al. 2018)). 5.4 Summary ggtree implements grammar of graphics for annotating phylogenetic trees. Users can use ggplot2 syntax to combine different annotation layers to produce complex tree annotation. If you are familiar with ggplot2, tree annotation with high level of customization can be intuitive and flexible using ggtree. References "],
["chapter6.html", "Chapter 6 Visual Exploration of Phylogenetic Tree 6.1 Viewing Selected Clade 6.2 Scaling Selected Clade 6.3 Collapsing and Expanding Clade 6.4 Grouping Taxa 6.5 Exploring tree structure 6.6 Summary", " Chapter 6 Visual Exploration of Phylogenetic Tree The ggtree supports many ways of manipulating the tree visually, including viewing selected clade to explore large tree (Figure 6.1), taxa clustering (Figure 6.5), rotating clade or tree (Figure 6.6B and 6.8), zoom out or collapsing clades (Figure 6.3A and 6.2), etc.. Details tree manipulation functions are summarized in Table 6.1. Table 6.1: Tree manipulation functions. Function Descriptiotn collapse collapse a selecting clade expand expand collapsed clade flip exchange position of 2 clades that share a parent node groupClade grouping clades groupOTU grouping OTUs by tracing back to most recent common ancestor identify interactive tree manipulation rotate rotating a selected clade by 180 degree rotate_tree rotating circular layout tree by specific angle scaleClade zoom in or zoom out selecting clade open_tree convert a tree to fan layout by specific open angle 6.1 Viewing Selected Clade A clade is a monophyletic group that contains a single ancestor and all of its descendants. We can visualize a specific selected clade via the viewClade function as demonstrated in Figure 6.1B. Another similar function is gzoom which plots the tree with selected clade side by side. These two functions are developed to explore large tree. library(ggtree) nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) p &lt;- ggtree(tree) + geom_tiplab() viewClade(p, MRCA(p, &quot;I&quot;, &quot;L&quot;)) Figure 6.1: Viewing a selected clade of a tree. An example tree used to demonstrate how ggtree support exploring or manipulating phylogenetic tree visually (A). The ggtree supports visualizing selected clade (B). A clade can be selected by specifying a node number or determined by most recent common ancestor of selected tips. Some of the functions, e.g. viewClade, work with clade and accept a parameter of internal node number. To get the internal node number, user can use MRCA() function (as in Figure 6.1) by providing two taxa names. The function will return node number of input taxa’s most recent commond ancestor (MRCA). It works with tree and graphic (i.e. ggtree() output) object. tidytree also provide MRCA function to extract information of MRCA node (see details in session 2.1.3). 6.2 Scaling Selected Clade The ggtree provides another option to zoom out (or compress) these clades via the scaleClade function. In this way, we retain the topology and branch lengths of compressed clades. This helps to save the space to highlight those clades of primary interest to the study. tree2 &lt;- groupClade(tree, c(17, 21)) p &lt;- ggtree(tree2, aes(color=group)) + theme(legend.position=&#39;none&#39;) + scale_color_manual(values=c(&quot;black&quot;, &quot;firebrick&quot;, &quot;steelblue&quot;)) scaleClade(p, node=17, scale=.1) Figure 6.2: Scaling selected clade. Clades can be zoom in (if scale &gt; 1) to highlight or zoom out to save space. If users want to emphasize important clades, they can use scaleClade function with scale parameter larger than 1. Then the selected clade will be zoomed in. Users can also use groupClade to select clades and color them with different colors as shown in Figure 6.2. 6.3 Collapsing and Expanding Clade It is a common practice to prune or collapse clades so that certain aspects of a tree can be emphasized. The ggtree supports collapsing selected clades using the collapse function as shown in Figure 6.3A. p2 &lt;- p %&gt;% collapse(node=21) + geom_point2(aes(subset=(node==21)), shape=21, size=5, fill=&#39;green&#39;) p2 &lt;- collapse(p2, node=23) + geom_point2(aes(subset=(node==23)), shape=23, size=5, fill=&#39;red&#39;) print(p2) expand(p2, node=23) %&gt;% expand(node=21) Figure 6.3: Collapsing selected clades and expanding collapsed clades. Clades can be selected to collapse (A) and the collapsed clades can be expanded back (B) if necessary as ggtree stored all information of species relationships. Green and red symbols were displayed on the tree to indicate the collapsed clades. Here two clades were collapsed and labelled by green circle and red square symbolic points. Collapsing is a common strategy to collapse clades that are too large for displaying in full or are not primary interest of the study. In ggtree, we can expand (i.e., uncollapse) the collapsed branches back with expand function to show details of species relationships as demonstrated in Figure 6.3B. Triangles are often used to represent the collapsed clade and ggtree also supports it. The collapse function provides a “mode” parameter, which by default is “none” and the selected clade was collapsed as a “tip”. User can specify mode to “max” (Figure 6.4A), “min” (Figure 6.4B) and “mixed” (Figure 6.4C). p2 &lt;- p + geom_tiplab() node &lt;- 21 collapse(p2, node, &#39;max&#39;) %&gt;% expand(node) collapse(p2, node, &#39;min&#39;) %&gt;% expand(node) collapse(p2, node, &#39;mixed&#39;) %&gt;% expand(node) We can pass additional parameter to set the color and transparency of the triangles (Figure 6.4D). collapse(p, 21, &#39;mixed&#39;, fill=&#39;steelblue&#39;, alpha=.4) %&gt;% collapse(23, &#39;mixed&#39;, fill=&#39;firebrick&#39;, color=&#39;blue&#39;) We can combine scaleClade with collapse to zoom in/out of the triangles (Figure 6.4E). scaleClade(p, 23, .2) %&gt;% collapse(23, &#39;min&#39;, fill=&quot;darkgreen&quot;) Figure 6.4: Collapse clade as triangle. ‘max’ takes the position of most distant tip (A). ‘min’ takes the position of closest tip (B). ‘mixed’ takes the positions of both closest and distant tips (C), which looks more like the shape of the clade. Set color, fill and alpha of the triangles (D). Combine with scaleClade to zoom out triangle to save space (E). 6.4 Grouping Taxa The groupClade function assigns the branches and nodes under different clades into different groups. groupClade accepts an internal node or a vector of internal nodes to cluster clade/clades. Similarly, groupOTU function assigns branches and nodes to different groups based on user-specified groups of operational taxonomic units (OTUs) that are not necessarily within a clade, but can be monophyletic (clade), polyphyletic or paraphyletic. It accepts a vector of OTUs (taxa name) or a list of OTUs and will trace back from OTUs to their most recent common ancestor (MRCA) and cluster them together as demonstrated in Figure 6.5. A phylogenetic tree can be annotated by mapping different line type, size, color or shape to the branches or nodes that have been assigned to different groups. data(iris) rn &lt;- paste0(iris[,5], &quot;_&quot;, 1:150) rownames(iris) &lt;- rn d_iris &lt;- dist(iris[,-5], method=&quot;man&quot;) tree_iris &lt;- ape::bionj(d_iris) grp &lt;- list(setosa = rn[1:50], versicolor = rn[51:100], virginica = rn[101:150]) p_iris &lt;- ggtree(tree_iris, layout = &#39;circular&#39;, branch.length=&#39;none&#39;) groupOTU(p_iris, grp, &#39;Species&#39;) + aes(color=Species) + theme(legend.position=&quot;right&quot;) Figure 6.5: Grouping OTUs. OTU clustering based on their relationships. Selected OTUs and their ancestors upto MRCA will be clustered together. We can grouping taxa at tree level. The following code will produce identical figure of Figure 6.5 (see more details described at session 2.2.3). tree_iris &lt;- groupOTU(tree_iris, grp, &quot;Species&quot;) ggtree(tree_iris, aes(color=Species), layout = &#39;circular&#39;, branch.length = &#39;none&#39;) + theme(legend.position=&quot;right&quot;) 6.5 Exploring tree structure To facilitate exploring the tree structure, ggtree supports rotating selected clade by 180 degree using the rotate function (Figure 6.6B). Position of immediate descendant clades of internal node can be exchanged via flip function (Figure 6.6C). p1 &lt;- p + geom_point2(aes(subset=node==16), color=&#39;darkgreen&#39;, size=5) p2 &lt;- rotate(p1, 17) %&gt;% rotate(21) flip(p2, 17, 21) Figure 6.6: Exploring tree structure. A clade (indicated by darkgreen circle) in a tree (A) can be rotated by 180° (B) and the positions of its immediate descedant clades (colored by blue and red) can be exchanged (C). Most of the tree manipulation functions are working on clades, while ggtree also provides functions to manipulate a tree, including open_tree to transform a tree in either rectangular or circular layout to fan layout, and rotate_tree function to rotate a tree for specific angle in both circular or fan layouts, as demonstrated in Figure 6.7 and 6.8. p3 &lt;- open_tree(p, 180) + geom_tiplab() print(p3) Figure 6.7: Transforming a tree to fan layout. A tree can be transformed to fan layout by open_tree with specific angle parameter. rotate_tree(p3, 180) Figure 6.8: Rotating tree. A circular/fan layout tree can be rotated by any specific angle. The following example traverse all the internal nodes and rotate them one by one (Figure 6.9). set.seed(2016-05-29) x &lt;- rtree(50) p &lt;- ggtree(x) + geom_tiplab() for (n in reorder(x, &#39;postorder&#39;)$edge[,1] %&gt;% unique) { p &lt;- rotate(p, n) print(p + geom_point2(aes(subset=(node == n)), color=&#39;red&#39;)) } Figure 6.9: Traverse and rotate all clades. set.seed(123) tr &lt;- rtree(50) p &lt;- ggtree(tr, layout=&#39;circular&#39;) + geom_tiplab() for (angle in seq(0, 270, 10)) { print(open_tree(p, angle=angle) + ggtitle(paste(&quot;open angle:&quot;, angle))) } Figure 6.10 demonstrates the usage of open_tree with different open angles. Figure 6.10: Open tree with different angles. Figure 6.11 illustrates rotating tree with different angles. for (angle in seq(0, 270, 10)) { print(rotate_tree(p, angle) + ggtitle(paste(&quot;rotate angle:&quot;, angle))) } Figure 6.11: Rotate tree with different angles. Interactive tree manipulation is also possible via identify methods14. 6.6 Summary The ggtree provides a set of functions to allow visually manipulating phylogenetic tree and exploring tree structure with associated data. "],
["chapter7.html", "Chapter 7 Plotting tree with data 7.1 Mapping data to the tree structure 7.2 Alignning graph to the tree based on tree structure 7.3 Visualize tree with associated matrix 7.4 Visualize tree with multiple sequence alignment 7.5 The ggtree object 7.6 Summary", " Chapter 7 Plotting tree with data Integrating user data to annotate phylogenetic tree can be done at different levels. The treeio package implements full_join methods to combine tree data to phylogenetic tree object. The tidytree package supports linking tree data to phylogeny using tidyverse verbs. ggtree supports mapping external data to phylogeny for visualization and annotation on the fly. Although the feature of linking external data is overlapping among these packages, they have different application scopes. For example, in addition to the treedata object, ggtree also supports several other tree objects (see chapter 9), including phylo4d, phyloseq and obkData that were designed to contain domain specific data. The design of these objects did not consider to support linking external data to the object (it can not be done at tree object level). We can visualize trees from these objects using ggtree and link external data at visualization level (Yu et al. 2018). ggtree provides two general methods for mapping and visualizing associated external data on phylogenies. Method 1 allows external data to be mapped on the tree structure and used as visual characteristic in tree and data visualization. Method 2 plots the data with the tree side by side using different geometric functions after reordering the data based on the tree structure. These two methods integrate data with phylogeny for further exploration and comparison in the evolutionary biology context. 7.1 Mapping data to the tree structure In ggtree, we implemented an operator, %&lt;+%, to attach annotation data to a ggtree graphic object. Any data that contains a column of “node” or first column of taxa labels can be integrated using the %&lt;+% operator. Multiple datasets can be attached progressively. When the data are attached, all the information stored in the data serve as numerical/categorical node attributes and can be directly used to visualize the tree by scaling the attributes as different colors or line sizes, label the tree using the original values of the attributes or parsing them as math expression, emoji or silhouette image. The following example uses the %&lt;+% operator to integrat taxon (tip_data.csv) and internal node (inode_data.csv) information and map the data to different colors or shapes of symbolic points and labels (Figure 7.1). The tip data contains imageURL that links to online figures of the species, which can be parsed and used as tip labels in ggtree (see chapter 8). library(ggimage) library(ggtree) url &lt;- paste0(&quot;https://raw.githubusercontent.com/TreeViz/&quot;, &quot;metastyle/master/design/viz_targets_exercise/&quot;) x &lt;- read.tree(paste0(url, &quot;tree_boots.nwk&quot;)) info &lt;- read.csv(paste0(url, &quot;tip_data.csv&quot;)) p &lt;- ggtree(x) %&lt;+% info + xlim(-.1, 4) p2 &lt;- p + geom_tiplab(offset = .6, hjust = .5) + geom_tippoint(aes(shape = trophic_habit, color = trophic_habit, size = mass_in_kg)) + theme(legend.position = &quot;right&quot;) + scale_size_continuous(range = c(3, 10)) d2 &lt;- read.csv(paste0(url, &quot;inode_data.csv&quot;)) p2 %&lt;+% d2 + geom_label(aes(label = vernacularName.y, fill = posterior)) + scale_fill_gradientn(colors = RColorBrewer::brewer.pal(3, &quot;YlGnBu&quot;)) Figure 7.1: Example of attaching multiple datasets. Although the data integrated by the %&lt;+% operator in ggtree is for tree visualization, the data attached to the ggtree graphic object can be converted to treedata object that contains the tree and the attached data (see session 7.5). 7.2 Alignning graph to the tree based on tree structure For associating phylogenetic tree with different type of plot produced by user’s data, ggtree provides geom_facet layer and facet_plot function which accept an input data.frame and a geom function to draw the input data. The data will be displayed in an additional panel of the plot. The geom_facet (or facet_plot) is a general solution for linking graphic layer to a tree. The function internally re-orders the input data based on the tree strucutre and visualizes the data at the specific panel by the geometric layer. Users are free to visualize several panels to plot different types of data as demonstrated in Figure 9.4 and to use different geometric layers to plot the same dataset (Figure 11.1) or different datasets on the same panel. The geom_facet is designed to work with most of the geom layers defined in ggplot2 and other ggplot2-based packages. A list of the geometric layers that work seamlessly with geom_facet and facet_plot can be found in Table G.1. As the ggplot2 community keeps expanding and more geom layers will be implemented in either ggplot2 or other extensions, geom_facet and facet_plot will gain more power to present data in future. Note that different geom layers can be combined to present data on the same panel and the combinations of different geom layers create the possibility to present more complex data with phylogeny. library(ggtree) remote_folder &lt;- paste0(&quot;https://raw.githubusercontent.com/katholt/&quot;, &quot;plotTree/master/tree_example_april2015/&quot;) ## read the phylogenetic tree tree &lt;- read.tree(paste0(remote_folder, &quot;tree.nwk&quot;)) ## read the sampling information data set info &lt;- read.csv(paste0(remote_folder,&quot;info.csv&quot;)) ## read and process the allele table snps&lt;-read.csv(paste0(remote_folder, &quot;alleles.csv&quot;), header = F, row.names = 1, stringsAsFactor = F) snps_strainCols &lt;- snps[1,] snps&lt;-snps[-1,] # drop strain names colnames(snps) &lt;- snps_strainCols gapChar &lt;- &quot;?&quot; snp &lt;- t(snps) lsnp &lt;- apply(snp, 1, function(x) { x != snp[1,] &amp; x != gapChar &amp; snp[1,] != gapChar }) lsnp &lt;- as.data.frame(lsnp) lsnp$pos &lt;- as.numeric(rownames(lsnp)) lsnp &lt;- tidyr::gather(lsnp, name, value, -pos) snp_data &lt;- lsnp[lsnp$value, c(&quot;name&quot;, &quot;pos&quot;)] ## read the trait data bar_data &lt;- read.csv(paste0(remote_folder, &quot;bar.csv&quot;)) ## visualize the tree p &lt;- ggtree(tree) ## attach the sampling information data set ## and add symbols colored by location p &lt;- p %&lt;+% info + geom_tippoint(aes(color=location)) ## visualize SNP and Trait data using dot and bar charts, ## and align them based on tree structure p + geom_facet(panel = &quot;SNP&quot;, data = snp_data, geom = geom_point, mapping=aes(x = pos, color = location), shape = &#39;|&#39;) + geom_facet(panel = &quot;Trait&quot;, data = bar_data, geom = ggstance::geom_barh, aes(x = dummy_bar_value, color = location, fill = location), stat = &quot;identity&quot;, width = .6) + theme_tree2(legend.position=c(.05, .85)) Figure 7.2: Example of plotting SNP and trait data. 7.3 Visualize tree with associated matrix The gheatmap function is designed to visualize phylogenetic tree with heatmap of associated matrix (either numerical or categorical). geom_facet is a general solution for plotting data with the tree, including heatmap. gheatmap is specifically designed for plotting heatmap with tree and provides shortcut for handling column labels and color palette. Another difference is that geom_facet only supports rectangular and slanted tree layouts while `gheatmap supports rectugular, slanted and circular (Figure 7.4) layouts. In the following example, we visualized a tree of H3 influenza viruses with their associated genotype (Figure 7.3A). beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) genotype_file &lt;- system.file(&quot;examples/Genotype.txt&quot;, package=&quot;ggtree&quot;) genotype &lt;- read.table(genotype_file, sep=&quot;\\t&quot;, stringsAsFactor=F) colnames(genotype) &lt;- sub(&quot;\\\\.$&quot;, &quot;&quot;, colnames(genotype)) p &lt;- ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + geom_treescale(x=2008, y=1, offset=2) + geom_tiplab(size=2) gheatmap(p, genotype, offset=5, width=0.5, font.size=3, colnames_angle=-45, hjust=0) + scale_fill_manual(breaks=c(&quot;HuH3N2&quot;, &quot;pdm&quot;, &quot;trig&quot;), values=c(&quot;steelblue&quot;, &quot;firebrick&quot;, &quot;darkgreen&quot;), name=&quot;genotype&quot;) The width parameter is to control the width of the heatmap. It supports another parameter offset for controlling the distance between the tree and the heatmap, for instance to allocate space for tip labels. For time-scaled tree, as in this example, it’s more often to use x axis by using theme_tree2. But with this solution, the heatmap is just another layer and will change the x axis. To overcome this issue, we implemented scale_x_ggtree to set the x axis more reasonable (Figure 7.3A). p &lt;- ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + geom_tiplab(size=2, align=TRUE, linesize=.5) + theme_tree2() gheatmap(p, genotype, offset=8, width=0.6, colnames=FALSE, legend_title=&quot;genotype&quot;) + scale_x_ggtree() + scale_y_continuous(expand=c(0, 0.3)) Figure 7.3: Example of plotting matrix with gheatmap. 7.3.1 Visualize tree with multiple associated matrix Of course, we can use multiple gheatmap function call to align several associated matrix with the tree, however, ggplot2 doesn’t allow us to use multiple fill scales15. To solve this issue, we can use ggnewscale to create new fill scales. Here is an example of using ggnewscale with gheatmap. nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) circ &lt;- ggtree(tree, layout = &quot;circular&quot;) df &lt;- data.frame(first=c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;e&quot;, &quot;e&quot;, &quot;f&quot;, &quot;c&quot;, &quot;f&quot;), second= c(&quot;z&quot;, &quot;z&quot;, &quot;z&quot;, &quot;z&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;a&quot;, &quot;a&quot;)) rownames(df) &lt;- tree$tip.label df2 &lt;- as.data.frame(matrix(rnorm(39), ncol=3)) rownames(df2) &lt;- tree$tip.label colnames(df2) &lt;- LETTERS[1:3] p1 &lt;- gheatmap(circ, df, offset=.8, width=.2, colnames_angle=95, colnames_offset_y = .25) + scale_fill_viridis_d(option=&quot;D&quot;, name=&quot;discrete\\nvalue&quot;) library(ggnewscale) p2 &lt;- p1 + new_scale_fill() gheatmap(p2, df2, offset=15, width=.3, colnames_angle=90, colnames_offset_y = .25) + scale_fill_viridis_c(option=&quot;A&quot;, name=&quot;continuous\\nvalue&quot;) Figure 7.4: Example of plotting matrix with gheatmap. 7.4 Visualize tree with multiple sequence alignment The msaplot accepts a tree (output of ggtree) and a fasta file, then it can visualize the tree with sequence alignment. We can specify the width (relative to the tree) of the alignment and adjust relative position by offset, that are similar to gheatmap function. tree &lt;- read.tree(&quot;data/tree.nwk&quot;) p &lt;- ggtree(tree) + geom_tiplab(size=3) msaplot(p, &quot;data/sequence.fasta&quot;, offset=3, width=2) A specific slice of the alignment can also be displayed by specific window parameter. p &lt;- ggtree(tree, layout=&#39;circular&#39;) + geom_tiplab(offset=4, align=TRUE) + xlim(NA, 12) msaplot(p, &quot;data/sequence.fasta&quot;, window=c(120, 200)) Figure 7.5: Example of plotting multiple sequence alignment with a tree. 7.5 The ggtree object 7.6 Summary Although there are many software packages support visualizing phylogenetic tree, plotting tree with data is often missing or with only limited supports. Some of the packages defines S4 classes to store phylogenetic tree with domain specific data, such as OutbreakTools (Jombart et al. 2014) defined obkData for storing tree with epidemiology data and phyloseq (McMurdie and Holmes 2013) defines phyloseq for storing tree with microbiome data. These packages are capable to present some of the data stored in the object on the tree. However, not all the associated data are supported. For example, species abundance stored in phyloseq object is not supported to be visualized using phyloseq package. These packages did not provide any utilities to integrate external data for tree visualization. None of these packages support visualizting external data and align the plot to tree based on the tree structure. ggtree provides general solutions for integrating data. Method 1, the %&lt;+% operator, can integrate external and internal node data and map the data as visual characteristic to visualize the tree and other datasets used in geom_facet. Method 2, the geom_facet layer, has no restriction of input data as long as there is a geom function available to plot the data (e.g. species abundance displayed by geom_density_ridges as demonstrated in Figure 9.4). Users are free to combine different panels and combine different geom layers in the same panel (Figure 11.1). ggtree has many unique features that cannot be found in other implementations: Integrating node/edge data to the tree can be mapped to visual characteristics of the tree or other datasets (Figure ). Capable of parsing expression (math symbols or text formatting), emoji and image files (chapter 8). No predefined of input data types or how the data should be plotted in geom_facet (Table G.1). Combining different geom functions to visualize associated data is supported (Figure 11.1). Visualizing different datasets on the same panel is supported. Data integrated by %&lt;+% can be used in geom_facet. Able to add further annotation to specific layers. Modular design by separating tree visualization, data integration (method 1) and graph alignment (method 2). Modular design is a unique feature for ggtree to stand out from other packages. The tree can be visualized with data stored in tree object or external data linked by %&lt;+% operator, and fully annotated with multiple layers of annotations (Figure 7.1 and 11.1), before passing it to geom_facet. geom_facet can be called progressively to add multiple panels or multiple layers on the same panels (Figure 11.1). This creates the possiblity of plotting full annotated tree with complex data panels that contains multiple graphic layers. ggtree fits the R ecosystem and extends the abilities of integrating and presenting data with trees to existing phylogenetic packages. As demonstrated in Figure 9.4, we are able to plot species abundance distributions with phyloseq object. This cannot be easily done without ggtree. With ggtree, we are able to attach additional data to tree objects using %&lt;+% and align graph to tree using geom_facet. Integrating ggtree to existing workflows will definitely extends the abilities and broadens the applications to present phylogeny-associated data, especially for comparative studies. References "],
["chapter8.html", "Chapter 8 Annotating Tree with Silhouette Images and Sub-plots 8.1 Annotating Tree with Images 8.2 Annotating Tree with Phylopic 8.3 Annotating Tree with Sub-plots 8.4 Have Fun with Phylomoji", " Chapter 8 Annotating Tree with Silhouette Images and Sub-plots 8.1 Annotating Tree with Images We usually use text to label taxa, i.e. displaying taxa names. If the text is image file name (either local or remote), ggtree can read the image and display the actual image as label of the taxa (Figure 8.1). The geom_tiplab and geom_nodelab are capable to render silhouette image by internally called ggimage package. Online tools such as iTOL (Letunic and Bork 2007) and EvolView (He et al. 2016) support displaying subplots on phylogenetic tree. However only bar and pie charts are supported by these tools. Users may want to visualize node-associated data with other visualization methods, such as violin plot (Grubaugh et al. 2017), venn diagram (Lott et al. 2015), sequence logo etc, and display them on the tree. In ggtree, all kinds of subplots are supported as we can export all subplots to image files and use them to label corresponding nodes on the tree. library(ggimage) library(ggtree) nwk &lt;- &quot;((((bufonidae, dendrobatidae), ceratophryidae), (centrolenidae, leptodactylidae)), hylidae);&quot; x = read.tree(text = nwk) ggtree(x) + xlim(NA, 7) + ylim(NA, 6.2) + geom_tiplab(aes(image=paste0(&quot;img/frogs/&quot;, label, &#39;.jpg&#39;)), geom=&quot;image&quot;, offset=2, align=2, size=.2) + geom_tiplab(geom=&#39;label&#39;, offset=1, hjust=.5) + geom_image(x=.8, y=5.5, image=&quot;img/frogs/frog.jpg&quot;, size=.2) Figure 8.1: Labelling taxa with images. 8.2 Annotating Tree with Phylopic Phylopic contains more than 3200 silhouettes and covers almost all life forms. ggtree also supports using phylopic16 to annotate the tree. Most importantly, we can color the image using numerical/categorical variable. tree &lt;- ape::read.nexus(&quot;data/tree.nex&quot;) phylopic_info &lt;- data.frame(node = c(124, 113, 110, 96, 89, 70), phylopic = c(&quot;c4ac9ea6-b465-4ed0-a5de-9fe4eebd3ef9&quot;, &quot;5388a472-994a-48e1-86de-d988c6019e72&quot;, &quot;615c82cf-fabe-49f8-b571-e8117edfa212&quot;, &quot;63ff1b70-6b6e-4412-b4d2-b2e2fb51aa95&quot;, &quot;d65d5abd-df8b-4509-912c-e42f6c34861f&quot;, &quot;6d54acc7-9e1e-4b79-be88-4904cf58fbb5&quot;), species = c(&quot;galagoids&quot;, &quot;lemurs&quot;, &quot;tarsiers&quot;, &quot;cebids&quot;, &quot;hominoids&quot;, &quot;cercopithecoids&quot;)) pg &lt;- ggtree(tree) pg &lt;- pg %&lt;+% phylopic_info + geom_nodelab(aes(image=phylopic, color=species, subset=!is.na(species)), geom=&quot;phylopic&quot;, alpha = .6) + theme(legend.position=c(.2, .8)) ggimage package supports querying phylopic uid from scientific name, which is very handy for annotating tree with phylopic. require(ggtree) newick = &quot;((Pongo_abelii,(Gorilla_gorilla_gorilla,(Pan_paniscus,Pan_troglodytes)Pan,Homo_sapiens)Homininae)Hominidae,Nomascus_leucogenys)Hominoidea;&quot; tree = read.tree(text=newick) idlist = ggimage::phylopic_uid(tree$tip.label) ids &lt;- sapply(idlist, function(x) x[1,1]) d &lt;- data.frame(label = tree$tip.label, uid = ids) p &lt;- ggtree(tree) %&lt;+% d + geom_tiplab(aes(image=uid, color=label), geom=&quot;phylopic&quot;, offset=2.5) + geom_tiplab(aes(label=label), offset = .2) + xlim(NA, 7) + theme(legend.position=&#39;none&#39;) Figure 8.2: Labelling taxa with phylopic images. ggtree will automatically download phylopic figures by querying provided UID (A). The UID can be searched using scientific names of the taxa (B). The figures can be colored using on numerical or categorical values. 8.3 Annotating Tree with Sub-plots ggtree provides a layer, geom_inset, for adding subplots to a phylogenetic tree. The input is a named list of ggplot graphic objects (can be any kind of charts). These objects should named by node numbers. Users can also use ggplotify to convert plots that generated by other functions (even implemented by base graphics) to ggplot objects, which can then be used in geom_inset. To facilitate adding bar and pie charts (e.g. summarized stats of results from ancestral reconstruction) to phylogenetic tree, ggtree provides nodepie and nodebar functions to create a list of pie or bar charts. 8.3.1 Annotate with bar charts library(phytools) data(anoletree) x &lt;- getStates(anoletree,&quot;tips&quot;) tree &lt;- anoletree cols &lt;- setNames(palette()[1:length(unique(x))],sort(unique(x))) fitER &lt;- ape::ace(x,tree,model=&quot;ER&quot;,type=&quot;discrete&quot;) ancstats &lt;- as.data.frame(fitER$lik.anc) ancstats$node &lt;- 1:tree$Nnode+Ntip(tree) ## cols parameter indicate which columns store stats bars &lt;- nodebar(ancstats, cols=1:6) bars &lt;- lapply(bars, function(g) g+scale_fill_manual(values = cols)) tree2 &lt;- full_join(tree, data.frame(label = names(x), stat = x ), by = &#39;label&#39;) p &lt;- ggtree(tree2) + geom_tiplab() + geom_tippoint(aes(color = stat)) + scale_color_manual(values = cols) + theme(legend.position = &quot;right&quot;) + xlim(NA, 8) p + geom_inset(bars, width = .08, height = .05, x = &quot;branch&quot;) Figure 8.3: Annotate internal nodes with barplots. The x position can be one of ‘node’ or ‘branch’ and can be adjusted by the parameter hjust and vjust for horizontal and vertical adjustment respecitvely. 8.3.2 Annotate with pie charts Similarly, users can use nodepie function to generate a list of pie charts and place these charts to annotate corresponding nodes. Both nodebar and nodepie accepts parameter alpha to allow transparency. pies &lt;- nodepie(ancstats, cols = 1:6) pies &lt;- lapply(pies, function(g) g+scale_fill_manual(values = cols)) p + geom_inset(pies, width = .1, height = .1) Figure 8.4: Annotate internal nodes with pie plots. 8.3.3 Annotate with other types of charts The inset function accepts a list of ggplot graphic objects and these input objects are not restricted to pie or bar charts. They can be any kinds of charts and hybrid of these charts. pies_and_bars &lt;- pies i &lt;- sample(length(pies), 20) pies_and_bars[i] &lt;- bars[i] p + geom_inset(pies_and_bars, width=.08, height=.05) Figure 8.5: Annotate internal nodes with different types of subplots (bar and pie). 8.4 Have Fun with Phylomoji #phylomoji is fun and it is internally supported by ggtree since 201517. Here, we will use ggtree to recreate the figure: library(ggplot2) library(ggtree) tt = &#39;((snail,mushroom),(((sunflower,evergreen_tree),leaves),green_salad));&#39; tree = read.tree(text = tt) d &lt;- data.frame(label = c(&#39;snail&#39;,&#39;mushroom&#39;, &#39;sunflower&#39;, &#39;evergreen_tree&#39;,&#39;leaves&#39;, &#39;green_salad&#39;), group = c(&#39;animal&#39;, &#39;fungi&#39;, &#39;flowering plant&#39;, &#39;conifers&#39;, &#39;ferns&#39;, &#39;mosses&#39;)) ggtree(tree, linetype = &quot;dashed&quot;, size=1, color=&#39;firebrick&#39;) %&lt;+% d + xlim(0, 4.5) + ylim(0.5, 6.5) + geom_tiplab(parse=&quot;emoji&quot;, size=15, vjust=.25) + geom_tiplab(aes(label = group), geom=&quot;label&quot;, x=3.5, hjust=.5) Figure 8.6: Parsing label as emoji. Text (e.g. node or tip labels) can be parsed as emoji. Note that the output may depends on what emoji fonts installed in your system18. With ggtree, it is easy to generate phylomoji. The emoji is treated as text, like abc. We can use emojis to label taxa, clade, color and ratate emoji with any given color and angle. This functionality is internally supported by the emojifont package. 8.4.1 Emoji in cirular/fan layout tree p &lt;- ggtree(tree, layout = &quot;circular&quot;, size=1) + geom_tiplab(parse=&quot;emoji&quot;, size=10, vjust=.25) print(p) ## fan layout p2 &lt;- open_tree(p, angle=200) print(p2) p2 %&gt;% rotate_tree(-90) Figure 8.7: Phylomoji in cirular and fan layouts. 8.4.2 Emoji to label clades set.seed(123) tr &lt;- rtree(30) ggtree(tr) + xlim(NA, 5.2) + geom_cladelabel(node=41, label=&quot;chicken&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;firebrick&quot;) + geom_cladelabel(node=53, label=&quot;duck&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;steelblue&quot;) + geom_cladelabel(node=48, label=&quot;family&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;darkkhaki&quot;) Figure 8.8: Emoji to label clades. 8.4.3 Apple Color Emoji Although R’s graphical devices don’t support AppleColorEmoji font, it’s still possible to use it. We can export the plot to svg file and render it in Safari. library(ggtree) tree_text &lt;- &quot;(((((cow, (whale, dolphin)), (pig2, boar)), camel), fish), seedling);&quot; x &lt;- read.tree(text=tree_text) library(ggimage) library(gridSVG) p &lt;- ggtree(x, size=2) + geom_tiplab(size=20, parse=&#39;emoji&#39;) + xlim(NA, 7) + ylim(NA, 8.5) + geom_phylopic(image=&quot;79ad5f09-cf21-4c89-8e7d-0c82a00ce728&quot;, color=&quot;firebrick&quot;, alpha = .3, size=Inf) p ps = grid.export(&quot;emoji.svg&quot;, addClass=T) Figure 8.9: Use Apple Color Emoji in ggtree. 8.4.4 Phylomoji in ASCII art This is also possible, please refer to Appendix D for details. References "],
["chapter9.html", "Chapter 9 ggtree for other tree-like objects 9.1 ggtree for phylogenetic tree objects 9.2 ggtree for dendrograms 9.3 ggtree for tree graph", " Chapter 9 ggtree for other tree-like objects 9.1 ggtree for phylogenetic tree objects The treeio packages allows parsing evolutionary inferences from a number of software outputs and linking external data to the tree structure. It serves as an infrastructure to bring evolutionary data to the R community. The ggtree package works seamlessly with treeio to visualize tree associated data to annotate the tree. The ggtree package is general tool for tree visualization and annotation and it fits the ecosystem of R packages. Most of the S3/S4 tree objects defined by other R packages are also supported by ggtree, including phylo(session 4.2), multiPhylo (session 4.4), phylo4, phylo4d, phyloseq and obkData. With ggtree, we are able to generate more complex tree graph which is not possible or easy to do with other packages. For example, the visualization of the phyloseq object in Figure 9.4 is not supported by the phyloseq package. The ggtree package also extend the possibility of linking external data to these tree object (Yu et al. 2018). 9.1.1 The phylo4 and phylo4d objects The phylo4 and phylo4d are defined in the phylobase package. The phylo4 object is a S4 version of phylo, while phylo4d extends phylo4 with a data frame that contains trait data. The phylobase package provides plot method, which internally calls the treePlot function, to display the tree with the data. However there are some restrictions of the plot method, it can only plot numeric values for tree-associated data as bubbles and cannot generate figure legend. Phylobase doesn’t implement visualization method to display categorical values. Using associated data as visual characteristics such as color, size and shape, is also not supported. Although it is possible to color the tree using associated data, it requires users to extract the data and map them to color vector manually follow by passing the color vector to the plot method. This is tedious and error-prone since the order of the color vector needs to be consistent with the edge list stored in the object. The ggtree package supports phylo4d object and all the associated data stored in the phylo4d object can be used directly to annotate the tree (Fig. ). library(phylobase) data(geospiza_raw) g1 &lt;- as(geospiza_raw$tree, &quot;phylo4&quot;) g2 &lt;- phylo4d(g1, geospiza_raw$data, missing.data=&quot;warn&quot;) d1 &lt;- data.frame(x = seq(0.93, 1.15, length.out = 5), lab = names(geospiza_raw$data)) ggtree(g2) + geom_tippoint(aes(size = wingL), x = d1$x[1], shape = 1) + geom_tippoint(aes(size = tarsusL), x = d1$x[2], shape = 1) + geom_tippoint(aes(size = culmenL), x = d1$x[3], shape = 1) + geom_tippoint(aes(size = beakD), x = d1$x[4], shape = 1) + geom_tippoint(aes(size = gonysW), x = d1$x[5], shape = 1) + scale_size_continuous(range = c(3,12), name=&quot;&quot;) + geom_text(aes(x = x, y = 0, label = lab), data = d1, angle = 90) + geom_tiplab(offset = .3) + xlim(0, 1.3) + theme(legend.position = c(.1, .75)) Figure 9.1: Visualizing phylo4d data using ggtree. 9.1.2 The phylog object The phylog is defined in ade4 package. The package is designed for analyzing ecological data and provides newick2phylog, hclust2phylog and taxo2phylog functions to create phylogeny from Newick string, hierachical clustering result or a taxonomy. The phylog object is also supported by ggtree as demonstrated in Figure 9.2. library(ade4) data(taxo.eg) tax &lt;- as.taxo(taxo.eg[[1]]) print(tax) ## genre famille ordre ## esp3 g1 fam1 ORD1 ## esp1 g1 fam1 ORD1 ## esp2 g1 fam1 ORD1 ## esp4 g1 fam1 ORD1 ## esp5 g1 fam1 ORD1 ## esp6 g1 fam1 ORD1 ## esp7 g1 fam1 ORD1 ## esp8 g2 fam2 ORD2 ## esp9 g3 fam2 ORD2 ## esp10 g4 fam3 ORD2 ## esp11 g5 fam3 ORD2 ## esp12 g6 fam4 ORD2 ## esp13 g7 fam4 ORD2 ## esp14 g8 fam5 ORD2 ## esp15 g8 fam5 ORD2 tax.phy &lt;- taxo2phylog(as.taxo(taxo.eg[[1]])) print(tax.phy) ## Phylogenetic tree with 15 leaves and 16 nodes ## $class: phylog ## $call: taxo2phylog(taxo = as.taxo(taxo.eg[[1]])) ## $tre: ((((esp3,esp1,esp2,esp4,e...15)l1g8)l2fam5)l3ORD2)Root; ## ## class length ## $leaves numeric 15 ## $nodes numeric 16 ## $parts list 16 ## $paths list 31 ## $droot numeric 31 ## content ## $leaves length of the first preceeding adjacent edge ## $nodes length of the first preceeding adjacent edge ## $parts subsets of descendant nodes ## $paths path from root to node or leave ## $droot distance to root ggtree(tax.phy) + geom_tiplab() + geom_nodelab(geom=&#39;label&#39;) Figure 9.2: Visualizing phylog tree object. 9.1.3 The phyloseq object The phyloseq class that defined in the phyloseq package was designed for storing microbiome data, including phylogenetic tree, associated sample data and taxonomy assignment. It can import data from popular pipelines, such as QIIME (Kuczynski et al. 2011), mothur (Schloss et al. 2009), DADA2 (Callahan et al. 2016) and PyroTagger (Kunin and Hugenholtz 2010), etc.. The ggtree supports visualizing the phylogenetic tree stored in phyloseq object and related data can be used to annotate the tree as demonstrated in Figure 9.3 and 9.4. library(phyloseq) library(scales) data(GlobalPatterns) GP &lt;- prune_taxa(taxa_sums(GlobalPatterns) &gt; 0, GlobalPatterns) GP.chl &lt;- subset_taxa(GP, Phylum==&quot;Chlamydiae&quot;) ggtree(GP.chl) + geom_text2(aes(subset=!isTip, label=label), hjust=-.2, size=4) + geom_tiplab(aes(label=Genus), hjust=-.3) + geom_point(aes(x=x+hjust, color=SampleType, shape=Family, size=Abundance),na.rm=TRUE) + scale_size_continuous(trans=log_trans(5)) + theme(legend.position=&quot;right&quot;) Figure 9.3: Visualizing phyloseq tree object. Figure 9.3 reproduce output of phyloseq::plot_tree(). Users of phyloseq will find ggtree useful for visualizing microbiome data and for further annotation, since ggtree supports high-level of annotation using grammar of graphics and can add tree data layers that are not available in phyloseq. library(ggridges) data(&quot;GlobalPatterns&quot;) GP &lt;- GlobalPatterns GP &lt;- prune_taxa(taxa_sums(GP) &gt; 600, GP) sample_data(GP)$human &lt;- get_variable(GP, &quot;SampleType&quot;) %in% c(&quot;Feces&quot;, &quot;Skin&quot;) mergedGP &lt;- merge_samples(GP, &quot;SampleType&quot;) mergedGP &lt;- rarefy_even_depth(mergedGP,rngseed=394582) mergedGP &lt;- tax_glom(mergedGP,&quot;Order&quot;) melt_simple &lt;- psmelt(mergedGP) %&gt;% filter(Abundance &lt; 120) %&gt;% select(OTU, val=Abundance) ggtree(mergedGP) + geom_tippoint(aes(color=Phylum), size=1.5) + geom_facet(mapping = aes(x=val,group=label, fill=Phylum), data = melt_simple, geom = geom_density_ridges, panel=&quot;Abundance&quot;, color=&#39;grey80&#39;, lwd=.3) Figure 9.4: Phylogenetic tree with OTU abundance densities. Tips were colored by Phylum and corresponding abundance across different samples were visualized as density ridgelines and sorted according to the tree structure. This example uses microbiome data that provided in phyloseq package and density ridgeline is employed to visualize species abundance data. The geom_facet layer automatically re-arranges the abundance data according to the tree structure, visualizes the data using the specify geom function, i.e. geom_density_ridges, and aligns the density curves with the tree as demonstrated in Fig. . Note that data stored in the phyloseq object is visible to ggtree and can be used directly in tree visualization (Phylum was used to color tips and density ridgelines in this example). The source code of this example was firstly published in Supplemental File of (Yu et al. 2018). 9.1.4 The obkData object The okbData is defined in the OutbreakTools package to store incidence-based outbreak data, including meta data of sampling and information of infected individuals such as age and onset of symptoms. The ggtree supports the obkData object and the information can be used to annotate the tree as shown in Figure 9.5. library(OutbreakTools) data(FluH1N1pdm2009) attach(FluH1N1pdm2009) x &lt;- new(&quot;obkData&quot;, individuals = individuals, dna = dna, dna.individualID = samples$individualID, dna.date = samples$date, trees = FluH1N1pdm2009$trees) ggtree(x, mrsd=&quot;2009-09-30&quot;, as.Date=TRUE, right=TRUE) + geom_tippoint(aes(color=location), size=3, alpha=.75) + scale_color_brewer(&quot;location&quot;, palette=&quot;Spectral&quot;) + theme_tree2(legend.position=&#39;right&#39;) Figure 9.5: Visualizing obkData tree object. x-axis was scaled by timeline of the outbreak and tips were colored by location of different individuals. 9.2 ggtree for dendrograms A dendrogram is a tree diagram to display hierachical clustering and classification/regression trees. We can calculate a hierachical clustering using the function hclust hc &lt;- hclust(dist(mtcars)) hc ## ## Call: ## hclust(d = dist(mtcars)) ## ## Cluster method : complete ## Distance : euclidean ## Number of objects: 32 The hclust object describes the tree produced by the clustering process. It can be converted to dendrogram object, which stores the tree as deeply-nested lists. den &lt;- as.dendrogram(hc) den ## &#39;dendrogram&#39; with 2 branches and 32 members total, at height 425.3447 The ggtree package supports most of the hierarchical clustering objects defined in the R community, including hclust and dendrogram as well as agnes, diana and twins that defined in the cluster package. Users can use ggtree(object) to display its tree structure, and user other layers and utilities to customize the graph and of course add annotation to the tree. ggtree provides layout_dendrogram to layout the tree top down, and theme_dendrogram to display tree height (similar to theme_tree2 for phylogenetic tree) as demonstrated in Figure 9.6. clus &lt;- cutree(hc, 4) g &lt;- split(names(clus), clus) p &lt;- ggtree(hc, linetype=&#39;dashed&#39;) clades &lt;- sapply(g, function(n) MRCA(p, n)) p &lt;- groupClade(p, clades, group_name=&#39;subtree&#39;) + aes(color=subtree) d &lt;- data.frame(label = names(clus), cyl = mtcars[names(clus), &quot;cyl&quot;]) p %&lt;+% d + layout_dendrogram() + geom_tippoint(size=5, shape=21, aes(fill=factor(cyl), x=x+.5), color=&#39;black&#39;) + geom_tiplab(aes(label=cyl), size=3, hjust=.5, color=&#39;black&#39;) + geom_tiplab(angle=90, hjust=1, offset=-10, show.legend=F) + scale_color_brewer(palette=&#39;Set1&#39;, breaks=1:4) + theme_dendrogram(plot.margin=margin(6,6,80,6)) + theme(legend.position=c(.9, .6)) Figure 9.6: Visualizing dendrogram. 9.3 ggtree for tree graph treeio supports converting tree graph (as an igraph object) to phylo object and ggtree supports directly visualizing tree graph as demonstrated in Figure 9.7. library(igraph) g &lt;- graph.tree(40, 3) ggtree(g, layout=&#39;slanted&#39;, arrow=arrow(length=unit(3, &#39;mm&#39;))) + geom_point(size=5, color=&#39;steelblue&#39;, alpha=.6) + geom_tiplab(hjust=.5,vjust=2) + layout_dendrogram() Figure 9.7: Visualizing tree graph. References "],
["chapter10.html", "Chapter 10 ggtree utilities 10.1 facet utilities 10.2 layout utilities 10.3 legend utilities 10.4 scale utilities", " Chapter 10 ggtree utilities 10.1 facet utilities 10.1.1 facet_widths library(ggplot2) library(ggstance) library(ggtree) library(reshape2) set.seed(123) tree &lt;- rtree(30) p &lt;- ggtree(tree, branch.length = &quot;none&quot;) + geom_tiplab() + theme(legend.position=&#39;none&#39;) a &lt;- runif(30, 0,1) b &lt;- 1 - a df &lt;- data.frame(tree$tip.label, a, b) df &lt;- melt(df, id = &quot;tree.tip.label&quot;) p2 &lt;- facet_plot(p + xlim_tree(8), panel = &#39;bar&#39;, data = df, geom = geom_barh, mapping = aes(x = value, fill = as.factor(variable)), width = 0.8, stat=&#39;identity&#39;) + xlim_tree(9) facet_widths(p2, widths = c(1, 2)) It also supports using name vector to set the widths of specific panels. The following code will display identical figure to Figure 10.1A. facet_widths(p2, c(Tree = .5)) The facet_widths function also work with other ggplot object as demonstrated in Figure 10.1B. p &lt;- ggplot(iris, aes(Sepal.Width, Petal.Length)) + geom_point() + facet_grid(.~Species) facet_widths(p, c(setosa = .5)) Figure 10.1: Adjust relative widths of ggplot facets. The facet_widths function works with ggtree (A) as well as ggplot (B). 10.1.2 facet_labeller The facet_labeller function was designed to re-label selected panels, and it currently only works with ggtree object (i.e. facet_plot output). facet_labeller(p2, c(Tree = &quot;phylogeny&quot;, bar = &quot;HELLO&quot;)) If you want to combine facet_widths with facet_labeller, you need to call facet_labeller to re-label the panels before using facet_widths to set the relative widths of each panels. Otherwise it wont work since the output of facet_widths is re-drawn from grid object. facet_labeller(p2, c(Tree = &quot;phylogeny&quot;)) %&gt;% facet_widths(c(Tree = .4)) Figure 10.2: Rename facet labels. Rename multiple labels simultaneously (A) or only for specific one (B) are all supported. facet_labeller can combine with facet_widths to rename facet label and then adjust relative widths (B). 10.2 layout utilities In session 4.2.2, we introduce several layouts that supported by ggtree. The ggtree package also provide several layout functions that can transfrom from one to another. Note that not all layouts are supported (see 10.1). Table 10.1: Layout layers. Layout Description layout_circular transform rectangular layout to circular layout layout_dendrogram transform rectangular layout to dendrogram layout layout_fan transform rectangular/circular layout to fan layout layout_rectangular transform circular/fan layout to rectangular layout set.seed(2019) x &lt;- rtree(20) p &lt;- ggtree(x) p + layout_dendrogram() ggtree(x, layout = &quot;circular&quot;) + layout_rectangular() p + layout_circular() p + layout_fan(angle=90) Figure 10.3: Layout layers for transforming among different layouts. Default rectangular layout (A); transform rectangular to dendrogram layout (B); transform circular to rectangular layout (C); transform rectangular to circular layout (D); transform rectangular to fan layout (E). 10.3 legend utilities 10.4 scale utilities 10.4.1 xlim_expand Sometimes we need to set xlim for specific panel (e.g. allocate more space for long tip labels at Tree panel). However, the ggplot2::xlim() function applies to all the panels. ggtree provides xlim_expand() to adjust xlim for user specific panel. It accepts two parameters, xlim and panel, and can adjust all individual panels as demonstrated in Figure 10.4A. If you only want to adjust xlim of the Tree panel, you can use xlim_tree() as a shortcut. set.seed(2019-05-02) x &lt;- rtree(30) p &lt;- ggtree(x) + geom_tiplab() d &lt;- data.frame(label = x$tip.label, value = rnorm(30)) p2 &lt;- facet_plot(p, panel = &quot;Dot&quot;, data = d, geom = geom_point, mapping = aes(x = value)) p2 + xlim_tree(6) + xlim_expand(c(-10, 10), &#39;Dot&#39;) The xlim_expand() function also works with ggplot2::facet_grid(). As demonstrating in Figure 10.4B, only the xlim of virginica panel was adjusted by xlim_expand(). g &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point() + facet_grid(. ~ Species, scales = &quot;free_x&quot;) g + xlim_expand(c(0, 15), &#39;virginica&#39;) Figure 10.4: Setting xlim for user specific panel. xlim for ggtree::facet_plot (A, Tree and Dot panels), and ggplot2::facet_grid (B, virginica panel). "],
["chapter11.html", "Chapter 11 Gallery of reproducible examples 11.1 Visualizing pairwise nucleotide sequence distance with phylogenetic tree 11.2 Displaying different symbolic points for bootstrap values. 11.3 Phylogenetic tree with genome locus structure", " Chapter 11 Gallery of reproducible examples 11.1 Visualizing pairwise nucleotide sequence distance with phylogenetic tree This example reproduces Fig. 1 of (Chen et al. 2017). It extracts accession numbers from tip labels of the HPV58 tree and calculates pairwise nucleotide sequence distances. The distance matrix is visualized as dot and line plots. This example demonstrates the abilities of adding multiple layers to a specific panel. As illustrated on Figure 11.1, the facet_plot function displays sequence distances as a dot plot and then adds a layer of line plot to the same panel, i.e. Sequence Distance. In addition, the tree in facet_plot can be fully annotated with multiple layers (clade labels, bootstrap support values, etc). The source code of this example was firstly published in Supplemental File of (Yu et al. 2018). library(tibble) library(tidyr) library(Biostrings) library(treeio) library(ggplot2) library(ggtree) hpvtree &lt;- paste0(&quot;https://raw.githubusercontent.com/GuangchuangYu/&quot;, &quot;plotting_tree_with_data/master/HPV58.tree&quot;) tree &lt;- read.tree(hpvtree) clade &lt;- c(A3 = 92, A1 = 94, A2 = 108, B1 = 156, B2 = 159, C = 163, D1 = 173, D2 = 176) tree &lt;- groupClade(tree, clade) cols &lt;- c(A1 = &quot;#EC762F&quot;, A2 = &quot;#CA6629&quot;, A3 = &quot;#894418&quot;, B1 = &quot;#0923FA&quot;, B2 = &quot;#020D87&quot;, C = &quot;#000000&quot;, D1 = &quot;#9ACD32&quot;,D2 = &quot;#08630A&quot;) ## visualize the tree with tip labels and tree scale p &lt;- ggtree(tree, aes(color = group), ladderize = FALSE) %&gt;% rotate(rootnode(tree)) + geom_tiplab(aes(label = paste0(&quot;italic(&#39;&quot;, label, &quot;&#39;)&quot;)), parse = TRUE, size = 2.5) + geom_treescale(x = 0, y = 1, width = 0.002) + scale_color_manual(values = c(cols, &quot;black&quot;), na.value = &quot;black&quot;, name = &quot;Lineage&quot;, breaks = c(&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;C&quot;, &quot;D1&quot;, &quot;D2&quot;)) + guides(color = guide_legend(override.aes = list(size = 5, shape = 15))) + theme_tree2(legend.position = c(.1, .88)) ## Optional ## add labels for monophyletic (A, C and D) and paraphyletic (B) groups p &lt;- p + geom_cladelabel(94, &quot;italic(A1)&quot;, color = cols[[&quot;A1&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0, 0.5), parse = TRUE) + geom_cladelabel(108, &quot;italic(A2)&quot;, color = cols[[&quot;A2&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = 0.5, parse = TRUE) + geom_cladelabel(131, &quot;italic(A3)&quot;, color = cols[[&quot;A3&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0.5, 0), parse = TRUE) + geom_cladelabel(92, &quot;italic(A)&quot;, color = &quot;darkgrey&quot;, offset = .00315, align = TRUE, offset.text = 0.0002, barsize = 2, fontsize = 5, parse = TRUE) + geom_cladelabel(156, &quot;italic(B1)&quot;, color = cols[[&quot;B1&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0, 0.5), parse = TRUE) + geom_cladelabel(159, &quot;italic(B2)&quot;, color = cols[[&quot;B2&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0.5, 0), parse = TRUE) + geom_strip(65, 71, &quot;italic(B)&quot;, color = &quot;darkgrey&quot;, offset = 0.00315, align = TRUE, offset.text = 0.0002, barsize = 2, fontsize = 5, parse = TRUE) + geom_cladelabel(163, &quot;italic(C)&quot;, color = &quot;darkgrey&quot;, offset = .0031, align = TRUE, offset.text = 0.0002, barsize = 3.2, fontsize = 5, parse = TRUE) + geom_cladelabel(173, &quot;italic(D1)&quot;, color = cols[[&quot;D1&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0, 0.5), parse = TRUE) + geom_cladelabel(176, &quot;italic(D2)&quot;, color = cols[[&quot;D2&quot;]], offset = .003, align = TRUE, offset.text = -.001, barsize = 1.2, extend = c(0.5, 0), parse = TRUE) + geom_cladelabel(172, &quot;italic(D)&quot;, color = &quot;darkgrey&quot;, offset = .00315, align = TRUE, offset.text = 0.0002, barsize = 2, fontsize = 5, parse = TRUE) ## Optional ## display support values p &lt;- p + geom_nodelab(aes(subset = (node == 92), label = &quot;*&quot;), color = &quot;black&quot;, nudge_x = -.001, nudge_y = 1) + geom_nodelab(aes(subset = (node == 155), label = &quot;*&quot;), color = &quot;black&quot;, nudge_x = -.0003, nudge_y = -1) + geom_nodelab(aes(subset = (node == 158), label = &quot;95/92/1.00&quot;), color = &quot;black&quot;, nudge_x = -0.0001, nudge_y = -1, hjust = 1) + geom_nodelab(aes(subset = (node == 162), label = &quot;98/97/1.00&quot;), color = &quot;black&quot;, nudge_x = -0.0001, nudge_y = -1, hjust = 1) + geom_nodelab(aes(subset = (node == 172), label = &quot;*&quot;), color = &quot;black&quot;, nudge_x = -.0003, nudge_y = -1) ## extract accession numbers from tip labels tl &lt;- tree$tip.label acc &lt;- sub(&quot;\\\\w+\\\\|&quot;, &quot;&quot;, tl) names(tl) &lt;- acc ## read sequences from GenBank directly into R ## and convert the object to DNAStringSet tipseq &lt;- ape::read.GenBank(acc) %&gt;% as.character %&gt;% lapply(., paste0, collapse = &quot;&quot;) %&gt;% unlist %&gt;% DNAStringSet ## align the sequences using muscle tipseq_aln &lt;- muscle::muscle(tipseq) tipseq_aln &lt;- DNAStringSet(tipseq_aln) ## calculate pairwise hamming distances among sequences tipseq_dist &lt;- stringDist(tipseq_aln, method = &quot;hamming&quot;) ## calculate percentage of differences tipseq_d &lt;- as.matrix(tipseq_dist) / width(tipseq_aln[1]) * 100 ## convert the matrix to tidy data frame for facet_plot dd &lt;- as_tibble(tipseq_d) dd$seq1 &lt;- rownames(tipseq_d) td &lt;- gather(dd,seq2, dist, -seq1) td$seq1 &lt;- tl[td$seq1] td$seq2 &lt;- tl[td$seq2] g &lt;- p$data$group names(g) &lt;- p$data$label td$clade &lt;- g[td$seq2] ## visualize the sequence differences using dot plot and line plot ## and align the sequence difference plot to the tree using facet_plot p2 &lt;- facet_plot(p, panel = &quot;Sequence Distance&quot;, data = td, geom_point, mapping = aes(x = dist, color = clade, shape = clade), alpha = .6) %&gt;% facet_plot(panel = &quot;Sequence Distance&quot;, data = td, geom = geom_path, mapping=aes(x = dist, group = seq2, color = clade), alpha = .6) + scale_shape_manual(values = 1:8, guide = FALSE) print(p2) Figure 11.1: Phylogeny of HPV58 complete genomes with dot and line plots of pairwise nucleotide sequence distances. 11.2 Displaying different symbolic points for bootstrap values. We can cut the bootstrap values into several intervals, e.g. to indicate whether the clade is high, moderate or low support. Then we can use these intervals as categorical variable to set different color or shape of symbolic points to indicate the bootstrap values belong to which category. library(treeio) library(ggplot2) library(ggtree) tree &lt;- read.newick(&quot;data/RMI.phy_phyml_tree_rooted_labeled.txt&quot;, node.label=&#39;support&#39;) root &lt;- rootnode(tree) ggtree(tree, color=&quot;black&quot;, size=1.5, linetype=1, right=TRUE) + geom_tiplab(size=4.5, hjust = -0.060, fontface=&quot;bold&quot;) + xlim(0, 0.09) + geom_point2(aes(subset=!isTip &amp; node != root, fill=cut(support, c(0, 700, 900, 1000))), shape=21, size=4) + theme_tree(legend.position=c(0.2, 0.2)) + scale_fill_manual(values=c(&quot;white&quot;, &quot;grey&quot;, &quot;black&quot;), guide=&#39;legend&#39;, name=&#39;Bootstrap Percentage(BP)&#39;, breaks=c(&#39;(900,1e+03]&#39;, &#39;(700,900]&#39;, &#39;(0,700]&#39;), labels=expression(BP&gt;=90,70 &lt;= BP * &quot; &lt; 90&quot;, BP &lt; 70)) Figure 11.2: Partitioning bootstrap values. Bootstrap values were divided into three categories and this information was used to color circle points. 11.3 Phylogenetic tree with genome locus structure The geom_motif is defined in ggtree and it is a wrapper layer of gggenes::geom_gene_arrow. The geom_motif can automatically adjust genomic alignment by selective gene (via the on parameter) and can label genes via the label parameter. In the following example, we use example_genes dataset provided by gggenes. As the dataset only provide genomic coordinations of a set of genes, a phylogeny for the genomes need to be firstly constructed. We calculate jaccard similarity based on the ratio of overlapping genes among genomes and correspondingly determine genome distance. BioNJ algorithm was applied to construct the tree (Figure 11.3). library(dplyr) library(ggplot2) library(gggenes) library(ggtree) get_genes &lt;- function(data, genome) { filter(data, molecule == genome) %&gt;% pull(gene) } g &lt;- unique(example_genes[,1]) n &lt;- length(g) d &lt;- matrix(nrow = n, ncol = n) rownames(d) &lt;- colnames(d) &lt;- g genes &lt;- lapply(g, get_genes, data = example_genes) for (i in 1:n) { for (j in 1:i) { jaccard_sim &lt;- length(intersect(genes[[i]], genes[[j]])) / length(union(genes[[i]], genes[[j]])) d[j, i] &lt;- d[i, j] &lt;- 1 - jaccard_sim } } tree &lt;- ape::bionj(d) p &lt;- ggtree(tree, branch.length=&#39;none&#39;) + geom_tiplab() + xlim_tree(5.5) + geom_facet(mapping = aes(xmin = start, xmax = end, fill = gene), data = example_genes, geom = geom_motif, panel = &#39;Alignment&#39;, on = &#39;genE&#39;, label = &#39;gene&#39;, align = &#39;left&#39;) + scale_fill_brewer(palette = &quot;Set3&quot;) + scale_x_continuous(expand=c(0,0)) + theme(strip.text=element_blank(), panel.spacing=unit(0, &#39;cm&#39;)) facet_widths(p, widths=c(1,2)) Figure 11.3: Genomic features with phylogenetic tree. References "],
["chapter12.html", "Chapter 12 ggtree extensions", " Chapter 12 ggtree extensions rp &lt;- BiocManager::repositories() db &lt;- utils::available.packages(repo=rp) x &lt;- tools::package_dependencies(&#39;ggtree&#39;, db=db, which = c(&quot;Depends&quot;, &quot;Imports&quot;), reverse=TRUE) print(x) ## $ggtree ## [1] &quot;LINC&quot; &quot;LymphoSeq&quot; &quot;philr&quot; ## [4] &quot;singleCellTK&quot; &quot;universalmotif&quot; &quot;genBaRcode&quot; ## [7] &quot;harrietr&quot; &quot;STraTUS&quot; There are 8 packages in CRAN or Bioconductor that depend or import ggtree and several packages on github that extends ggtree. deeptime: Plotting Tools for Anyone Working in Deep Time ggnetworx: phylogenetic networks using ggplot2 and ggtree microbiomeViz: Visualize microbiome data with black magic ggtree "],
["faq.html", "A Frequently asked questions A.1 Installation A.2 Basic R related A.3 Aesthetic mapping A.4 Text &amp; Label A.5 Different x labels for different facet panels A.6 Plot something behind the phylogeny A.7 Enlarge center space in circular/fan layout tree A.8 Use the most distant tip from the root as the origin of the time scale A.9 Changing branch length of outgroup A.10 Edit tree graphic details", " A Frequently asked questions A.1 Installation ggtree is released within the Bioconductor project, you need to use BiocManager to install it. ## you need to install BiocManager before using it ## install.packages(&quot;BiocManager&quot;) library(BiocManager) install(&quot;ggtree&quot;) Bioconductor release is adhere to specific R version. Please make sure you are using latest version of R if you want to install the latest release of Bioconductor packages, including ggtree. Beware that bugs will only be fixed in current release and develop branches. If you find a bug, please follow the guide19 to report it. A.2 Basic R related A.2.1 Use your local file If you are new to R and want to use ggtree for tree visualization, please do learn some basic R and ggplot2. A very common issue is that users always copy-paste command without looking at the function’s behavior. system.file() was used in the treeio and ggtree package documentation to find files in the packages. system.file package:base R Documentation Find Names of R System Files Description: Finds the full file names of files in packages etc. Usage: system.file(..., package = &quot;base&quot;, lib.loc = NULL, mustWork = FALSE) For users who want to use their own files, please just use relative or absolute file path (e.g. f = \"your/folder/filename\"). A.3 Aesthetic mapping A.3.1 Inherit aes ggtree(rtree(30)) + geom_point() For example, we can add symbolic points to nodes with geom_point() directly. The magic here is we don’t need to map x and y position of the points by providing aes(x, y) to geom_point() since it was already mapped by ggtree function and it serves as a global mapping for all layers. But what if we provide a dataset in a layer and the dataset doesn’t contain column of x and/or y, the layer function also try to map x and y and also others if you map them in ggtree function. As these variable is not available in your dataset, you will get the following error: Error in eval(expr, envir, enclos) : object &#39;x&#39; not found This can be fixed by using parameter inherit.aes=FALSE which will disable inheriting mapping from ggtree function. A.3.2 Never use $ in aes NEVER DO THIS20. See the explaination in the ggplot2 book 2ed: Never refer to a variable with $ (e.g., diamonds$carat) in aes(). This breaks containment, so that the plot no longer contains everything it needs, and causes problems if ggplot2 changes the order of the rows, as it does when facetting. A.4 Text &amp; Label A.4.1 Tip label truncated ggplot2 can’t auto adjust xlim based on added text21. library(ggtree) ## example tree from https://support.bioconductor.org/p/72398/ tree &lt;- read.tree(text= paste(&quot;(Organism1.006G249400.1:0.03977,(Organism2.022118m:0.01337,&quot;, &quot;(Organism3.J34265.1:0.00284,Organism4.G02633.1:0.00468)0.51:0.0104):0.02469);&quot;)) p &lt;- ggtree(tree) + geom_tiplab() In this example, the tip labels displayed on Figure A.1A are truncated. This is because the units are in two different spaces (data and pixel). Users can use xlim to allocate more spaces for tip labels (Figure A.1B). p + xlim(0, 0.08) Another solution is to set clip = \"off\" to allow drawing outside of the plot panel. We may also need to set plot.margin to allocate more spaces for margin (Figure A.1C). p + coord_cartesian(clip = &#39;off&#39;) + theme_tree2(plot.margin=margin(6, 120, 6, 6)) Figure A.1: Allocating more spaces for truncated tip lables. Long tip lables may be truncated (A). One solution is to allocate more spaces for plot panel (B) and another solution is to allow plotting labels outside the plot panel (C). A.4.2 Modify (tip) labels If you want to modify tip labels of the tree, you can use treeio::rename_taxa() to rename a phylo or treedata object. tree &lt;- read.tree(text = &quot;((A, B), (C, D));&quot;) d &lt;- data.frame(label = LETTERS[1:4], label2 = c(&quot;sunflower&quot;, &quot;tree&quot;, &quot;snail&quot;, &quot;mushroom&quot;)) ## rename_taxa use 1st column as key and 2nd column as value by default ## rename_taxa(tree, d) rename_taxa(tree, d, label, label2) %&gt;% write.tree ## [1] &quot;((sunflower,tree),(snail,mushroom));&quot; If the input tree object is a treedata instance, you can use write.beast() to export the tree with with associated data to a BEAST compatible NEXUS file. Renaming phylogeny tip labels seems not be a good idea, since it may introduce problems when mapping the original sequence alignment to the tree. Personally, I recommend to store the new labels as a tip annotation in treedata object. tree2 &lt;- full_join(tree, d, by = &quot;label&quot;) tree2 ## &#39;treedata&#39; S4 object&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## ## Rooted; no branch lengths. ## ## with the following features available: ## &#39;label2&#39;. If you just want to show different or additional information when plotting the tree, you don’t need to modify tip labels. This could be easily done via the %&lt;+% operator to attach the modified version of the labels and than use geom_tiplab to display the modified version (Figure A.2). p &lt;- ggtree(tree) + xlim(NA, 3) p1 &lt;- p + geom_tiplab() ## the following command will produce identical figure of p2 ## ggtree(tree2) + geom_tiplab(aes(label = label2)) p2 &lt;- p %&lt;+% d + geom_tiplab(aes(label=label2)) cowplot::plot_grid(p1, p2, ncol=2, labels = c(&quot;A&quot;, &quot;B&quot;)) Figure A.2: Alternative tip labels. Original tip lables (A) and modified version (B). A.4.3 Formatting (tip) labels If you want to format labels, you need to set parse=TRUE in geom_text/geom_tiplab and the label should be string that can be parsed into expression and displayed as described in ?plotmath. For example, the tip labels contains two parts, species name and accession number and we want to display species name in italic, we can use command like this to format specific tip/node label (Figure A.3A): set.seed(2019-06-24) tree &lt;- rtree(30) p1 &lt;- ggtree(tree) + geom_tiplab(aes(subset=node==35), label=&#39;paste(italic(&quot;species name&quot;), &quot; accession number&quot;)&#39;, parse=T) + xlim(0, 6) Another example for formating all tip labels is demonstrated in Figure A.3B: p2 &lt;- ggtree(tree) + geom_tiplab(aes(label=paste0(&#39;bold(&#39;, label, &#39;)~italic(&#39;, node, &#39;)&#39;)), parse=TRUE) + xlim(0, 5) The label can be provided by a data.frame that contains related information of the taxa (Figure A.3C). tree &lt;- read.tree(text = &quot;((a,(b,c)),d);&quot;) genus &lt;- c(&quot;Gorilla&quot;, &quot;Pan&quot;, &quot;Homo&quot;, &quot;Pongo&quot;) species &lt;- c(&quot;gorilla&quot;, &quot;spp.&quot;, &quot;sapiens&quot;, &quot;pygmaeus&quot;) geo &lt;- c(&quot;Africa&quot;, &quot;Africa&quot;, &quot;World&quot;, &quot;Asia&quot;) d &lt;- data.frame(label = tree$tip.label, genus = genus, species = species, geo = geo) p3 &lt;- ggtree(tree) %&lt;+% d + xlim(NA, 6) + geom_tiplab(aes(label=paste0(&#39;italic(&#39;, genus, &#39;)~bolditalic(&#39;, species, &#39;)~&#39;, geo)), parse=T) cowplot::plot_grid(p1, p2, p3, ncol=3, labels = LETTERS[1:3]) Figure A.3: Formatting labels. Formatting specific tip/node label (A), all tip labels (B &amp; C). A.4.4 Avoid overlapping text labels User can use ggrepel package to repel overlapping text labels22. . For example: library(ggrepel) library(ggtree) raxml_file &lt;- system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;) raxml &lt;- read.raxml(raxml_file) ggtree(raxml) + geom_label_repel(aes(label=bootstrap, fill=bootstrap)) + theme(legend.position = c(.1, .8)) + scale_fill_viridis_c() Figure A.4: Repel labels. Repel labels to avoid overlapping. A.4.5 Bootstrap values from newick format It’s quite command to store bootstrap value as node label in newick format. Visualizing node label is easy using geom_text2(aes(subset = !isTip, label=label)). If you want to only display a subset of bootstrap (e.g. bootstrap &gt; 80), you can’t simply using geom_text2(subset= (label &gt; 80), label=label) since label is a character vector, which contains node label (bootstrap value) and tip label (taxa name). If we use geom_text2(subset=(as.numeric(label) &gt; 80), label=label), it will also fail since NAs were introduced by coercion. We need to convert NAs to logical FALSE, this can be done by the following code: nwk &lt;- system.file(&quot;extdata/RAxML&quot;,&quot;RAxML_bipartitions.H3&quot;, package=&#39;ggtree&#39;) tr &lt;- read.tree(nwk) ggtree(tr) + geom_text2(aes(label=label, subset = !is.na(as.numeric(label)) &amp; as.numeric(label) &gt; 80)) Another solution is converting the bootstrap value outside ggtree. q &lt;- ggtree(tr) d &lt;- q$data d &lt;- d[!d$isTip,] d$label &lt;- as.numeric(d$label) d &lt;- d[d$label &gt; 80,] q + geom_text(data=d, aes(label=label)) A.5 Different x labels for different facet panels This is not supported by ggplot2 in general. However, we can just draw text labels for each panels and put the labels beyond the plot panels as demonstrated in Figure A.5. library(ggtree) library(ggplot2) set.seed(2019-05-02) x &lt;- rtree(30) p &lt;- ggtree(x) + geom_tiplab() d &lt;- data.frame(label = x$tip.label, value = rnorm(30)) p2 &lt;- facet_plot(p, panel = &quot;Dot&quot;, data = d, geom = geom_point, mapping = aes(x = value)) p2 &lt;- p2 + theme_bw() + xlim_tree(5) + xlim_expand(c(-5, 5), &#39;Dot&#39;) d = data.frame(.panel = c(&#39;Tree&#39;, &#39;Dot&#39;), lab = c(&quot;Distance&quot;, &quot;Dot Units&quot;), x=c(2.5,0), y=-2) p2 + scale_y_continuous(limits=c(0, 31), expand=c(0,0), oob=function(x, ...) x) + geom_text(aes(label=lab), data=d) + coord_cartesian(clip=&#39;off&#39;) + theme(plot.margin=margin(6, 6, 40, 6)) Figure A.5: X-axis titles for different facet panels. A.6 Plot something behind the phylogeny The ggtree function plot the tree structure and normally we add layers on top of the tree. set.seed(1982) x &lt;- rtree(5) p &lt;- ggtree(x) + geom_hilight(7, alpha=1) If we want the layers behind the tree layer, we can reverse the order of all the layers. p$layers &lt;- rev(p$layers) Another solution is to use ggplot() instead of ggtree() and + geom_tree() to add the layer of tree structure at the correct position of layer stack. ggplot(x) + geom_hilight(7, alpha=1) + geom_tree() + theme_tree() Figure A.6: Add layers behind tree structure. A layer on top of the tree structure (A). Reverse layer order of A (B). Add layer behind the tree layer (C). A.7 Enlarge center space in circular/fan layout tree This question was asked several times23, and a published example can be found in https://www.ncbi.nlm.nih.gov/pubmed/27605062. Increasing percentage of center white space in circular tree is useful to avoid overlapping tip labels and to increase readibility of the tree by moving all nodes and branches further out. This can be done simply by using +xlim() to allocate more space, just like in Figure 4.3G, or assign a long root branch that is similar to the “Root Length” parameter in FigTree. set.seed(1982) tree &lt;- rtree(30) plot_grid( ggtree(tree, layout=&#39;circular&#39;) + xlim(-10, NA), ggtree(tree, layout=&#39;circular&#39;) + geom_rootedge(5), labels = c(&quot;A&quot;, &quot;B&quot;, ncol=2) ) Figure A.7: Enlarge center space in circular tree. Allocate more space by xlim (A) or long root branch (B). A.8 Use the most distant tip from the root as the origin of the time scale The revts will reverse the x-axis by setting the most recent tip to 0. We can use scale_x_continuous(labels=abs) to label x-axis using absolute values. tr &lt;- rtree(10) p &lt;- ggtree(tr) + theme_tree2() p2 &lt;- revts(p) + scale_x_continuous(labels=abs) plot_grid(p, p2, ncol=2, labels=c(&quot;A&quot;, &quot;B&quot;)) Figure A.8: Origin of the time scale. Forward: from the root to tips (A). Backward: from the most distant tip to the root (B). A.9 Changing branch length of outgroup When outgroups are on a very long branch length (Figure A.9A), we would like to keep the out groups in the tree but ignore their branch lengths (Figure A.9B)24. This can be easily done by modifying coordination of the out groups. x &lt;- read.tree(&quot;data/long-branch-example.newick&quot;) m &lt;- MRCA(x, 75, 76) y &lt;- groupClade(x, m) p &lt;- p1 &lt;- ggtree(y, aes(linetype = group)) + geom_tiplab(size = 2) + theme(legend.position = &#39;none&#39;) p$data[p$data$node %in% c(75, 76), &quot;x&quot;] &lt;- mean(p$data$x) plot_grid(p1, p, ncol=2) Figure A.9: Changing branch length of outgroup. Original tree (A) and reduced outgroup branch length version (B). A.10 Edit tree graphic details It can be hard to modify plot details for ordinary users using ggplot2/ggtree. We recommend using the export package to export ggtree output to ‘Microsoft Office’ Document and edit the tree graphic in ‘PowerPoint’. "],
["ggimage-tips.html", "B Tips for using ggtree with ggimage B.1 Example 1: Remove background of images B.2 Example 2: Plot tree on a background image", " B Tips for using ggtree with ggimage ggtree supports annotating tree with silhouette images via the ggimage package. ggimage provides grammar of graphic syntax to work with image files. It allows processing images on the fly via the image_fun parameter, which accepts a function to process magick-image object. The magick package provides several functions and these functions can be combined to perform a particular task. B.1 Example 1: Remove background of images set.seed(1982) x &lt;- rtree(5) p &lt;- ggtree(x) + theme_grey() p1 &lt;- p + geom_nodelab(image=&quot;img/frogs/frog.jpg&quot;, geom=&quot;image&quot;, size=.12) + ggtitle(&quot;original image&quot;) p2 &lt;- p + geom_nodelab(image=&quot;img/frogs/frog.jpg&quot;, geom=&quot;image&quot;, size=.12, image_fun= function(.) magick::image_transparent(., &quot;white&quot;)) + ggtitle(&quot;image with background removed&quot;) plot_grid(p1, p2, ncol=2) Figure B.1: Remove image background. Plotting silhouette images on phylogenetic tree without (A) and with (B) background remove. B.2 Example 2: Plot tree on a background image The geom_bgimage add a layer of the image and put the layer to the bottom of the layer stack. It is a normal layer and doesn’t change the structure of the output ggtree object. Users can add annotation layers as without the background image layer. ggtree(rtree(20), size=1.5, color=&quot;white&quot;) + geom_bgimage(&#39;img/blackboard.jpg&#39;) + geom_tiplab(color=&quot;white&quot;, size=5, family=&#39;xkcd&#39;) Figure B.2: Use image file as tree background. "],
["commicR.html", "C Comic (xkcd-like) phylogenetic tree", " C Comic (xkcd-like) phylogenetic tree library(htmltools) library(XML) library(gridSVG) library(ggplot2) library(ggtree) library(comicR) p &lt;- ggtree(rtree(30), layout=&quot;circular&quot;) + geom_tiplab(aes(label=label), color=&quot;purple&quot;) print(p) svg &lt;- grid.export(name=&quot;&quot;, res=100)$svg tagList( tags$div( id = &quot;ggtree_comic&quot;, tags$style(&quot;#ggtree_comic text {font-family:Chalkduster;}&quot;), HTML(saveXML(svg)), comicR(&quot;#ggtree_comic&quot;, ff=5) ) ) # %&gt;% html_print #ggtree_comic text {font-family:Chalkduster;} t23 t17 t28 t18 t9 t19 t27 t25 t5 t30 t15 t29 t10 t24 t4 t14 t3 t2 t26 t13 t21 t16 t11 t8 t20 t1 t12 t6 t22 t7 "],
["ascii-tree.html", "D Print ASCII-art rooted tree", " D Print ASCII-art rooted tree library(data.tree) tree &lt;- rtree(10) d &lt;- as.data.frame(as.Node(tree)) names(d) &lt;- NULL print(d, row.names=FALSE) 11 ¦--12 ¦ ¦--13 ¦ ¦ ¦--t4 ¦ ¦ °--t6 ¦ °--t10 °--14 ¦--15 ¦ ¦--16 ¦ ¦ ¦--17 ¦ ¦ ¦ ¦--t5 ¦ ¦ ¦ °--t7 ¦ ¦ °--t2 ¦ °--18 ¦ ¦--t1 ¦ °--t9 °--19 ¦--t3 °--t8 It is neat to print ASCII-art of phylogeny. Sometimes we don’t want to plot the tree, but just take a glance at the tree structure without leaving the focus from R console. However, it is not a good idea to print the whole tree as ASCII text if the tree is large. Sometimes we just want to look at a specific portion of the tree and their immediate relatives. At this scenario, we can use treeio::tree_subset() function (see session 2.4) to extract selected portion of a tree. Then we can print ASCII-art of the tree subset to explore evolutionary relationship of interested species in R console. ggtree supports parsing tip labels as emoji to create phylomoji. With the data.tree and emojifont packages, we can also print phylomoji as ASCII text. library(emojifont) tt &lt;- &#39;((snail,mushroom),(((sunflower,evergreen_tree),leaves),green_salad));&#39; tree &lt;- read.tree(text = tt) tree$tip.label &lt;- emoji(tree$tip.label) d &lt;- as.data.frame(as.Node(tree)) names(d) &lt;- NULL print(d, row.names=FALSE) 7 ¦--8 ¦ ¦--🐌 ¦ °--🍄 °--9 ¦--10 ¦ ¦--11 ¦ ¦ ¦--🌻 ¦ ¦ °--🌲 ¦ °--🍃 °--🥗 "],
["facet-zoom.html", "E Zoom in selected portion", " E Zoom in selected portion set.seed(2019-08-05) x &lt;- rtree(30) nn &lt;- tidytree::offspring(x, 43, self_include=TRUE) ggtree(x) + ggforce::facet_zoom(xy = node %in% nn) Figure E.1: Zoom in selected clade. "],
["run-ggtree-in-jupyter-notebook.html", "F Run ggtree in Jupyter notebook", " F Run ggtree in Jupyter notebook If you have Jupyter notebook installed on your system, you can install IRkernel with the following command in R: install.packages(&quot;IRkernel&quot;) IRkernel::installspec() Then you can use ggtree and other R packages in Jupyter notebook. Here is a screenshot of recreating Figure 8.6 in Jupyter notebook. Figure F.1: ggtree in Jupyter notebook. Running ggtree in Jupyter notebook via R kernel. "],
["figures-and-tables.html", "G Figures and Tables", " G Figures and Tables Table G.1: Geometric layers that supported by ‘geom_facet()’ and ‘facet_plot()’ Package Geom Layer Description ggalt geom_dumbbell creates dumbbell charts ggbio geom_alignment shows interval data as alignment ggfittext geom_fit_text shrinks, grows or wraps text to fit inside a defined rectangular area gggenes geom_gene_arrow draws genes as arrows ggimage geom_image visualizes image files geom_phylopic queries image files from phylopic database and visualizes them ggplot2 geom_hline adds horizontal lines geom_jitter adds a small amount of random variation to the location of each point geom_label draws a rectangle behind the text geom_point creats scatterplots geom_raster a high performance special case for all the tiles are the same size geom_rect draws rectangle by using the locations of the four coners geom_segment draws a straight line between points geom_spoke a polar parameterisation of ‘geom_segment()’ geom_text adds text to the plot geom_tile draws rectangle by using the center of the tile and its size geom_vline adds vertical lines ggrepel geom_text_repel adds text to the plot. The text labels repel away from each other and away from the data points geom_label_repel draws a rectangle underneath the text. The text labels repel away from each other and away from the data ponts ggridges geom_density_ridges arranges multiple density plots in a staggered fashion geom_density_ridges_gradient works just like ‘geom_density_ridges’ except that the ‘fill’ aesthetic can vary along the x axis geom_ridgeline plots the sum of the ‘y’ and ‘height’ aesthetics versus ‘x’, filling the area between ‘y’ and ‘y + height’ with a color geom_ridgeline_gradient works just like ‘geom_ridgeline’ except that the ‘fill’ aesthetic can vary along the x axis ggstance geom_barh horizontal version of ‘geom_bar()’ geom_boxploth horizontal version of ‘geom_boxplot()’ geom_crossbarh horizontal version of ‘geom_crossbar()’ geom_errorbarh horizontal version of ‘geom_errorbarh()’ geom_histogramh horizontal version of ‘geom_histogram()’ geom_linerangeh horizontal version of ‘geom_linerange()’ geom_pointrangeh horizontal version of ‘geom_pointrange()’ geom_violinh horizontal version of ‘geom_violin()’ ggtree geom_motif draws aligned motifs "],
["session-info.html", "H Session Info", " H Session Info The book was written using R Markdown and was compiled by bookdown package. Here is the session information on the system on which this thesis was compiled: ## ─ Session info ───────────────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.1 (2019-07-05) ## os Anarchy Linux ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Asia/Chongqing ## date 2019-09-28 ## ## ─ Packages ───────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## ade4 * 1.7-13 2018-08-31 [1] CRAN (R 3.6.0) ## animation 2.6 2018-12-11 [1] CRAN (R 3.6.0) ## ape * 5.3 2019-03-17 [1] CRAN (R 3.6.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.0) ## backports 1.1.4 2019-04-10 [1] CRAN (R 3.6.0) ## Biobase 2.44.0 2019-05-02 [1] Bioconductor ## BiocGenerics * 0.30.0 2019-05-02 [1] Bioconductor ## BiocManager 1.30.4 2018-11-13 [1] CRAN (R 3.6.0) ## biomformat 1.12.0 2019-05-02 [1] Bioconductor ## Biostrings * 2.52.0 2019-05-02 [1] Bioconductor ## bitops 1.0-6 2013-08-17 [1] CRAN (R 3.6.0) ## bookdown * 0.13 2019-08-21 [1] CRAN (R 3.6.1) ## brew 1.0-6 2011-04-13 [1] CRAN (R 3.6.0) ## callr 3.3.2 2019-09-22 [1] CRAN (R 3.6.1) ## cli 1.1.0 2019-03-19 [1] CRAN (R 3.6.0) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 3.6.1) ## clusterGeneration 1.3.4 2015-02-18 [1] CRAN (R 3.6.0) ## coda 0.19-3 2019-07-05 [1] CRAN (R 3.6.0) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 3.6.1) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.0) ## combinat 0.0-8 2012-10-29 [1] CRAN (R 3.6.0) ## comicR * 0.2 2019-06-05 [1] Github (timelyportfolio/comicR@f6131f4) ## cowplot * 1.0.0 2019-07-11 [1] CRAN (R 3.6.1) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.0) ## data.table 1.12.2 2019-04-07 [1] CRAN (R 3.6.0) ## data.tree * 0.7.8 2018-09-24 [1] CRAN (R 3.6.0) ## desc 1.2.0 2018-05-01 [1] CRAN (R 3.6.0) ## devtools 2.2.1 2019-09-24 [1] CRAN (R 3.6.1) ## DiagrammeR 1.0.1 2019-04-22 [1] CRAN (R 3.6.0) ## digest 0.6.21 2019-09-20 [1] CRAN (R 3.6.1) ## downloader 0.4 2015-07-09 [1] CRAN (R 3.6.0) ## dplyr * 0.8.3 2019-07-04 [1] CRAN (R 3.6.1) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 3.6.1) ## emojifont * 0.5.2 2018-06-20 [1] CRAN (R 3.6.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.0) ## expm 0.999-4 2019-03-21 [1] CRAN (R 3.6.0) ## fastmatch 1.1-0 2017-01-28 [1] CRAN (R 3.6.0) ## foreach 1.4.7 2019-07-27 [1] CRAN (R 3.6.1) ## fs 1.3.1 2019-05-06 [1] CRAN (R 3.6.0) ## ggfittext 0.8.1 2019-07-18 [1] CRAN (R 3.6.1) ## gggenes * 0.4.0 2019-06-24 [1] CRAN (R 3.6.1) ## ggimage * 0.2.3 2019-09-23 [1] CRAN (R 3.6.1) ## ggmap 3.0.0 2019-02-05 [1] CRAN (R 3.6.1) ## ggnewscale * 0.3.0 2019-07-05 [1] CRAN (R 3.6.1) ## ggplot2 * 3.2.1 2019-08-10 [1] CRAN (R 3.6.1) ## ggplotify 0.0.4 2019-08-06 [1] CRAN (R 3.6.1) ## ggrepel * 0.8.1 2019-05-07 [1] CRAN (R 3.6.0) ## ggridges * 0.5.1 2018-09-27 [1] CRAN (R 3.6.0) ## ggstance * 0.3.3 2019-08-19 [1] CRAN (R 3.6.1) ## ggtree * 1.99.1 2019-09-28 [1] Bioconductor ## glue 1.3.1 2019-03-12 [1] CRAN (R 3.6.0) ## gridExtra 2.3 2017-09-09 [1] CRAN (R 3.6.0) ## gridGraphics 0.4-1 2019-05-20 [1] CRAN (R 3.6.0) ## gridSVG * 1.7-0 2019-02-12 [1] CRAN (R 3.6.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.0) ## gtools 3.8.1 2018-06-26 [1] CRAN (R 3.6.0) ## highr 0.8 2019-03-20 [1] CRAN (R 3.6.0) ## hms 0.5.1 2019-08-23 [1] CRAN (R 3.6.1) ## htmltools * 0.3.6 2017-04-28 [1] CRAN (R 3.6.0) ## htmlwidgets 1.3 2018-09-30 [1] CRAN (R 3.6.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 3.6.1) ## igraph * 1.2.4.1 2019-04-22 [1] CRAN (R 3.6.0) ## influenceR 0.1.0 2015-09-03 [1] CRAN (R 3.6.0) ## IRanges * 2.18.2 2019-08-24 [1] Bioconductor ## iterators 1.0.12 2019-07-26 [1] CRAN (R 3.6.1) ## jpeg 0.1-8 2014-01-23 [1] CRAN (R 3.6.1) ## jsonlite * 1.6 2018-12-07 [1] CRAN (R 3.6.0) ## kableExtra * 1.1.0 2019-03-16 [1] CRAN (R 3.6.0) ## knitr * 1.25 2019-09-18 [1] CRAN (R 3.6.1) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.6.0) ## lattice 0.20-38 2018-11-04 [2] CRAN (R 3.6.1) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.0) ## lifecycle 0.1.0 2019-08-01 [1] CRAN (R 3.6.1) ## magick 2.2 2019-08-26 [1] CRAN (R 3.6.1) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.6.0) ## maps * 3.3.0 2018-04-03 [1] CRAN (R 3.6.0) ## MASS 7.3-51.4 2019-03-31 [2] CRAN (R 3.6.1) ## Matrix 1.2-17 2019-03-22 [2] CRAN (R 3.6.1) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.6.0) ## mgcv 1.8-28 2019-03-21 [2] CRAN (R 3.6.1) ## mnormt 1.5-5 2016-10-15 [1] CRAN (R 3.6.0) ## multtest 2.40.0 2019-05-02 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.0) ## network * 1.15 2019-04-02 [1] CRAN (R 3.6.1) ## networkDynamic 0.10.0 2019-04-05 [1] CRAN (R 3.6.1) ## nlme 3.1-140 2019-05-12 [2] CRAN (R 3.6.1) ## numDeriv 2016.8-1.1 2019-06-06 [1] CRAN (R 3.6.0) ## OutbreakTools * 0.1-16 2017-10-05 [1] CRAN (R 3.6.1) ## permute 0.9-5 2019-03-12 [1] CRAN (R 3.6.0) ## phangorn 2.5.5 2019-06-19 [1] CRAN (R 3.6.0) ## phylobase * 0.8.6 2019-02-02 [1] CRAN (R 3.6.0) ## phyloseq * 1.28.0 2019-05-02 [1] Bioconductor ## phytools * 0.6-99 2019-06-18 [1] CRAN (R 3.6.0) ## pillar 1.4.2 2019-06-29 [1] CRAN (R 3.6.0) ## pkgbuild 1.0.5 2019-08-26 [1] CRAN (R 3.6.1) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 3.6.1) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 3.6.0) ## plotrix 3.7-6 2019-06-21 [1] CRAN (R 3.6.1) ## plyr 1.8.4 2016-06-08 [1] CRAN (R 3.6.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.6.1) ## prettyunits 1.0.2 2015-07-13 [1] CRAN (R 3.6.0) ## processx 3.4.1 2019-07-18 [1] CRAN (R 3.6.1) ## progress 1.2.2 2019-05-16 [1] CRAN (R 3.6.0) ## proto 1.0.0 2016-10-29 [1] CRAN (R 3.6.0) ## ps 1.3.0 2018-12-21 [1] CRAN (R 3.6.0) ## purrr 0.3.2 2019-03-15 [1] CRAN (R 3.6.0) ## quadprog 1.5-7 2019-05-06 [1] CRAN (R 3.6.0) ## R6 2.4.0 2019-02-14 [1] CRAN (R 3.6.0) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 3.6.0) ## Rcpp 1.0.2 2019-07-25 [1] CRAN (R 3.6.1) ## RCurl 1.95-4.12 2019-03-04 [1] CRAN (R 3.6.0) ## readr 1.3.1 2018-12-21 [1] CRAN (R 3.6.0) ## remotes 2.1.0 2019-06-24 [1] CRAN (R 3.6.1) ## reshape2 * 1.4.3 2017-12-11 [1] CRAN (R 3.6.0) ## rgexf 0.15.3 2015-03-24 [1] CRAN (R 3.6.0) ## RgoogleMaps 1.4.4 2019-08-20 [1] CRAN (R 3.6.1) ## rhdf5 2.28.0 2019-05-02 [1] Bioconductor ## Rhdf5lib 1.6.1 2019-09-09 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] CRAN (R 3.6.1) ## rlang 0.4.0 2019-06-25 [1] CRAN (R 3.6.0) ## rmarkdown 1.15 2019-08-21 [1] CRAN (R 3.6.1) ## rncl 0.8.3 2018-07-27 [1] CRAN (R 3.6.0) ## RNeXML 2.3.0 2019-01-24 [1] CRAN (R 3.6.0) ## Rook 1.1-1 2014-10-20 [1] CRAN (R 3.6.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.0) ## rstudioapi 0.10 2019-03-19 [1] CRAN (R 3.6.0) ## rvcheck 0.1.4 2019-07-19 [1] Github (GuangchuangYu/rvcheck@9f80f7b) ## rvest 0.3.4 2019-05-15 [1] CRAN (R 3.6.0) ## S4Vectors * 0.22.1 2019-09-09 [1] Bioconductor ## scales * 1.0.0 2018-08-09 [1] CRAN (R 3.6.0) ## scatterplot3d 0.3-41 2018-03-14 [1] CRAN (R 3.6.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.0) ## showtext 0.7 2019-06-11 [1] CRAN (R 3.6.0) ## showtextdb 2.0 2017-09-11 [1] CRAN (R 3.6.0) ## sna 2.4 2016-08-08 [1] CRAN (R 3.6.1) ## statnet.common 4.3.0 2019-06-02 [1] CRAN (R 3.6.1) ## stringi 1.4.3 2019-03-12 [1] CRAN (R 3.6.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.0) ## survival 2.44-1.1 2019-04-01 [2] CRAN (R 3.6.1) ## sysfonts 0.8 2018-10-11 [1] CRAN (R 3.6.0) ## testthat 2.2.1 2019-07-25 [1] CRAN (R 3.6.1) ## tibble * 2.1.3 2019-06-06 [1] CRAN (R 3.6.0) ## tidyr * 1.0.0 2019-09-11 [1] CRAN (R 3.6.1) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.6.0) ## tidytree * 0.2.8 2019-09-27 [1] local ## treeio * 1.9.3 2019-09-28 [1] Bioconductor ## usethis 1.5.1 2019-07-04 [1] CRAN (R 3.6.1) ## uuid 0.1-2 2015-07-28 [1] CRAN (R 3.6.0) ## vctrs 0.2.0 2019-07-05 [1] CRAN (R 3.6.0) ## vegan 2.5-6 2019-09-01 [1] CRAN (R 3.6.1) ## viridis 0.5.1 2018-03-29 [1] CRAN (R 3.6.0) ## viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.6.0) ## visNetwork 2.0.8 2019-08-28 [1] CRAN (R 3.6.1) ## webshot 0.5.1 2018-09-28 [1] CRAN (R 3.6.0) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.6.0) ## xfun 0.9 2019-08-21 [1] CRAN (R 3.6.1) ## XML * 3.98-1.20 2019-06-06 [1] CRAN (R 3.6.0) ## xml2 1.2.2 2019-08-09 [1] CRAN (R 3.6.1) ## XVector * 0.24.0 2019-05-02 [1] Bioconductor ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.6.0) ## zeallot 0.1.0 2018-01-28 [1] CRAN (R 3.6.0) ## zlibbioc 1.30.0 2019-05-02 [1] Bioconductor ## ## [1] /home/ygc/R/library ## [2] /usr/lib/R/library "],
["references.html", "References", " References "]
]
