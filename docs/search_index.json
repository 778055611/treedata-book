[
["index.html", "Data Integration, Manipulation and Visualization of Phylogenetic Trees Preface", " Data Integration, Manipulation and Visualization of Phylogenetic Trees Guangchuang Yu Preface You can’t even begin to understand biology, you can’t understand life, unless you understand what it’s all there for, how it arose - and that means evolution. — Richard Dawkins "],
["importing-tree-with-data.html", "Chapter 1 Importing tree with data 1.1 Overview of Phylogenetic Tree Construction 1.2 Phylogenetic Tree Formats 1.3 Getting Tree Data with treeio 1.4 Summary", " Chapter 1 Importing tree with data 1.1 Overview of Phylogenetic Tree Construction Phylogenetic trees are used to describe genealogical relationships among a group of organisms, which can be constructed based on the genetic sequences of the organisms. A rooted phylogenetic tree represents a model of evolutionary history depicted by ancestor-descendant relationships between tree nodes and clustering of ‘sister’ or ‘cousin’ organisms at different level of relatedness, as illustrated in Figure 1.1. In infectious disease research, phylogenetic trees are usually built from the pathogens’ gene or genome sequences to show which pathogen sample is genetically closer to a pathogen sample, providing insights into the underlying unobserved epidemiologic linkage and potential source of an outbreak. Figure 1.1: Components of a phylogenetic tree. External nodes (green circles), also called ‘tips’, represent actual organisms sampled and sequenced (e.g., virus in infectious disease research). They are the ‘taxa’ in the terminology of evolutionary biology. The internal nodes (blue circles) represent hypothetical ancestors for the tips. The root (red circle) is the common ancestor of all species in the tree. The horizontal lines are branches and represent evolutionary changes (grey number) measured in unit of time or genetic divergence. The bar at the bottom provides the scale of these branch lengths. Phylogenetic tree can be constructed from genetic sequences using distance-based methods or character-based methods. Distance-based methods, including nweighted air roup ethod with rithmetic means (UPGMA) and Neighbor-joining (NJ), are based on the matrix of pairwise genetic distances calculated between sequences. The character-based methods, including maximum parsimony (MP) (Fitch 1971), maximum likelihood (ML) (Felsenstein 1981), and Bayesian Markov Chain Monte Carlo (BMCMC) method (Rannala and Yang 1996), are based on mathematical model that describes the evolution of genetic characters and search for the best phylogenetic tree according to their own optimality criteria. Maximum Parsimony (MP) method assumes that the evolutionary change is rare and minimizes the amount of character-state changes (e.g., number of DNA substitutions). The criterion is similar to Occam’s razor, that the simplest hypothesis that can explains the data is the best hypothesis. Unweighted parsimony assumes mutations across different characters (nucleotides or amino acids) are equally likely while weighted method assume unequal likely of mutations (e.g., the third codon position is more liable than other codon positions; and the transition mutations have higher frequency than transversion). The concept of MP method is straightforward and intuitive, which is a probable reason for its popularity amongst biologist users who care more about the research question rather than the computational details of the analysis. However, this method has a number of disadvantages, which in particular the tree inference can be biased by the well-known systematic error called long-branch attraction (LBA) that incorrectly infer distantly related lineages as closely related (Felsenstein 1978). This is because MP method poorly takes into consideration of many sequence evolution factors (e.g., reversals and convergence) that are hardly observable from the existing genetic data. Maximum likelihood (ML) method and Bayesian Markov Chain Monte Carlo (BMCMC) method are the two most commonly used methods in phylogenetic tree construction and are most often used in scientific publications. ML and BMCMC methods require a substitution model of sequence evolution. Different sequence data have different substitution models to formulate the evolutionary process of DNA, codon and amino acid. There are several models for nucleotide substitution, including JC69, K2P, F81, HKY and GTR (Arenas 2015). These models can be used in conjunction with the rate variation across sites (denoted as +\\(\\Gamma\\))) (Yang 1994) and the proportion of invariable sites (denoted as +I) (Shoemaker and Fitch 1989). Previous research (Lemmon and Moriarty 2004) had suggested that misspecification of substitution model might bias phylogenetic inference. Procedural testing for the best-fit substitution model is recommended. The optimal criterion of ML method is to find the tree that maximizes the likelihood given the sequence data. The procedure of ML method is simple: calculating the likelihood of a tree and optimizing its topology and branches (and the substitution model parameters, if not fixed) until the best tree is found. Heuristic search such as those implemented in PhyML and RAxML, is often used to find the best tree based on the likelihood criterion. Bayesian method finds the tree that maximizes posterior probability by sampling trees through MCMC based on the given substitution model. One of the advantage of BMCMC is that parameter variance and tree topological uncertainty (included by the posterior clade probability; see below) can be naturally and conveniently obtained from the sampling trees in MCMC process. Moreover, influence of topological uncertainty to other parameter estimates are also naturally integrated in the BMCMC phylogenetic framework. In a simple phylogenetic tree, data associated with the tree branches/nodes could be the branch lengths (indicating genetic or time divergence) and lineage supports such as bootstrap values estimated from bootstrapping procedure or posterior clade probability summarized from the sampled trees in the BMCMC analysis. 1.2 Phylogenetic Tree Formats There are several file formats designed to store phylogenetic trees and the data associated with the nodes and branches. The three commonly used formats are Newick1, NEXUS (Maddison et al. 1997) and Phylip (Felsenstein 1989). Some formats (e.g., NHX) are extended from Newick format. Newick and NEXUS formats are supported as input by most of the software in evolutionary biology, while some of the software tools output newer standard files (e.g., BEAST and MrBayes) by introducing new rules/data blocks for storing evolutionary inferences. On the other cases (e.g., PAML and r8s), output log files are only recognized by their own single software. 1.2.1 Newick tree format The Newick tree format is the standard for representing trees in computer-readable form. Figure 1.2: A sample tree for demonstrating Newick text to encode tree structure. Tips were aligned to right hand side and branch lengths were labelled on the middle of each branch. The rooted tree shown in Figure 1.2 can be represented by the following sequence of characters as a newick tree text. (t5:0.89,((t4:0.59,t1:0.37):0.34,(t2:0.03,t3:0.67):0.9):0.04); The tree text ends with semicolon. Internal nodes are represented by a pair of matched parentheses. Between the parentheses are descendant nodes of that node. For instance (t4:0.59, t1:0.37) represents the parent node of t4 and t1 that are the immediate descendants. Sibling nodes are separated by comma and tips are represented by their names. A branch length (from parent node to child node) is represented by a real number after the child node and preceded by a colon. Singular data (e.g., bootstrap values) associated with internal nodes or branches maybe encoded as node label and represented by the simple text/numbers before the colon. Newick tree format was developed by Meacham in 1984 for the PHYLIP (Retief 2000) package. Newick format is now the most widely used tree format and used by PHYLIP, PAUP* (Wilgenbusch and Swofford 2003), TREE-PUZZLE (Schmidt et al. 2002), MrBayes and many other applications. Phylip tree format contains Phylip multiple sequence alignment (MSA) with a corresponding Newick tree text that was built based on the MSA sequences in the same file. 1.2.2 NEXUS tree format The NEXUS format incorporates Newick tree text with related information organized into separated units known as blocks. A NEXUS block has the following structure: #NEXUS ... BEGIN characters; ... END; For example, the above example tree can be saved as a following NEXUS format: #NEXUS [R-package APE, Wed Nov 9 11:46:32 2016] BEGIN TAXA; DIMENSIONS NTAX = 5; TAXLABELS t5 t4 t1 t2 t3 ; END; BEGIN TREES; TRANSLATE 1 t5, 2 t4, 3 t1, 4 t2, 5 t3 ; TREE * UNTITLED = [&amp;R] (1:0.89,((2:0.59,3:0.37):0.34, (4:0.03,5:0.67):0.9):0.04); END; Comments can be placed by using square brackets. Some blocks can be recognized by most of the programs including TAXA (contains information of taxa), DATA (contains data matrix, e.g., sequence alignment) and TREE (contains phylogenetic tree, i.e., Newick tree text). Notably, blocks can be very diversed and some of them are only be recognized by one particular program. For example NEXUS file exported by PAUP* has a paup block which contains PAUP* commands, whereas FigTree exports NEXUS file with a figtree block that contains visualization settings. NEXUS organizes different types of data into different blocks, whereas programs that support reading NEXUS can parse some blocks they recognized and ignore those they could not. This is a good mechanism to allow different programs to use the same format without crashing when unsupported types of data are present. Notably most of the programs only support parsing TAXA, DATA and TREE blocks, therefore a program/platform that could generically read all kinds of data blocks from the NEXUS would be useful for phylogenetic data integration. The DATA block is widely used to store sequence alignment. For this purpose, user can store tree and sequence data in Phylip format which are essentially Phylip multiple sequence alignment and Newick tree text respectively. It is used in Phylogeny Inference Package (PHYLIP). 1.2.3 New Hampshire eXtended format Newick, NEXUS and phylip are mainly designed to store phylogenetic tree and basic singular data associated with internal nodes or branches. In addition to the singular data annotation at branches and nodes (mentioned above), New Hampshire eXtended format (NHX), which is based on Newick (also called New Hampshire), was developed to introduce tags to associate multiple data fields with the tree nodes (both internal nodes and tips). Tags are placed after branch length and must be wrapped between [&amp;&amp;NHX and ] which makes it possible to compatible with NEXUS format as it defined characters between [ and ] as comments. NHX is also the output format of PHYLODOG (Boussau et al. 2013) and RevBayes (Höhna et al. 2016). A Tree Viewer (ATV) (Zmasek and Eddy 2001) is a java tool that supports displaying annotation data stored in NHX format, but this package is no more maintained. Here is a sample tree from NHX definition document2: (((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]): 0.05[&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY: 0.1[&amp;&amp;NHX:S=nematode],ADHX: 0.12[&amp;&amp;NHX:S=insect]):0.1[&amp;&amp;NHX:S=metazoa:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast],ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast],ADH1:0.11[&amp;&amp;NHX:S=yeast]): 0.1[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:D=N]; 1.2.4 Jplace format In order to store the NGS short reads mapped onto a phylogenetic tree (for the purpose of metagenomic classification; illustrated with more details in Chapter 5), Matsen proposed jplace format for such phylogenetic placements (Matsen et al. 2012). Jplace format is based on JSON and contains four keys: tree, fields, placements, metadata and version. The tree value contains tree text extended from Newick tree format by putting the edge label in brackets (if available) after branch length and putting the edge number in curly braces after edge label. The fields value contains header information of placement data. The value of placements is a list of pqueries. Each pquery contains two keys: p for placements and n for name or nm for names with multiplicity. The value of p is a list of placement for that pqueries. Here is a jplace sample file: { &quot;tree&quot;: &quot;(((((((A:4{1},B:4{2}):6{3},C:5{4}):8{5},D:6{6}): 3{7},E:21{8}):10{9},((F:4{10},G:12{11}):14{12},H:8{13}): 13{14}):13{15},((I:5{16},J:2{17}):30{18},(K:11{19}, L:11{20}):2{21}):17{22}):4{23},M:56{24});&quot;, &quot;placements&quot;: [ {&quot;p&quot;:[24, -61371.300778, 0.333344, 0.000003, 0.003887], &quot;n&quot;:[&quot;AA&quot;] }, {&quot;p&quot;:[[1, -61312.210786, 0.333335, 0.000001, 0.000003], [2, -61322.210823, 0.333322, 0.000003, 0.000003], [3, -61352.210823, 0.333322, 0.000961, 0.000003]], &quot;n&quot;:[&quot;BB&quot;] }, {&quot;p&quot;:[[8, -61312.229128, 0.200011, 0.000001, 0.000003], [9, -61322.229179, 0.200000, 0.000003, 0.000003], [10, -61342.229223, 0.199992, 0.000003, 0.000003]], &quot;n&quot;:[&quot;CC&quot;] } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;a jplace sample file&quot;}, &quot;version&quot; : 2, &quot;fields&quot;: [&quot;edge_num&quot;, &quot;likelihood&quot;, &quot;like_weight_ratio&quot;, &quot;distal_length&quot;, &quot;pendant_length&quot; ] } Jplace is the output format of pplacer (Frederick A. Matsen, Kodner, and Armbrust 2010) and Evolutionary Placement Algorithm (EPA) (Berger, Krompass, and Stamatakis 2011a). But these two programs do not contain tools to visualize placement results. Pplacer provides placeviz to convert jplace file to phyloXML or Newick formats which can be visualized by Archaeopteryx3. 1.2.5 Software outputs RAxML (Stamatakis 2014) can output Newick format by storing the bootstrap values as internal node labels. Another way that RAxML supported is to place bootstrap value inside square brackets and after branch length. This could not be supported by most of the software that support Newick format where square brackets will be ignored. BEAST (Bouckaert et al. 2014) output is based on NEXUS and it also introduce square brackets in the tree block to store evolutionary evidences inferred by BEAST. Inside brackets, curly braces may also incorporated if feature values have length more than 1 (e.g., HPD or range of substitution rate). These brackets are placed between node and branch length (i.e., after label if exists and before colon). Bracket is not defined in Newick format and is reserve character for NEXUS comment. So these information will be ignored for standard NEXUS parsers. Here is a sample TREE block of the BEAST output: tree TREE1 = [&amp;R] (((11[&amp;length=9.4]:9.38,14[&amp;length=6.4]: 6.385096430786298)[&amp;length=25.7]:25.43,4[&amp;length=9.1]: 8.821663252749829)[&amp;length=3.0]:3.10,(12[&amp;length=0.6]: 0.56,(10[&amp;length=1.6]:1.56,(7[&amp;length=5.2]:5.19, ((((2[&amp;length=3.3]:3.26,(1[&amp;length=1.3]:1.32, (6[&amp;length=0.8]:0.83,13[&amp;length=0.8]:0.8311577761397366) [&amp;length=2.4]:2.48917886025146)[&amp;length=0.9]: 0.9416178372674331)[&amp;length=0.4]:0.49,9[&amp;length=1.7]: 1.757288031101215)[&amp;length=2.4]:2.35,8[&amp;length=2.1]: 2.1125745387283246)[&amp;length=0.2]:0.23,(3[&amp;length=3.3]:3.31, (15[&amp;length=5.2]:5.27,5[&amp;length=3.2]:3.2710481368304585) [&amp;length=1.0]:1.0409443024626412)[&amp;length=1.9]: 2.0372962536780435)[&amp;length=2.8]:2.8446835614595685) [&amp;length=5.3]:5.367459711197171)[&amp;length=2.0]: 2.0037467863383043)[&amp;length=4.3]:4.360909907798238) [&amp;length=0.0]; BEAST output can contain many different evolutionary inferences, depending of the analysis models defined in BEAUTi for running. For example in molecular clock analysis, it contains rate, length, height, posterior and corresponding HPD and range for uncertainty estimation. Rate is the estimated evolutionary rate of the branch. Length is the length of the branch in years. Height is the time from node to root while posterior is the Bayesian clade credibility value. The above example is the output tree of clock analysis and should contains these inferences. To save space, I only keep the length above. MrBayes (Huelsenbeck and Ronquist 2001) is a program that uses Markov Chain Monte Carlo method to sample from the posterior probability distributions. Its output file annotates nodes and branches separately by two sets of square brackets. For example below, posterior clade probabilities for the node and branch length estimates for the branch: tree con_all_compat = [&amp;U] (8[&amp;prob=1.0]: 2.94e-1[&amp;length_mean=2.9e-1],10[&amp;prob=1.0]: 2.25e-1[&amp;length_mean=2.2e-1],((((1[&amp;prob=1.0]: 1.43e-1[&amp;length_mean=1.4e-1],2[&amp;prob=1.0]: 1.92e-1[&amp;length_mean=1.9e-1])[&amp;prob=1.0]: 1.24e-1[&amp;length_mean=1.2e-1],9[&amp;prob=1.0]: 2.27e-1[&amp;length_mean=2.2e-1])[&amp;prob=1.0]: 1.72e-1[&amp;length_mean=1.7e-1],12[&amp;prob=1.0]: 5.11e-1[&amp;length_mean=5.1e-1])[&amp;prob=1.0]: 1.76e-1[&amp;length_mean=1.7e-1],(((3[&amp;prob=1.0]: 5.46e-2[&amp;length_mean=5.4e-2],(6[&amp;prob=1.0]: 1.03e-2[&amp;length_mean=1.0e-2],7[&amp;prob=1.0]: 7.13e-3[&amp;length_mean=7.2e-3])[&amp;prob=1.0]: 6.93e-2[&amp;length_mean=6.9e-2])[&amp;prob=1.0]: 6.03e-2[&amp;length_mean=6.0e-2],(4[&amp;prob=1.0]: 6.27e-2[&amp;length_mean=6.2e-2],5[&amp;prob=1.0]: 6.31e-2[&amp;length_mean=6.3e-2])[&amp;prob=1.0]: 6.07e-2[&amp;length_mean=6.0e-2])[&amp;prob=1.0]: 1.80e-1[&amp;length_mean=1.8e-1],11[&amp;prob=1.0]: 2.37e-1[&amp;length_mean=2.3e-1])[&amp;prob=1.0]: 4.05e-1[&amp;length_mean=4.0e-1])[&amp;prob=1.0]: 1.16e+000[&amp;length_mean=1.162699558201079e+000])[&amp;prob=1.0] [&amp;length_mean=0]; To save space, most of the inferences were removed and only contains prob for clade probability and length_mean for mean value of branch length. The full version of this file also contains prob_stddev, prob_range, prob(percent), prob+-sd for probability inferences and length_median, length_95%_HPD for every branch. The BEAST and MrBayes outputs are expected to be parsed without inferences (dropped as comments) by software that support NEXUS. FigTree supports parsing BEAST and MrBayes outputs with inferences that can be used to display or annotate on the tree. But from there extracting these data for further analysis is still challenging. HyPhy (Pond, Frost, and Muse 2005) could do a number of phylogenetic analysis, including ancestral sequence reconstruction. For ancestral sequence reconstruction, these sequences and the Newick tree text are stored in NEXUS format as the major analysis output. It did not completely follow the NEXUS definition and only put the ancestral node labels in TAXA instead of external node label. The MATRIX block contains sequence alignment of ancestral nodes which cannot be referred back to the tree stored in TREES block since it does not contains node labels. Here is the sample output (to save space, only the first 72bp of alignment are shown): #NEXUS [ Generated by HYPHY 2.0020110620beta(MP) for MacOS(Universal Binary) on Tue Dec 23 13:52:34 2014 ] BEGIN TAXA; DIMENSIONS NTAX = 13; TAXLABELS &#39;Node1&#39; &#39;Node2&#39; &#39;Node3&#39; &#39;Node4&#39; &#39;Node5&#39; &#39;Node12&#39; &#39;Node13&#39; &#39;Node15&#39; &#39;Node18&#39; &#39;Node20&#39; &#39;Node22&#39; &#39;Node24&#39; &#39;Node26&#39; ; END; BEGIN CHARACTERS; DIMENSIONS NCHAR = 2148; FORMAT DATATYPE = DNA GAP=- MISSING=? NOLABELS ; MATRIX ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATTGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAGTGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT END; BEGIN TREES; TREE tree = (K,N,(D,(L,(J,(G,((C,(E,O)),(H,(I,(B,(A,(F,M))))))))))); END; There are other applications that output rich information text that also contains phylogenetic trees with associated data. For example r8s (Sanderson 2003) output three trees in its log file, namely TREE, RATE and PHYLO for branches scaled by time, substitution rate, and absolute substitutions respectively. Phylogenetic Analysis by Maximum Likelihood (PAML) (Yang 2007) is a package of programs for phylogenetic analyses of DNA or protein sequences. Two main programs, BaseML and CodeML, implement a variety of models. BaseML estimates tree topology, branch lengths and substitution parameters using a number of nucleotide substitution models available, including JC69, K80, F81, F84, HKY85, T92, TN93 and GTR. CodeML estimates synonymous and non-synonymous substitution rates, likelihood ratio test of positive selection under codon substitution models (Goldman and Yang 1994). BaseML outputs mlb file that contains input sequence (taxa) alignment and phylogenetic tree with branch length as well as substitution model and other parameters estimated. The supplementary result file, rst, contains sequence alignment (with ancestral sequence if perform reconstruction of ancestral sequences) and Naive Empirical Bayes (NBE) probabilities that each site in the alignment evolved. CodeML outputs mlc file that contains tree structure and estimation of synonymous and non-synonymous substitution rates. CodeML also output supplementary result file, rst, that is similar to BaseML except that site is defined as codon instead of nucleotide. Parsing these files can be tedious and would oftentimes need a number of post-processing steps and require expertise in programming (e.g. with Python4 or Perl5). Introducing square brackets is quite common for storing extra information, including RAxML to store bootstrap value, NHX format for annotation, jplace for edge label and BEAST for evolutionary estimation, etc.. But the positions to place square brackets are not consistent in different software and the contents employ different rules for storing associated data, these properties make it difficult to parse associated data. For most of the software, they will just ignore square brackets and only parse the tree structure if the file is compatible. Some of them contains invalid characters (e.g. curly braces in tree field of jplace format) and even the tree structure can’t be parsed by standard parsers. It is difficult to extract useful phylogeny/taxon-related information from the different analysis outputs produced by various evolutionary inference software, for displaying on the same phylogenetic tree and for further analysis. FigTree supports BEAST output, but not for most of other software outputs that contains evolutionary inferences or associated data. For those output rich text files (e.g. r8s, PAML, etc.), the tree structure cannot be parsed by any tree viewing software and users need expertise to manually extract the phylogenetic tree and other useful result data from the output file. However, such manual operation is slow and error-prone, which is not practical for big-data. It was not easy to retrieve phylogenetic trees with evolutionary data from different analysis outputs of commonly used software in the field. Some of them (e.g., PAML output and jplace file) without software or programming library to support parsing file, while others (e.g., BEAST and MrBayes output) can be parsed without evolutionary inferences as they are stored in square brackets that will be omitted as comment by most of the software. Although FigTree support visualizing evolutionary statistics inferred by BEAST and MrBayes, extracting these data for further analysis is not supported. Different software packages implement different algorithms for different analyses (e.g., PAML for dN/dS, HyPhy for ancestral sequences and BEAST for skyline analysis). Therefore, in encountering the big genomic sequence data, there is a desire need to efficiently and flexibly integrate different analysis inference results for comprehensive understanding, comparison and further analysis. This motivated us to develop the programming library to parse the phylogenetic trees and data from various sources. 1.3 Getting Tree Data with treeio Phylogenetic trees are commonly used to present evolutionary relationships of species. Information associated with taxon species/strains may be further analyzed in the context of the evolutionary history depicted by the phylogenetic tree. For example, host information of the influenza virus strains in the tree could be studied to understand host range of a virus linage. Moreover, such meta-data (e.g., isolation host, time, location, etc.) directly associated with taxon strains are also often subjected to further evolutionary or comparative phylogenetic models and analyses, to infer their dynamics associated with the evolutionary or transmission processes of the virus. All these meta-data or other phenotypic or experimental data are stored either as the annotation data associated with the nodes or branches, and are often produced in inconsistent format by different analysis programs. Getting trees in to R is still limited. Newick and Nexus can be imported by several packages, including ape, phylobase. NeXML format can be parsed by RNeXML. However, analysis results from widely used software packages in this field are not well supported. SIMMAP output can be parsed by phyext2 and phytools. Although PHYLOCH can import BEAST and MrBayes output, only internal node attributes were parsed and tip attributes were ignore. Many other software outputs are mainly required programming expertise to import the tree with associated data. Linking external data, including experimental and clinical data, to phylogeny is another obstacle for evolution biologists. To fill the gap that most of the tree formats or software outputs cannot be parsed within the same software/platform, an R package treeio was developed for parsing various tree file formats and outputs from common evolutionary analysis software. Treeio is developed with the R programming language (R Core Team 2016). Not only the tree structure can be parsed but also the associated data and evolutionary inferences, including NHX annotation, clock rate inferences (from BEAST or r8s (Sanderson 2003) programs), snynonymous and non-synonymous substitutions (from CodeML), and ancestral sequence construction (from HyPhy, BaseML or CodeML), etc.. Currently, treeio is able to read the following file formats: Newick, Nexus, New Hampshire eXtended format (NHX), jplace and Phylip as well as the data outputs from the following analysis programs: BEAST, EPA, HyPhy, MrBayes, PAML, PHYLDOG, pplacer, r8s, RAxML and RevBayes. This is made possible with the several parser functions developed in treeio (Table 1.1). Table 1.1: Parser functions defined in treeio Parser function Description read.beast parsing output of BEAST read.codeml parsing output of CodeML (rst and mlc files) read.codeml_mlc parsing mlc file (output of CodeML) read.hyphy parsing output of HYPHY read.jplace parsing jplace file including output of EPA and pplacer read.mrbayes parsing output of MrBayes read.newick parsing newick string, with ability to parse node label as support values read.nhx parsing NHX file including output of PHYLDOG and RevBayes read.paml_rst parsing rst file (output of BaseML or CodeML) read.phylip parsing phylip file (phylip alignment + newick string) read.r8s parsing output of r8s read.raxml parsing output of RAxML The treeio package defines base classes and functions for phylogenetic tree input and output. It is an infrastructure that enables evolutionary evidences that inferred by commonly used software packages to be used in R. For instance, dN/dS values or ancestral sequences inferred by CODEML (Yang 2007), clade support values (posterior) inferred by BEAST (Bouckaert et al. 2014) and short read placement by EPA (Berger, Krompass, and Stamatakis 2011b) and pplacer (Frederick A Matsen, Kodner, and Armbrust 2010). These evolutionary evidences can be further analyzed in R and used to annotate phylogenetic tree using ggtree (Yu et al. 2017). The growth of analysis tools and models available introduces a challenge to integrate different varieties of data and analysis results from different sources for an integral analysis on the the same phylogenetic tree background. The treeio package provides a merge_tree function to allow combining tree data obtained from different sources. In addition, treeio also enables external data to be linked to phylogenetic tree structure. After parsing, storage of the tree structure with associated data is made through a S4 class, treedata, defined in the treeio package. These parsed data are mapped to the tree branches and nodes inside treedata object, so that they can be efficiently used to visually annotate the tree using ggtree package (Yu et al. 2017) (described in Chapter 4). A programmable platform for phylogenetic data parsing, integration and annotations as such makes us easier to identify the evolutionary dynamics and correlation patterns. 1.3.1 Overview of treeio The treeio package defined S4 classes for storing phylogenetic tree with diverse types of associated data or covariates from different sources including analysis outputs from different software packages. It also defined corresponding parser functions for parsing phylogenetic tree with annotation data and stored as data object in R for further manipulation or analysis (see Table 1.1). Several accessor functions were defined to facilitate accessing the tree annotation data, including get.fields for obtaining annotation features available in the tree object, get.placements for obtaining the phylogenetic placement results (i.e., output of pplacer, EPA, etc.), get.subs for obtaining the genetic substitutions from parent node to child node, and get.tipseq for getting the tip sequences. The S3 class, phylo, which was defined in ape (Paradis, Claude, and Strimmer 2004) package, is widely used in R community and many packages. As treeio uses S4 class, to enable those available R packages to analyze the tree imported by treeio, treeio provides as.phylo function to convert treeio-generated tree object to phylo object that only contains tree structure without annotation data. In the other way, treeio also provides as.treedata function to convert phylo object with evolutionary analysis result (e.g., bootstrap values calculated by ape or ancestral states inferred by phangorn (Schliep 2011)) to be stored as a treedata S4 object, making it easy to map the data to the tree structure and to be visualized using ggtree (introduced in Chapter 4). To allow integration of different kinds of data in phylogenetic tree, treeio provides merge_tree function (details in section 2.3.3) for combining evolutionary statistics/evidences imported from different sources including those common tree files and outputs from analysis programs (Table 1.1). There are other information, such as sampling location, taxonomy information, experimental result and evolutionary traits, etc. that are stored in separate files with user-defined format. In treeio, we could read in these data from the users’ files using standard R IO functions, and attach them to the tree object by the operator, %&lt;+%, defined in our treeio package. After attaching, the data will become the attributes associated with nodes or branches, which can be compared with other data incorporated, or can be visually displayed on the tree. To facilitate storing the merged data into a single file, treeio implemented write.baset and write.jtree function to export treedata object for storing complex data associated with the phylogenetic tree. A full list of functions that defined in treeio can be found in Table A.1. 1.3.2 Function Demonstration 1.3.2.1 Parsing BEAST output file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) beast ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. Since % is not a valid character in names, all the feature names that contain x% will convert to 0.x. For example, length_95%_HPD will be changed to length_0.95_HPD. Not only tree structure but also all the features inferred by BEAST will be stored in the S4 object. These features can be used for tree annotation (Figure ??). The get.fields method return all available features. ##$# Parsing MrBayes output file &lt;- system.file(&quot;extdata/MrBayes&quot;, &quot;Gq_nxs.tre&quot;, package=&quot;treeio&quot;) read.mrbayes(file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/MrBayes/Gq_nxs.tre&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 12 tips and 10 internal nodes. ## ## Tip labels: ## B_h, B_s, G_d, G_k, G_q, G_s, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;length_0.95HPD&#39;, &#39;length_mean&#39;, &#39;length_median&#39;, &#39;prob&#39;, ## &#39;prob_percent&#39;, &#39;prob_range&#39;, &#39;prob_stddev&#39;, &#39;prob+-sd&#39;. 1.3.2.2 Parsing PAML output The read.paml_rst function can parse rst file from BASEML and CODEML. The only difference is the space in the sequences. For BASEML, each ten bases are separated by one space, while for CODEML, each three bases (triplet) are separated by one space. brstfile &lt;- system.file(&quot;extdata/PAML_Baseml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) brst &lt;- read.paml_rst(brstfile) brst ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/PAML_Baseml/rst&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. Similarly, we can parse the rst file from CODEML. crstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) ## type can be one of &quot;Marginal&quot; or &quot;Joint&quot; crst &lt;- read.paml_rst(crstfile, type = &quot;Joint&quot;) crst ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/PAML_Codeml/rst&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. Ancestral sequences inferred by BASEML or CODEML via marginal or joint ML reconstruction methods will be stored in the S4 object and mapped to tree nodes. treeio will automatically determine the substitutions between the sequences at the both ends of each branch. Amino acid substitution will also be determined by translating nucleotide sequences to amino acid sequences. These computed substitutions will also be stored in the S4 object for efficient tree annotation later (Figure ??). CODEML infers selection pressure and estimated dN/dS, dN and dS. These information are stored in output file mlc, which can be parsed by read.codeml_mlc function. mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc &lt;- read.codeml_mlc(mlcfile) mlc ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. In previous session, we separately parsed rst and mlc files. However, they can also be parsed together using read.codeml function. ## tree can be one of &quot;rst&quot; or &quot;mlc&quot; to specify ## using tree from which file as base tree in the object ml &lt;- read.codeml(crstfile, mlcfile, tree = &quot;mlc&quot;) ml ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/PAML_Codeml/rst&#39;, ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, ## &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. All the features in both rst and mlc files were imported into a single S4 object and hence are available for further annotation and visualization. For example, we can annotate and display both dN/dS (from mlc file) and amino acid substitutions (derived from rst file) on the same phylogenetic tree. 1.3.2.3 Parsing HyPhy output Ancestral sequences inferred by HyPhy are stored in the Nexus output file, which contains the tree topology and ancestral sequences. To parse this data file, users can use the read.hyphy.seq function. ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) read.hyphy.seq(ancseq) ## 13 DNA sequences in binary format stored in a list. ## ## All sequences of same length: 2148 ## ## Labels: ## Node1 ## Node2 ## Node3 ## Node4 ## Node5 ## Node12 ## ... ## ## Base composition: ## a c g t ## 0.335 0.208 0.237 0.220 ## (Total: 27.92 kb) To map the sequences on the tree, user shall also provide an internal-node-labelled tree. If users want to determine substitution, they need also provide tip sequences. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) hy ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/HYPHY/labelledtree.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## Node labels: ## Node1, Node2, Node3, Node4, Node5, Node12, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. 1.3.2.4 Parsing r8s output r8s uses parametric, semiparametric and nonparametric methods to relax molecular clock to allow better estimations of divergence times and evolution rates (@ Sanderson 2003). It outputs three trees in log file, namely TREE, RATO and PHYLO for time tree, rate tree and absolute substitution tree respectively. Time tree is scaled by divergence time, rate tree is scaled by substitution rate and absolute substitution tree is scaled by absolute number of substitution. After parsing the file, all these three trees are stored in a multiPhylo object. r8s &lt;- read.r8s(system.file(&quot;extdata/r8s&quot;, &quot;H3_r8s_output.log&quot;, package=&quot;treeio&quot;)) r8s ## 3 phylogenetic trees 1.3.2.5 Parsing output of RAxML bootstraping analysis RAxML bootstraping analysis output a Newick tree text that is not standard as it stores bootstrap values inside square brackets after branch lengths. This file usually cannot be parsed by traditional Newick parser, such as ape::read.tree. The function read.raxml can read such file and stored the bootstrap as an additional features, which can be used to display on the tree or used to color tree branches, etc.. raxml_file &lt;- system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;) raxml &lt;- read.raxml(raxml_file) raxml ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/RAxML/RAxML_bipartitionsBranchLabels.H3&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 64 tips and 62 internal nodes. ## ## Tip labels: ## A_Hokkaido_M1_2014_H3N2_2014, A_Czech_Republic_1_2014_H3N2_2014, FJ532080_A_California_09_2008_H3N2_2008, EU199359_A_Pennsylvania_05_2007_H3N2_2007, EU857080_A_Hong_Kong_CUHK69904_2006_H3N2_2006, EU857082_A_Hong_Kong_CUHK7047_2005_H3N2_2005, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;bootstrap&#39;. 1.3.2.6 Parsing NHX tree NHX (New Hampshire eXtended) format is an extension of Newick by introducing NHX tags. NHX is commonly used in phylogenetics software (including PHYLDOG (Boussau et al. 2013), RevBayes (Höhna et al. 2014)) for storing statistical inferences. The following codes imported a NHX tree with associated data inferred by PHYLDOG. nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) nhx ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;. 1.3.2.7 Parsing Phylip tree Phylip format contains multiple sequence alignment of taxa in Phylip sequence format with corresponding Newick tree text that was built from taxon sequences. Sequence alignment can be sorted based on the tree structure and displayed at the right hand side of the tree using ggtree (Yu et al. 2017). phyfile &lt;- system.file(&quot;extdata&quot;, &quot;sample.phy&quot;, package=&quot;treeio&quot;) phylip &lt;- read.phylip(phyfile) phylip ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/sample.phy&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## ## Unrooted; no branch lengths. 1.3.2.8 Parsing EPA and pplacer output EPA (Berger, Krompass, and Stamatakis 2011b) and PPLACER (Frederick A Matsen, Kodner, and Armbrust 2010) have common output file format, jplace, which can be parsed by read.jplace() function. jpf &lt;- system.file(&quot;extdata/EPA.jplace&quot;, package=&quot;treeio&quot;) jp &lt;- read.jplace(jpf) print(jp) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/EPA.jplace&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 493 tips and 492 internal nodes. ## ## Tip labels: ## CIR000447A, CIR000479, CIR000078, CIR000083, CIR000070, CIR000060, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;nplace&#39;. The number of evolutionary placement on each branch will be calculated and stored as the nplace feature, which can be mapped to line size and/or color using ggtree (Yu et al. 2017). 1.3.2.9 Parsing jtree format The jtree is a JSON based format that was defined in this treeio package to support tree data inter change. Phylogenetic tree with associated data can be exported to a single jtree file using write.jtree function. The jtree can be easily parsed using any JSON parser. The jtree format contains three keys: tree, data and metadata. The tree value contains tree text extended from Newick tree format by putting the edge number in curly braces after branch length. The data value contains node/branch-specific data, while metadata value contains additional meta information. jtree_file &lt;- tempfile(fileext = &#39;.jtree&#39;) write.jtree(beast, file = jtree_file) read.jtree(file = jtree_file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:\\Users\\YGC\\AppData\\Local\\Temp\\RtmpGEUTIm\\file4547a5561a3.jtree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## K_2013, N_2010, D_1987, L_1980, J_1983, G_1992, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_range&#39;, &#39;length&#39;, ## &#39;length_0.95_HPD&#39;, &#39;length_median&#39;, &#39;length_range&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, ## &#39;height_median&#39;, &#39;posterior&#39;. 1.3.3 Getting information from treedata object After the tree was imported, users may want to extract information that stored in the treedata object. treeio provides several accessor methods to extract tree structure, features/attributes that stored in the object and their corresponding values. The get.tree or as.phylo methods can convert the treedata object to phylo object which is the fundamental tree object in the R community and many packages work with phylo object. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) # or get.tree as.phylo(beast_tree) ## ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. The get.fields method return a vector of features/attributes that stored in the object and associated with the phylogeny. get.fields(beast_tree) ## [1] &quot;height&quot; &quot;height_0.95_HPD&quot; &quot;height_median&quot; ## [4] &quot;height_range&quot; &quot;length&quot; &quot;length_0.95_HPD&quot; ## [7] &quot;length_median&quot; &quot;length_range&quot; &quot;posterior&quot; ## [10] &quot;rate&quot; &quot;rate_0.95_HPD&quot; &quot;rate_median&quot; ## [13] &quot;rate_range&quot; The get.data method return a tibble of all the associated data. get.data(beast_tree) ## # A tibble: 151 x 14 ## height height_0.95_HPD height_median height_range length ## &lt;dbl&gt; &lt;list&gt; &lt;dbl&gt; &lt;list&gt; &lt;dbl&gt; ## 1 19 &lt;dbl [2]&gt; 19 &lt;dbl [2]&gt; 2.34 ## 2 17 &lt;dbl [2]&gt; 17 &lt;dbl [2]&gt; 1.18 ## 3 14 &lt;dbl [2]&gt; 14 &lt;dbl [2]&gt; 0.966 ## 4 12 &lt;dbl [2]&gt; 12 &lt;dbl [2]&gt; 1.87 ## 5 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 2.93 ## 6 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; 0.827 ## 7 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; 0.834 ## 8 10.8 &lt;dbl [2]&gt; 10.8 &lt;dbl [2]&gt; 0.233 ## 9 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 1.28 ## 10 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; 0.414 ## # ... with 141 more rows, and 9 more variables: ## # length_0.95_HPD &lt;list&gt;, length_median &lt;dbl&gt;, ## # length_range &lt;list&gt;, posterior &lt;dbl&gt;, rate &lt;dbl&gt;, ## # rate_0.95_HPD &lt;list&gt;, rate_median &lt;dbl&gt;, ## # rate_range &lt;list&gt;, node &lt;int&gt; If users are only interesting a subset of the features/attributes return by get.fields, they can extract the information from the output of get.data or directly subset the data by [ or [[. beast_tree[, c(&quot;node&quot;, &quot;height&quot;)] ## # A tibble: 151 x 2 ## node height ## &lt;int&gt; &lt;dbl&gt; ## 1 10 19 ## 2 9 17 ## 3 36 14 ## 4 31 12 ## 5 29 9 ## 6 28 10 ## 7 39 10 ## 8 90 10.8 ## 9 16 9 ## 10 2 9 ## # ... with 141 more rows head(beast_tree[[&quot;height_median&quot;]]) ## [1] 19 17 14 12 9 10 1.4 Summary Software tools for inferring molecular evolution (e.g., ancestral states, molecular dating and selection pressure, etc.) are proliferating, but there is no single data format that is used by all different programs and capable to store different types of phylogenetic data. Most of the software packages have their own unique output formats and these formats are not compatible with each other. Parsing software outputs is challenging, which restricts the joint analysis using different tools. The treeio provides a set of functions (Table 1.1) for parsing various types of phylogenetic data files. These phylogenetic data can be integrated together that allows further exploration and comparison. Until now, most software tools in field of molecular evolution are isolated and often not fully compatible with each other for input and output files. All these software tools are designed to do their own analysis and the outputs are often not readable in other software. There is no software tool that was particularly designed to unify the inference data from different analysis programs. An efficient incorporation of the different inference data can compare and verify between methods, and comprehend the understanding of the study target at different aspects and angles, which may discover new systematic patterns and bring new insights to generate new hypothesis. As phylogenetic trees are growing in its application to identify patterns in evolutionary context, more different disciplines are employing phylogenetic trees in their research. For example, spatial ecologists may map the geographical positions of the organisms to their phylogenetic trees to understand the biogeography of the species (Schön et al. 2015); disease epidemiologists may incorporate the pathogen sampling time and locations into the phylogenetic analysis to infer the disease transmission dynamics in spatiotemporal space (He et al. 2013); microbiologists may determine the pathogenicity of different pathogen strains and map them into their phylogenetic trees to identify the genetic determinants of the pathogenicity (Bosi et al. 2016); genomic scientists may use the phylogenetic trees to help taxonomically classify their metagenomic sequence data (Gupta and Sharma 2015). A robust tool such as treeio to import and map different types of data into the phylogenetic tree are important to facilitate these phylogenetics-related research, or a.k.a ‘phylodynamics’. Such tool could also help integrate different metadata (time, geography, genotype, epidemiological information) and analysis results (selective pressure, evolutionary rates) at the highest level and provide a comprehensive understanding of the study organisms. In the field of influenza research, there have been such attemps of studying phylodynamics of the influenza virus by mapping different meta-data and analysis results on the same phylogenetic tree and evolutionary time scale (Lam et al. 2015). References "],
["manipulating-tree-with-data.html", "Chapter 2 Manipulating tree with data 2.1 Linking external data to phylogeny 2.2 Combining tree data 2.3 Convert tree object to tidy data frame and vice versa 2.4 Access related nodes 2.5 Grouping taxa", " Chapter 2 Manipulating tree with data 2.1 Linking external data to phylogeny In addition to analysis findings that are associated with the tree as we showed above, there is a wide range of heterogeneous data, including phenotypic data, experimental data and clinical data etc., that need to be integrated and linked to phylogeny. For example, in the study of viral evolution, tree nodes may associated with epidemiological information, such as location, age and subtype. Functional annotations may need to be mapped on gene trees for comparative genomics studies. To facilitate data integration, treeio provides full_join method to link external data to phylogeny and stored in treedata object. Here are examples of linking external data to a phylogenetic tree. After that, we can use exporter to combine the tree and the data to a single tree file. The data that mapped on the phylogenetic tree can also be used to visualize or annotate the tree using ggtree (Yu et al. 2017). file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) x &lt;- data_frame(label = as.phylo(beast)$tip.label, trait = rnorm(Ntip(beast))) full_join(beast, x, by=&quot;label&quot;) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;trait&#39;. N &lt;- Nnode2(beast) y &lt;- data_frame(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N)) full_join(beast, y, by=&quot;node&quot;) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;fake_trait&#39;, ## &#39;another_trait&#39;. 2.2 Combining tree data The treeio package serves as an infrastructure that enables various types of phylogenetic data inferred from common analysis programs to be imported and used in R. For instance dN/dS or ancestral sequences estimated by CODEML, and clade support values (posterior) inferred by BEAST/MrBayes. In addition, treeio package supports linking external data to phylogeny. It brings these external phylogenetic data (either from software output or exteranl sources) to the R community and make it available for further analysis in R. Furthermore, treeio can combine multiple phylogenetic trees together into one with their node/branch-specific attribute data. Essentially, as a result, one such attribute (e.g., substitution rate) can be mapped to another attribute (e.g., dN/dS) of the same node/branch for comparison and further computations. A previously published data set, seventy-six H3 hemagglutinin gene sequences of a lineage containing swine and human influenza A viruses (Liang et al. 2014), was here to demonstrate the utilities of comparing evolutionary statistics inferred by different software. The dataset was re-analyzed by BEAST for timescale estimation and CODEML for synonymous and non-synonymous substitution estimation. In this example, we first parsed the outputs from BEAST using read.beast and from CODEML using read.codeml into two treedata objects. Then the two objects containing separate sets of node/branch-specific data were merged via the merge_tree function. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) rst_file &lt;- system.file(&quot;examples/rst&quot;, package=&quot;ggtree&quot;) mlc_file &lt;- system.file(&quot;examples/mlc&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) codeml_tree &lt;- read.codeml(rst_file, mlc_file) merged_tree &lt;- merge_tree(beast_tree, codeml_tree) merged_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;, ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/rst&#39;, ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;subs&#39;, ## &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, ## &#39;S_x_dS&#39;. After merging the beast_tree and codeml_tree objects, all node/branch-specific data imported from BEAST and CODEML output files are all available in the merged_tree object. The tree object was converted to tidy data frame using tidytree package and visualized as hexbin scatterplot of dN/dS, dN and dS inferred by CODEML versus rate (substitution rate in unit of substitutions/site/year) inferred by BEAST on the same branches. library(tidytree) library(ggplot2) as_tibble(merged_tree) %&gt;% dplyr::select(dN_vs_dS, dN, dS, rate) %&gt;% subset(dN_vs_dS &gt;=0 &amp; dN_vs_dS &lt;= 1.5) %&gt;% tidyr::gather(type, value, dN_vs_dS:dS) %&gt;% ggplot(aes(rate, value)) + geom_hex() + facet_wrap(~factor(type, levels = c(&#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;)), scale=&#39;free_y&#39;) + ylab(NULL) Using merge_tree, we are able to compare analysis results using identical model from different software packages or different models using different or identical software. It also allows users to integrate different analysis finding from different software packages. Merging tree data is not restricted to software findings, associating external data to analysis findings is also granted. The merge_tree function is chainable and allows several tree objects to be merged into one. phylo &lt;- as.phylo(beast_tree) N &lt;- Nnode2(phylo) d &lt;- tibble(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N)) fake_tree &lt;- treedata(phylo = phylo, data = d) triple_tree &lt;- merge_tree(merged_tree, fake_tree) triple_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;, ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/rst&#39;, ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/mlc&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;subs&#39;, ## &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, ## &#39;S_x_dS&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. The triple_tree object showed above contains analysis results obtained from BEAST and CODEML, and evolutionary trait from external sources. All these information can be used to annotate the tree using ggtree (Yu et al. 2017). Manipulating tree object is frustrated with the fragmented functions available for working with phylo object, not to mention linking external data to the phylogeny structure. Using tidy data principles can make phylogenetic tree manipulation tasks easier and consistent with tools already in wide use, including dplyr, tidyr, ggplot2 and ggtree. 2.3 Convert tree object to tidy data frame and vice versa 2.3.1 phylo object The phylo class defined in ape is fundamental for phylogenetic analysis in R. Most of the R packages in this field rely extensively on phylo object. The tidytree package provides as_tibble method to convert the phylo object to tidy data frame, a tbl_tree object. library(ape) set.seed(2017) tree &lt;- rtree(4) tree ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t2&quot; &quot;t1&quot; &quot;t4&quot; &quot;t3&quot; ## ## Rooted; includes branch lengths. x &lt;- as_tibble(tree) x ## # A tibble: 7 x 4 ## parent node branch.length label ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 7 1 0.472 t2 ## 2 7 2 0.274 t1 ## 3 6 3 0.674 t4 ## 4 5 4 0.00202 t3 ## 5 5 5 NA &lt;NA&gt; ## 6 5 6 0.0393 &lt;NA&gt; ## 7 6 7 0.435 &lt;NA&gt; The tbl_tree object can be converted back to a phylo object. as.phylo(x) ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t2&quot; &quot;t1&quot; &quot;t4&quot; &quot;t3&quot; ## ## Rooted; includes branch lengths. Using tbl_tree object makes tree and data manipulation more effective and easier. For example, we can link evolutionary trait to phylogeny using the verbs full_join d &lt;- tibble(label = paste0(&#39;t&#39;, 1:4), trait = rnorm(4)) y &lt;- full_join(x, d, by = &#39;label&#39;) 2.3.2 treedata object The tidytree package defines a treedata class to store phylogenetic tree with associated data. After mapping external data to the tree structure, the tbl_tree object can be converted to a treedata object. as.treedata(y) ## &#39;treedata&#39; S4 object&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## [1] &quot;t2&quot; &quot;t1&quot; &quot;t4&quot; &quot;t3&quot; ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;trait&#39;. The treedata class is also used in treeio package to store evolutionary evidences inferred by commonly used software (BEAST, EPA, HYPHY, MrBayes, PAML, PHYLODOG, pplacer, r8s, RAxML and RevBayes). The tidytree package also provides as_tibble to convert treedata object to a tidy data frame. The phylogentic tree structure and the evolutionary inferences were stored in the tbl_tree object, making it consistent and easier for manipulating evolutionary statistics inferred by different software as well as linking external data to the same tree structure. y %&gt;% as.treedata %&gt;% as_tibble ## # A tibble: 7 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 1 0.472 t2 -0.00152 ## 2 7 2 0.274 t1 -1.96 ## 3 6 3 0.674 t4 1.56 ## 4 5 4 0.00202 t3 -0.265 ## 5 5 5 NA &lt;NA&gt; NA ## 6 5 6 0.0393 &lt;NA&gt; NA ## 7 6 7 0.435 &lt;NA&gt; NA 2.4 Access related nodes dplyr verbs can be applied to tbl_tree directly to manipulate tree data. In addition, tidytree provides several verbs to filter related nodes, including child, parent, offspring, ancestor, sibling and MRCA. These verbs accept a tbl_tree and a selected node which can be node number or label. child(y, 5) ## # A tibble: 2 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 4 0.00202 t3 -0.265 ## 2 5 6 0.0393 &lt;NA&gt; NA parent(y, 2) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6 7 0.435 &lt;NA&gt; NA offspring(y, 5) ## # A tibble: 6 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 1 0.472 t2 -0.00152 ## 2 7 2 0.274 t1 -1.96 ## 3 6 3 0.674 t4 1.56 ## 4 5 4 0.00202 t3 -0.265 ## 5 5 6 0.0393 &lt;NA&gt; NA ## 6 6 7 0.435 &lt;NA&gt; NA ancestor(y, 2) ## # A tibble: 3 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 5 NA &lt;NA&gt; NA ## 2 5 6 0.0393 &lt;NA&gt; NA ## 3 6 7 0.435 &lt;NA&gt; NA sibling(y, 2) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 1 0.472 t2 -0.00152 MRCA(y, 2, 3) ## # A tibble: 1 x 5 ## parent node branch.length label trait ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 5 6 0.0393 &lt;NA&gt; NA 2.5 Grouping taxa tidytree implemented groupOTU and groupClade for adding taxa grouping information to the input tbl_tree object. These grouping information can be used directly in tree visualization (e.g. coloring tree based on grouping) with ggtree. 2.5.1 groupClade The groupClade method accepts an internal node or a vector of internal nodes to add grouping information of clade/clades. nwk &lt;- &#39;(((((((A:4,B:4):6,C:5):8,D:6):3,E:21):10,((F:4,G:12):14,H:8):13):13,((I:5,J:2):30,(K:11,L:11):2):17):4,M:56);&#39; tree &lt;- read.tree(text=nwk) groupClade(as_tibble(tree), c(17, 21)) ## # A tibble: 25 x 5 ## parent node branch.length label group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 20 1 4 A 1 ## 2 20 2 4 B 1 ## 3 19 3 5 C 1 ## 4 18 4 6 D 1 ## 5 17 5 21 E 1 ## 6 22 6 4 F 2 ## 7 22 7 12 G 2 ## 8 21 8 8 H 2 ## 9 24 9 5 I 0 ## 10 24 10 2 J 0 ## # ... with 15 more rows 2.5.2 groupOTU ## the input nodes can be node ID or label groupOTU(x, c(&#39;t1&#39;, &#39;t4&#39;), group_name = &quot;fake_group&quot;) ## # A tibble: 7 x 5 ## parent node branch.length label fake_group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 7 1 0.472 t2 0 ## 2 7 2 0.274 t1 1 ## 3 6 3 0.674 t4 1 ## 4 5 4 0.00202 t3 0 ## 5 5 5 NA &lt;NA&gt; 0 ## 6 5 6 0.0393 &lt;NA&gt; 1 ## 7 6 7 0.435 &lt;NA&gt; 1 The groupOTU will trace back from input nodes to most recent common ancestor. In this example, nodes 2, 3, 7 and 6 (2 (t1) -&gt; 7 -&gt; 6 and 3 (t4) -&gt; 6) are grouping together. Related OTUs are grouping together and they are not necessarily within a clade. They can be monophyletic (clade), polyphyletic or paraphyletic. cls &lt;- list(c1=c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), c2=c(&quot;F&quot;, &quot;G&quot;, &quot;H&quot;), c3=c(&quot;L&quot;, &quot;K&quot;, &quot;I&quot;, &quot;J&quot;), c4=&quot;M&quot;) as_tibble(tree) %&gt;% groupOTU(cls) ## # A tibble: 25 x 5 ## parent node branch.length label group ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; ## 1 20 1 4 A c1 ## 2 20 2 4 B c1 ## 3 19 3 5 C c1 ## 4 18 4 6 D c1 ## 5 17 5 21 E c1 ## 6 22 6 4 F c2 ## 7 22 7 12 G c2 ## 8 21 8 8 H c2 ## 9 24 9 5 I c3 ## 10 24 10 2 J c3 ## # ... with 15 more rows If there are conflicts when tracing back to mrca, user can set overlap parameter to “origin” (the first one counts), “overwrite” (default, the last one counts) or “abandon” (un-selected for grouping), see also discussion here. 2.5.3 Data integration and comparison The treeio serves as an infrastructure that enables various types of phylogenetic data inferred from common analysis programs to be imported and used in R. For instance dN/dS or ancestral sequences estimated by CodeML, short read placement inferred by EPA/pplacer and clade support values (posterior probabilities) inferred by BEAST/MrBayes. Treeio brings these external phylogenetic data to the R community and makes it available for further analysis in R. Furthermore, treeio can combine multiple phylogenetic trees together into one with their node/branch-specific attribute data. Essentially, as a result, one such attribute (e.g., substitution rate) can be mapped to another attribute (e.g., dN/dS) of the same node/branch for comparison and further computations. A previously published data set, seventy-six H3 hemagglutinin gene sequences of a lineage containing swine and human influenza A viruses (Liang et al. 2014), was used here to demonstrate the utilities of comparing evolutionary statistics inferred by different software. The dataset was re-analyzed by BEAST for timescale estimation and CodeML for synonymous and non-synonymous substitutions estimation. In this example, we first parsed the outputs from BEAST using read.beast and from CodeML using read.codeml into two S4 objects. Then the two objects containing separate sets of node/branch-specific data were merged via the merge_tree function. library(treeio) library(ggtree) beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) rst_file &lt;- system.file(&quot;examples/rst&quot;, package=&quot;ggtree&quot;) mlc_file &lt;- system.file(&quot;examples/mlc&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) codeml_tree &lt;- read.codeml(rst_file, mlc_file) merged_tree &lt;- merge_tree(beast_tree, codeml_tree) get.fields(merged_tree) ## [1] &quot;height&quot; &quot;height_0.95_HPD&quot; &quot;height_median&quot; ## [4] &quot;height_range&quot; &quot;length&quot; &quot;length_0.95_HPD&quot; ## [7] &quot;length_median&quot; &quot;length_range&quot; &quot;posterior&quot; ## [10] &quot;rate&quot; &quot;rate_0.95_HPD&quot; &quot;rate_median&quot; ## [13] &quot;rate_range&quot; &quot;subs&quot; &quot;AA_subs&quot; ## [16] &quot;t&quot; &quot;N&quot; &quot;S&quot; ## [19] &quot;dN_vs_dS&quot; &quot;dN&quot; &quot;dS&quot; ## [22] &quot;N_x_dN&quot; &quot;S_x_dS&quot; After merging the beast_tree and codeml_tree objects, all node/branch-specific data imported from BEAST and CodeML output files are all available in the merged_tree object. The tree object was converted to data frame and visualized as hexbin scatterplot of dN/dS, dN and dS inferred by CodeML versus rate (substitution rate in unit of substitutions/site/year) inferred by BEAST on the same branches. library(dplyr) df &lt;- fortify(merged_tree) %&gt;% select(dN_vs_dS, dN, dS, rate) %&gt;% subset(dN_vs_dS &gt;=0 &amp; dN_vs_dS &lt;= 1.5) %&gt;% tidyr::gather(type, value, dN_vs_dS:dS) df$type[df$type == &#39;dN_vs_dS&#39;] &lt;- &#39;dN/dS&#39; df$type &lt;- factor(df$type, levels=c(&quot;dN/dS&quot;, &quot;dN&quot;, &quot;dS&quot;)) ggplot(df, aes(rate, value)) + geom_hex() + facet_wrap(~type, scale=&#39;free_y&#39;) Figure 2.1: Correlation of dN/dS, dN and dS versus substitution rate. After merging the BEAST and CodeML outputs, the branch-specific estimates (substitution rate, dN/dS , dN and dS) from the two analysis programs are compared on the same branch basis. The associations of dN/dS, dN and dS vs. rate are visualized in hexbin scatter plots. The output is illustrated in Fig. 2.1. We can then test the association of these node/branch-specific data using Pearson correlation, which in this case showed that dN and dS, but not dN/dS are significantly (p-values) associated with rate. After merging, all data inferred from different tools can be used to annotate the tree in ggtree (Chapter 3). The following example turned the merged_tree into a graphic object with tree branches colored by branches-specific substitution rates (rate) as shown in Fig. 2.2A. ggtree(merged_tree, aes(color=rate)) + theme_tree2() + scale_color_continuous(high=&#39;#D55E00&#39;, low=&#39;#0072B2&#39;) + geom_tiplab(size=2) The ggtree allows users to easily rescale a tree branches with another numerical variable. Here the tree branch lengths were rescaled and colored by dN inferred by CodeML as demonstrated in Fig. 2.2B. ggtree(merged_tree, branch.length=&#39;dN&#39;, aes(color=dN)) + scale_color_continuous(high=&#39;#D55E00&#39;, low=&#39;#0072B2&#39;) + theme_tree2() + geom_tiplab(size=2) Figure 2.2: Re-scaling tree branches. The tree with branches scaled in time (year from the root) and colored by substitution rates (A). The tree was re-scaled using dN as branch lengths and colored by dN values (B). As demonstrated above, phylogenetic data inferred from different analysis programs can be imported and used to annotate the tree (e.g., color branches or rescale branch lengths, etc.). These data can also be merged for joint analysis (Figure 2.1). They can be displayed on the same tree structure as more complex annotation to help visually inspection of their evolutionary patterns. In this example, we used dN/dS inferred by CodeML to color the tree and annotate the tree with posterior inferred by BEAST. Another example of annotating tree with diverse associated data were presented in Figure ??. ggtree(merged_tree, aes(color=dN_vs_dS), mrsd=&quot;2013-01-01&quot;, ndigits = 2) + geom_text2(aes(label=posterior), hjust=-.1, size=2, color=&quot;black&quot;) + scale_color_continuous(name=&#39;dN/dS&#39;, limits=c(0, 1.5), oob=scales::squish, low=&quot;green&quot;, high=&quot;red&quot;)+ theme_tree2(legend.position=c(.1, .8)) Figure 2.3: Time-scaled tree colored by dN/dS. The tree branches were scaled in time (Gregorian calendar) and colored by dN/dS. Clade posterior was displayed on the most recent common ancestor. Details of annotating phylogenetic tree with covariates and other associated data will be introduced in Chapter 3. All the tree data parsed/merged by treeio can be converted to tidy data frame using the tidytree package. The tidytree package provides tidy interfaces to manipulate tree with associated data. For instances, external data can be linked to phylogeny or evolutionary data obtained from different sources can be merged using tidyverse verbs. After the tree data was manipulated, it can be converted back to treedata object and exported to a single tree file, further analyzed in R or visualized using ggtree (Yu et al. 2017). treeio is seamlessly integrated into the ggtree (Yu et al. 2017) package and all the information either directly imported or linking from external sources can be used to visualize and annotate the tree. References "],
["exporting-tree-with-data.html", "Chapter 3 Exporting tree with data 3.1 Introduction 3.2 Exporting tree data to BEAST Nexus format 3.3 Exporting tree data to jtree format", " Chapter 3 Exporting tree with data 3.1 Introduction The treeio package supports parsing various phylogenetic tree file formats including software outputs that contain evolutionary evidences. Some of the formats are just log file (e.g. PAML and r8s outputs), while some of the others are non-standard formats (e.g. BEAST and MrBayes outputs that introduce square bracket, which was reserved to store comment in standard Nexus format, to store inferences). With treeio, we are now able to parse these files to extract phylogenetic tree and map associated data on the tree structure. Exporting tree structure is easy, users can use as.phyo method defined treeio to convert treedata object to phylo object then using write.tree or write.nexus implemented in ape package (Paradis, Claude, and Strimmer 2004) to export the tree structure as Newick text or Nexus file. This is quite useful for converting non-standard formats to standard format and for extracting tree from software outputs, such as log file. However, exporting tree with associated data is still challenging. These associated data can be parsed from analysis programs or obtained from external sources (e.g. phenotypic data, experimental data and clinical data). The major obstacle here is that there is no standard format that designed for storing tree with data. NeXML (Vos et al. 2012) maybe the most flexible format, however it is currently not widely supported. Most of the analysis programs in this field rely extensively on Newick string and Nexus format. In my opinion, although BEAST Nexus format6 may not be the best solution, it is currently a good approach for storing heterogeneous associated data. The beauty of the format is that all the annotate elements are stored within square bracket, which is reserved for comments. So that the file can be parsed as standard Nexus by ignoring annotate elements and existing programs should be able to read them. 3.2 Exporting tree data to BEAST Nexus format 3.2.1 Exporting/converting software output The treeio package provides write.beast to export treedata object as BEAST Nexus file (Bouckaert et al. 2014). With treeio, it is easy to convert software output to BEAST format if the output can be parsed by treeio. For example, we can convert NHX file to BEAST file and use NHX tags to color the tree using FigTree7 or convert CODEML output and use dN/dS, dN or dS to color the tree in FigTree. nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) # write.beast(nhx, file = &quot;phyldog.tree&quot;) write.beast(nhx) #NEXUS [R-package treeio, Fri Jan 11 16:29:09 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;Ev=S,S=58,ND=0]:0.0682841,(2[&amp;Ev=S,S=69,ND=1]:0.0193941,3[&amp;Ev=S,S=70,ND=2]:0.0121378)[&amp;Ev=S,S=60,ND=3]:0.0217782)[&amp;Ev=S,S=36,ND=4]:0.0607598,((4[&amp;Ev=S,S=31,ND=9]:0.11832,(((5[&amp;Ev=S,S=37,ND=10]:0.0144549,6[&amp;Ev=S,S=38,ND=11]:0.0149723)[&amp;Ev=S,S=33,ND=12]:0.0925388,7[&amp;Ev=S,S=61,ND=13]:0.077429)[&amp;Ev=S,S=24,ND=14]:0.0274637,(8[&amp;Ev=S,S=52,ND=15]:0.0761163,((9[&amp;Ev=S,S=53,ND=16]:0.0906068,10[&amp;Ev=S,S=54,ND=17]:1e-06)[&amp;Ev=S,S=45,ND=18]:1e-06,((11[&amp;Ev=S,S=65,ND=19]:0.120851,12[&amp;Ev=S,S=71,ND=20]:0.133939)[&amp;Ev=S,S=56,ND=21]:1e-06,13[&amp;Ev=S,S=64,ND=22]:0.0693814)[&amp;Ev=S,S=46,ND=23]:1e-06)[&amp;Ev=S,S=40,ND=24]:0.0333823)[&amp;Ev=S,S=35,ND=25]:1e-06)[&amp;Ev=D,S=24,ND=26]:0.0431861)[&amp;Ev=S,S=19,ND=27]:1e-06,14[&amp;Ev=S,S=26,ND=28]:0.22283)[&amp;Ev=S,S=17,ND=29]:0.0292362)[&amp;Ev=D,S=17,ND=8]:0.185603,(15[&amp;Ev=S,S=16,ND=5]:0.0621782,16[&amp;Ev=S,S=15,ND=6]:0.332505)[&amp;Ev=S,S=12,ND=7]:0.185603)[&amp;Ev=S,S=9,ND=30]; END; mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) ml &lt;- read.codeml_mlc(mlcfile) # write.beast(ml, file = &quot;codeml.tree&quot;) write.beast(ml) #NEXUS [R-package treeio, Fri Jan 11 16:29:09 2019] BEGIN TAXA; DIMENSIONS NTAX = 15; TAXLABELS A B C D E F G H I J K L M N O ; END; BEGIN TREES; TRANSLATE 1 A, 2 B, 3 C, 4 D, 5 E, 6 F, 7 G, 8 H, 9 I, 10 J, 11 K, 12 L, 13 M, 14 N, 15 O ; TREE * UNTITLED = [&amp;U] (11[&amp;t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0224,dN=0.002,dS=0.0878,N_x_dN=3,S_x_dS=55.6]:0.081785,14[&amp;t=0.062,N=1514.9,S=633.1,dN_vs_dS=0.0095,dN=7e-04,dS=0.0689,N_x_dN=1,S_x_dS=43.6]:0.062341,(4[&amp;t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0385,dN=0.0033,dS=0.0849,N_x_dN=5,S_x_dS=53.8]:0.082021,(12[&amp;t=0.006,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0062,N_x_dN=0,S_x_dS=3.9]:0.005508,(10[&amp;t=0.014,N=1514.9,S=633.1,dN_vs_dS=0.0457,dN=7e-04,dS=0.0143,N_x_dN=1,S_x_dS=9]:0.013996,(7[&amp;t=0.046,N=1514.9,S=633.1,dN_vs_dS=0.1621,dN=0.006,dS=0.0373,N_x_dN=9.2,S_x_dS=23.6]:0.045746,((3[&amp;t=0.028,N=1514.9,S=633.1,dN_vs_dS=0.0461,dN=0.0013,dS=0.0282,N_x_dN=2,S_x_dS=17.9]:0.02773,(5[&amp;t=0.031,N=1514.9,S=633.1,dN_vs_dS=0.0641,dN=0.002,dS=0.0305,N_x_dN=3,S_x_dS=19.3]:0.031104,15[&amp;t=0.048,N=1514.9,S=633.1,dN_vs_dS=0.0538,dN=0.0026,dS=0.0485,N_x_dN=4,S_x_dS=30.7]:0.048389)23[&amp;t=0.008,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0094,N_x_dN=0,S_x_dS=6]:0.008328)22[&amp;t=0.016,N=1514.9,S=633.1,dN_vs_dS=0.0395,dN=7e-04,dS=0.0165,N_x_dN=1,S_x_dS=10.4]:0.015959,(8[&amp;t=0.021,N=1514.9,S=633.1,dN_vs_dS=0.1028,dN=0.002,dS=0.0191,N_x_dN=3,S_x_dS=12.1]:0.021007,(9[&amp;t=0.015,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0167,N_x_dN=0,S_x_dS=10.6]:0.014739,(2[&amp;t=0.032,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0358,N_x_dN=0,S_x_dS=22.7]:0.031643,(1[&amp;t=0.01,N=1514.9,S=633.1,dN_vs_dS=0.0646,dN=7e-04,dS=0.0101,N_x_dN=1,S_x_dS=6.4]:0.01034,(6[&amp;t=0.007,N=1514.9,S=633.1,dN_vs_dS=0.298,dN=0.0013,dS=0.0044,N_x_dN=2,S_x_dS=2.8]:0.006649,13[&amp;t=0.009,N=1514.9,S=633.1,dN_vs_dS=0.0738,dN=7e-04,dS=0.0088,N_x_dN=1,S_x_dS=5.6]:0.009195)28[&amp;t=0.028,N=1514.9,S=633.1,dN_vs_dS=0.0453,dN=0.0013,dS=0.0289,N_x_dN=2,S_x_dS=18.3]:0.028303)27[&amp;t=0.008,N=1514.9,S=633.1,dN_vs_dS=0.0863,dN=7e-04,dS=0.0076,N_x_dN=1,S_x_dS=4.8]:0.008072)26[&amp;t=0.003,N=1514.9,S=633.1,dN_vs_dS=1.5591,dN=0.0013,dS=8e-04,N_x_dN=2,S_x_dS=0.5]:0.0035)25[&amp;t=0.02,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.023,N_x_dN=0,S_x_dS=14.6]:0.020359)24[&amp;t=0.001,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=6e-04,N_x_dN=0,S_x_dS=0.4]:0.000555)21[&amp;t=0.024,N=1514.9,S=633.1,dN_vs_dS=0.0549,dN=0.0013,dS=0.0237,N_x_dN=2,S_x_dS=15]:0.023675)20[&amp;t=0.046,N=1514.9,S=633.1,dN_vs_dS=0.0419,dN=0.002,dS=0.047,N_x_dN=3,S_x_dS=29.8]:0.045745)19[&amp;t=0.015,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0166,N_x_dN=0,S_x_dS=10.5]:0.014684)18[&amp;t=0.059,N=1514.9,S=633.1,dN_vs_dS=0.0964,dN=0.0053,dS=0.0545,N_x_dN=8,S_x_dS=34.5]:0.059308)17[&amp;t=0.232,N=1514.9,S=633.1,dN_vs_dS=0.0129,dN=0.0033,dS=0.2541,N_x_dN=5,S_x_dS=160.9]:0.231628)16; END; 3.2.2 Combining tree with external data Using the utilities provided by treeio, it is easy to link external data onto the corresponding phylogeny. The write.beast function enable users to combine the tree with external data to a single tree file. phylo &lt;- as.phylo(nhx) ## print the newick text write.tree(phylo) [1] &quot;(((Prayidae_D27SS7@2825365:0.0682841,(Kephyes_ovata@2606431:0.0193941,Chuniphyes_multidentata@1277217:0.0121378):0.0217782):0.0607598,((Apolemia_sp_@1353964:0.11832,(((Bargmannia_amoena@263997:0.0144549,Bargmannia_elongata@946788:0.0149723):0.0925388,Physonect_sp_@2066767:0.077429):0.0274637,(Stephalia_dilata@2960089:0.0761163,((Frillagalma_vityazi@1155031:0.0906068,Resomia_ornicephala@3111757:1e-06):1e-06,((Lychnagalma_utricularia@2253871:0.120851,Nanomia_bijuga@717864:0.133939):1e-06,Cordagalma_sp_@1525873:0.0693814):1e-06):0.0333823):1e-06):0.0431861):1e-06,Rhizophysa_filiformis@3073669:0.22283):0.0292362):0.185603,(Hydra_magnipapillata@52244:0.0621782,Ectopleura_larynx@3556167:0.332505):0.185603);&quot; N &lt;- Nnode2(phylo) fake_data &lt;- data_frame(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N)) fake_tree &lt;- treedata(phylo = phylo, data = fake_data) write.beast(fake_tree) #NEXUS [R-package treeio, Fri Jan 11 16:29:09 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;fake_trait=0.342768063622751,another_trait=0.509706555865705]:0.0682841,(2[&amp;fake_trait=1.572425399937,another_trait=0.920411841711029]:0.0193941,3[&amp;fake_trait=-0.746734743476614,another_trait=0.232821522746235]:0.0121378)[&amp;fake_trait=0.0987336130158627,another_trait=0.972914730897173]:0.0217782)[&amp;fake_trait=-0.867785443410887,another_trait=0.912789073772728]:0.0607598,((4[&amp;fake_trait=0.306649825246939,another_trait=0.19498902070336]:0.11832,(((5[&amp;fake_trait=-1.43048583788207,another_trait=0.152485728962347]:0.0144549,6[&amp;fake_trait=1.19442654297192,another_trait=0.165339544648305]:0.0149723)[&amp;fake_trait=0.297461853709007,another_trait=0.491289855912328]:0.0925388,7[&amp;fake_trait=-0.48206805621439,another_trait=0.367003423627466]:0.077429)[&amp;fake_trait=-0.930624939886141,another_trait=0.0285950915422291]:0.0274637,(8[&amp;fake_trait=1.3178623525853,another_trait=0.0858710501343012]:0.0761163,((9[&amp;fake_trait=-1.12983156850783,another_trait=0.866551321465522]:0.0906068,10[&amp;fake_trait=-0.926351407658812,another_trait=0.64708753535524]:1e-06)[&amp;fake_trait=1.94180284168099,another_trait=0.000483432319015265]:1e-06,((11[&amp;fake_trait=0.140709408058648,another_trait=0.51965602254495]:0.120851,12[&amp;fake_trait=-0.852232546447704,another_trait=0.543282775906846]:0.133939)[&amp;fake_trait=-0.221588783956122,another_trait=0.0482392930425704]:1e-06,13[&amp;fake_trait=1.903397182997,another_trait=0.837357287295163]:0.0693814)[&amp;fake_trait=-0.277956161863404,another_trait=0.152582261711359]:1e-06)[&amp;fake_trait=-1.0275346908299,another_trait=0.0555235911160707]:0.0333823)[&amp;fake_trait=3.13727710080761,another_trait=0.589515386614949]:1e-06)[&amp;fake_trait=0.589431905472849,another_trait=0.578338606283069]:0.0431861)[&amp;fake_trait=0.2410894403405,another_trait=0.192641460802406]:1e-06,14[&amp;fake_trait=-1.64818594113233,another_trait=0.126816635020077]:0.22283)[&amp;fake_trait=-0.683174373112094,another_trait=0.0565932868048549]:0.0292362)[&amp;fake_trait=0.636665628427795,another_trait=0.17444620328024]:0.185603,(15[&amp;fake_trait=0.759624769405575,another_trait=0.820879744598642]:0.0621782,16[&amp;fake_trait=0.0622908714051728,another_trait=0.213562297867611]:0.332505)[&amp;fake_trait=-1.05954514549066,another_trait=0.942036179127172]:0.185603)[&amp;fake_trait=-0.389031191481345,another_trait=0.886173036182299]; END; 3.2.3 Merging tree data from different sources Not only Newick tree text can be combined with associated data, but also tree data obtained from software output can be combined with external data, as well as different tree objects can be merged together. For details, please refer to the Importer vignette. ## combine tree object with data tree_with_data &lt;- full_join(nhx, fake_data, by = &quot;node&quot;) tree_with_data ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. ## merge two tree object tree2 &lt;- merge_tree(nhx, fake_tree) tree2 ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. identical(tree_with_data, tree2) ## [1] TRUE After merging data from different sources, the tree with the associated data can be exported into a single file. write.beast(tree2) #NEXUS [R-package treeio, Fri Jan 11 16:29:09 2019] BEGIN TAXA; DIMENSIONS NTAX = 16; TAXLABELS Prayidae_D27SS7@2825365 Kephyes_ovata@2606431 Chuniphyes_multidentata@1277217 Apolemia_sp_@1353964 Bargmannia_amoena@263997 Bargmannia_elongata@946788 Physonect_sp_@2066767 Stephalia_dilata@2960089 Frillagalma_vityazi@1155031 Resomia_ornicephala@3111757 Lychnagalma_utricularia@2253871 Nanomia_bijuga@717864 Cordagalma_sp_@1525873 Rhizophysa_filiformis@3073669 Hydra_magnipapillata@52244 Ectopleura_larynx@3556167 ; END; BEGIN TREES; TRANSLATE 1 Prayidae_D27SS7@2825365, 2 Kephyes_ovata@2606431, 3 Chuniphyes_multidentata@1277217, 4 Apolemia_sp_@1353964, 5 Bargmannia_amoena@263997, 6 Bargmannia_elongata@946788, 7 Physonect_sp_@2066767, 8 Stephalia_dilata@2960089, 9 Frillagalma_vityazi@1155031, 10 Resomia_ornicephala@3111757, 11 Lychnagalma_utricularia@2253871, 12 Nanomia_bijuga@717864, 13 Cordagalma_sp_@1525873, 14 Rhizophysa_filiformis@3073669, 15 Hydra_magnipapillata@52244, 16 Ectopleura_larynx@3556167 ; TREE * UNTITLED = [&amp;R] (((1[&amp;Ev=S,S=58,ND=0,fake_trait=0.342768063622751,another_trait=0.509706555865705]:0.0682841,(2[&amp;Ev=S,S=69,ND=1,fake_trait=1.572425399937,another_trait=0.920411841711029]:0.0193941,3[&amp;Ev=S,S=70,ND=2,fake_trait=-0.746734743476614,another_trait=0.232821522746235]:0.0121378)[&amp;Ev=S,S=60,ND=3,fake_trait=0.0987336130158627,another_trait=0.972914730897173]:0.0217782)[&amp;Ev=S,S=36,ND=4,fake_trait=-0.867785443410887,another_trait=0.912789073772728]:0.0607598,((4[&amp;Ev=S,S=31,ND=9,fake_trait=0.306649825246939,another_trait=0.19498902070336]:0.11832,(((5[&amp;Ev=S,S=37,ND=10,fake_trait=-1.43048583788207,another_trait=0.152485728962347]:0.0144549,6[&amp;Ev=S,S=38,ND=11,fake_trait=1.19442654297192,another_trait=0.165339544648305]:0.0149723)[&amp;Ev=S,S=33,ND=12,fake_trait=0.297461853709007,another_trait=0.491289855912328]:0.0925388,7[&amp;Ev=S,S=61,ND=13,fake_trait=-0.48206805621439,another_trait=0.367003423627466]:0.077429)[&amp;Ev=S,S=24,ND=14,fake_trait=-0.930624939886141,another_trait=0.0285950915422291]:0.0274637,(8[&amp;Ev=S,S=52,ND=15,fake_trait=1.3178623525853,another_trait=0.0858710501343012]:0.0761163,((9[&amp;Ev=S,S=53,ND=16,fake_trait=-1.12983156850783,another_trait=0.866551321465522]:0.0906068,10[&amp;Ev=S,S=54,ND=17,fake_trait=-0.926351407658812,another_trait=0.64708753535524]:1e-06)[&amp;Ev=S,S=45,ND=18,fake_trait=1.94180284168099,another_trait=0.000483432319015265]:1e-06,((11[&amp;Ev=S,S=65,ND=19,fake_trait=0.140709408058648,another_trait=0.51965602254495]:0.120851,12[&amp;Ev=S,S=71,ND=20,fake_trait=-0.852232546447704,another_trait=0.543282775906846]:0.133939)[&amp;Ev=S,S=56,ND=21,fake_trait=-0.221588783956122,another_trait=0.0482392930425704]:1e-06,13[&amp;Ev=S,S=64,ND=22,fake_trait=1.903397182997,another_trait=0.837357287295163]:0.0693814)[&amp;Ev=S,S=46,ND=23,fake_trait=-0.277956161863404,another_trait=0.152582261711359]:1e-06)[&amp;Ev=S,S=40,ND=24,fake_trait=-1.0275346908299,another_trait=0.0555235911160707]:0.0333823)[&amp;Ev=S,S=35,ND=25,fake_trait=3.13727710080761,another_trait=0.589515386614949]:1e-06)[&amp;Ev=D,S=24,ND=26,fake_trait=0.589431905472849,another_trait=0.578338606283069]:0.0431861)[&amp;Ev=S,S=19,ND=27,fake_trait=0.2410894403405,another_trait=0.192641460802406]:1e-06,14[&amp;Ev=S,S=26,ND=28,fake_trait=-1.64818594113233,another_trait=0.126816635020077]:0.22283)[&amp;Ev=S,S=17,ND=29,fake_trait=-0.683174373112094,another_trait=0.0565932868048549]:0.0292362)[&amp;Ev=D,S=17,ND=8,fake_trait=0.636665628427795,another_trait=0.17444620328024]:0.185603,(15[&amp;Ev=S,S=16,ND=5,fake_trait=0.759624769405575,another_trait=0.820879744598642]:0.0621782,16[&amp;Ev=S,S=15,ND=6,fake_trait=0.0622908714051728,another_trait=0.213562297867611]:0.332505)[&amp;Ev=S,S=12,ND=7,fake_trait=-1.05954514549066,another_trait=0.942036179127172]:0.185603)[&amp;Ev=S,S=9,ND=30,fake_trait=-0.389031191481345,another_trait=0.886173036182299]; END; The output BEAST Nexus file can be imported into R using the read.beast function and all the associated data can be used to annotate the tree using ggtree (Yu et al. 2017). outfile &lt;- tempfile(fileext = &quot;.tree&quot;) write.beast(tree2, file = outfile) read.beast(outfile) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:\\Users\\YGC\\AppData\\Local\\Temp\\RtmpGEUTIm\\file45454d176a1.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;another_trait&#39;, &#39;Ev&#39;, &#39;fake_trait&#39;, &#39;ND&#39;, &#39;S&#39;. 3.3 Exporting tree data to jtree format The treeio package provides write.beast to export treedata to BEAST Nexus file. This is quite useful to convert file format, combine tree with data and merging tree data from different sources as we demonstrated in Exporting tree data to BEAST Nexus format session. The treeio package also supplies read.beast function to parse output file of write.beast. Although with treeio, the R community has the ability to manipulate BEAST Nexus format and process tree data, there is still lacking library/package for parsing BEAST file in other programming language. JSON (JavaScript Object Notation)8 is a lightweight data-interchange format and widely supported in almost all modern programming languages. To make it easy to import tree with data in other programming languages, treeio supports exporting tree with data in jtree format, which is JSON-based and can be easy to parse using any languages that supports JSON. write.jtree(tree2) { &quot;tree&quot;: &quot;(((Prayidae_D27SS7@2825365:0.0682841{1},(Kephyes_ovata@2606431:0.0193941{2},Chuniphyes_multidentata@1277217:0.0121378{3}):0.0217782{20}):0.0607598{19},((Apolemia_sp_@1353964:0.11832{4},(((Bargmannia_amoena@263997:0.0144549{5},Bargmannia_elongata@946788:0.0149723{6}):0.0925388{25},Physonect_sp_@2066767:0.077429{7}):0.0274637{24},(Stephalia_dilata@2960089:0.0761163{8},((Frillagalma_vityazi@1155031:0.0906068{9},Resomia_ornicephala@3111757:1{10}e-06):1{28}e-06,((Lychnagalma_utricularia@2253871:0.120851{11},Nanomia_bijuga@717864:0.133939{12}):1{30}e-06,Cordagalma_sp_@1525873:0.0693814{13}):1{29}e-06):0.0333823{27}):1{26}e-06):0.0431861{23}):1{22}e-06,Rhizophysa_filiformis@3073669:0.22283{14}):0.0292362{21}):0.185603{18},(Hydra_magnipapillata@52244:0.0621782{15},Ectopleura_larynx@3556167:0.332505{16}):0.185603{31}){17};&quot;, &quot;data&quot;:[ { &quot;edge_num&quot;: 1, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;58&quot;, &quot;ND&quot;: 0, &quot;fake_trait&quot;: 0.3428, &quot;another_trait&quot;: 0.5097 }, { &quot;edge_num&quot;: 2, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;69&quot;, &quot;ND&quot;: 1, &quot;fake_trait&quot;: 1.5724, &quot;another_trait&quot;: 0.9204 }, { &quot;edge_num&quot;: 3, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;70&quot;, &quot;ND&quot;: 2, &quot;fake_trait&quot;: -0.7467, &quot;another_trait&quot;: 0.2328 }, { &quot;edge_num&quot;: 4, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;31&quot;, &quot;ND&quot;: 9, &quot;fake_trait&quot;: 0.3066, &quot;another_trait&quot;: 0.195 }, { &quot;edge_num&quot;: 5, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;37&quot;, &quot;ND&quot;: 10, &quot;fake_trait&quot;: -1.4305, &quot;another_trait&quot;: 0.1525 }, { &quot;edge_num&quot;: 6, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;38&quot;, &quot;ND&quot;: 11, &quot;fake_trait&quot;: 1.1944, &quot;another_trait&quot;: 0.1653 }, { &quot;edge_num&quot;: 7, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;61&quot;, &quot;ND&quot;: 13, &quot;fake_trait&quot;: -0.4821, &quot;another_trait&quot;: 0.367 }, { &quot;edge_num&quot;: 8, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;52&quot;, &quot;ND&quot;: 15, &quot;fake_trait&quot;: 1.3179, &quot;another_trait&quot;: 0.0859 }, { &quot;edge_num&quot;: 9, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;53&quot;, &quot;ND&quot;: 16, &quot;fake_trait&quot;: -1.1298, &quot;another_trait&quot;: 0.8666 }, { &quot;edge_num&quot;: 10, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;54&quot;, &quot;ND&quot;: 17, &quot;fake_trait&quot;: -0.9264, &quot;another_trait&quot;: 0.6471 }, { &quot;edge_num&quot;: 11, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;65&quot;, &quot;ND&quot;: 19, &quot;fake_trait&quot;: 0.1407, &quot;another_trait&quot;: 0.5197 }, { &quot;edge_num&quot;: 12, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;71&quot;, &quot;ND&quot;: 20, &quot;fake_trait&quot;: -0.8522, &quot;another_trait&quot;: 0.5433 }, { &quot;edge_num&quot;: 13, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;64&quot;, &quot;ND&quot;: 22, &quot;fake_trait&quot;: 1.9034, &quot;another_trait&quot;: 0.8374 }, { &quot;edge_num&quot;: 14, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;26&quot;, &quot;ND&quot;: 28, &quot;fake_trait&quot;: -1.6482, &quot;another_trait&quot;: 0.1268 }, { &quot;edge_num&quot;: 15, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;16&quot;, &quot;ND&quot;: 5, &quot;fake_trait&quot;: 0.7596, &quot;another_trait&quot;: 0.8209 }, { &quot;edge_num&quot;: 16, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;15&quot;, &quot;ND&quot;: 6, &quot;fake_trait&quot;: 0.0623, &quot;another_trait&quot;: 0.2136 }, { &quot;edge_num&quot;: 17, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;9&quot;, &quot;ND&quot;: 30, &quot;fake_trait&quot;: -0.389, &quot;another_trait&quot;: 0.8862 }, { &quot;edge_num&quot;: 18, &quot;Ev&quot;: &quot;D&quot;, &quot;S&quot;: &quot;17&quot;, &quot;ND&quot;: 8, &quot;fake_trait&quot;: 0.6367, &quot;another_trait&quot;: 0.1744 }, { &quot;edge_num&quot;: 19, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;36&quot;, &quot;ND&quot;: 4, &quot;fake_trait&quot;: -0.8678, &quot;another_trait&quot;: 0.9128 }, { &quot;edge_num&quot;: 20, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;60&quot;, &quot;ND&quot;: 3, &quot;fake_trait&quot;: 0.0987, &quot;another_trait&quot;: 0.9729 }, { &quot;edge_num&quot;: 21, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;17&quot;, &quot;ND&quot;: 29, &quot;fake_trait&quot;: -0.6832, &quot;another_trait&quot;: 0.0566 }, { &quot;edge_num&quot;: 22, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;19&quot;, &quot;ND&quot;: 27, &quot;fake_trait&quot;: 0.2411, &quot;another_trait&quot;: 0.1926 }, { &quot;edge_num&quot;: 23, &quot;Ev&quot;: &quot;D&quot;, &quot;S&quot;: &quot;24&quot;, &quot;ND&quot;: 26, &quot;fake_trait&quot;: 0.5894, &quot;another_trait&quot;: 0.5783 }, { &quot;edge_num&quot;: 24, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;24&quot;, &quot;ND&quot;: 14, &quot;fake_trait&quot;: -0.9306, &quot;another_trait&quot;: 0.0286 }, { &quot;edge_num&quot;: 25, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;33&quot;, &quot;ND&quot;: 12, &quot;fake_trait&quot;: 0.2975, &quot;another_trait&quot;: 0.4913 }, { &quot;edge_num&quot;: 26, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;35&quot;, &quot;ND&quot;: 25, &quot;fake_trait&quot;: 3.1373, &quot;another_trait&quot;: 0.5895 }, { &quot;edge_num&quot;: 27, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;40&quot;, &quot;ND&quot;: 24, &quot;fake_trait&quot;: -1.0275, &quot;another_trait&quot;: 0.0555 }, { &quot;edge_num&quot;: 28, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;45&quot;, &quot;ND&quot;: 18, &quot;fake_trait&quot;: 1.9418, &quot;another_trait&quot;: 0.0005 }, { &quot;edge_num&quot;: 29, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;46&quot;, &quot;ND&quot;: 23, &quot;fake_trait&quot;: -0.278, &quot;another_trait&quot;: 0.1526 }, { &quot;edge_num&quot;: 30, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;56&quot;, &quot;ND&quot;: 21, &quot;fake_trait&quot;: -0.2216, &quot;another_trait&quot;: 0.0482 }, { &quot;edge_num&quot;: 31, &quot;Ev&quot;: &quot;S&quot;, &quot;S&quot;: &quot;12&quot;, &quot;ND&quot;: 7, &quot;fake_trait&quot;: -1.0595, &quot;another_trait&quot;: 0.942 } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;R-package treeio&quot;, &quot;data&quot;: &quot;Fri Jan 11 16:29:09 2019&quot;} } The jtree format is based on JSON and can be parsed using JSON parser. jtree_file &lt;- tempfile(fileext = &#39;.jtree&#39;) write.jtree(tree2, file = jtree_file) jsonlite::fromJSON(jtree_file) $tree [1] &quot;(((Prayidae_D27SS7@2825365:0.0682841{1},(Kephyes_ovata@2606431:0.0193941{2},Chuniphyes_multidentata@1277217:0.0121378{3}):0.0217782{20}):0.0607598{19},((Apolemia_sp_@1353964:0.11832{4},(((Bargmannia_amoena@263997:0.0144549{5},Bargmannia_elongata@946788:0.0149723{6}):0.0925388{25},Physonect_sp_@2066767:0.077429{7}):0.0274637{24},(Stephalia_dilata@2960089:0.0761163{8},((Frillagalma_vityazi@1155031:0.0906068{9},Resomia_ornicephala@3111757:1{10}e-06):1{28}e-06,((Lychnagalma_utricularia@2253871:0.120851{11},Nanomia_bijuga@717864:0.133939{12}):1{30}e-06,Cordagalma_sp_@1525873:0.0693814{13}):1{29}e-06):0.0333823{27}):1{26}e-06):0.0431861{23}):1{22}e-06,Rhizophysa_filiformis@3073669:0.22283{14}):0.0292362{21}):0.185603{18},(Hydra_magnipapillata@52244:0.0621782{15},Ectopleura_larynx@3556167:0.332505{16}):0.185603{31}){17};&quot; $data edge_num Ev S ND fake_trait another_trait 1 1 S 58 0 0.3428 0.5097 2 2 S 69 1 1.5724 0.9204 3 3 S 70 2 -0.7467 0.2328 4 4 S 31 9 0.3066 0.1950 5 5 S 37 10 -1.4305 0.1525 6 6 S 38 11 1.1944 0.1653 7 7 S 61 13 -0.4821 0.3670 8 8 S 52 15 1.3179 0.0859 9 9 S 53 16 -1.1298 0.8666 10 10 S 54 17 -0.9264 0.6471 11 11 S 65 19 0.1407 0.5197 12 12 S 71 20 -0.8522 0.5433 13 13 S 64 22 1.9034 0.8374 14 14 S 26 28 -1.6482 0.1268 15 15 S 16 5 0.7596 0.8209 16 16 S 15 6 0.0623 0.2136 17 17 S 9 30 -0.3890 0.8862 18 18 D 17 8 0.6367 0.1744 19 19 S 36 4 -0.8678 0.9128 20 20 S 60 3 0.0987 0.9729 21 21 S 17 29 -0.6832 0.0566 22 22 S 19 27 0.2411 0.1926 23 23 D 24 26 0.5894 0.5783 24 24 S 24 14 -0.9306 0.0286 25 25 S 33 12 0.2975 0.4913 26 26 S 35 25 3.1373 0.5895 27 27 S 40 24 -1.0275 0.0555 28 28 S 45 18 1.9418 0.0005 29 29 S 46 23 -0.2780 0.1526 30 30 S 56 21 -0.2216 0.0482 31 31 S 12 7 -1.0595 0.9420 $metadata $metadata$info [1] &quot;R-package treeio&quot; $metadata$data [1] &quot;Fri Jan 11 16:29:09 2019&quot; The jtree file can be directly imported as a treedata object using read.jtree provided also in treeio package. read.jtree(jtree_file) ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:\\Users\\YGC\\AppData\\Local\\Temp\\RtmpGEUTIm\\file4541b032d11.jtree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, Chuniphyes_multidentata@1277217, Apolemia_sp_@1353964, Bargmannia_amoena@263997, Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;S&#39;, &#39;ND&#39;, &#39;fake_trait&#39;, &#39;another_trait&#39;. References "],
["chapter4.html", "Chapter 4 Phylogenetic Tree Visualization 4.1 Viewing a phylogenetic tree with ggtree 4.2 Layout 4.3 Displaying tree scale (evolution distance) 4.4 Displaying nodes/tips 4.5 Displaying labels 4.6 Update tree view with a new tree 4.7 Theme 4.8 Visualize a list of trees 4.9 Rescale tree 4.10 Zoom on a portion of tree 4.11 Color tree", " Chapter 4 Phylogenetic Tree Visualization To view a phylogenetic tree, we first need to parse the tree file into R. The ggtree (Yu et al. 2017) package supports many file formats via the treeio package, including output files of commonly used software packages in evolutionary biology. For more details, plase refer to the treeio vignette. library(&quot;treeio&quot;) library(&quot;ggtree&quot;) nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) 4.1 Viewing a phylogenetic tree with ggtree The ggtree package extends ggplot2 (Wickham 2009) package to support viewing phylogenetic tree. It implements geom_tree layer for displaying phylogenetic tree, as shown below: ggplot(tree, aes(x, y)) + geom_tree() + theme_tree() The function, ggtree, was implemented as a short cut to visualize a tree, and it works exactly the same as shown above. ggtree takes all the advantages of ggplot2. For example, we can change the color, size and type of the lines as we do with ggplot2. ggtree(tree, color=&quot;firebrick&quot;, size=1, linetype=&quot;dotted&quot;) By default, the tree is viewed in ladderize form, user can set the parameter ladderize = FALSE to disable it. ggtree(tree, ladderize=FALSE) The branch.length is used to scale the edge, user can set the parameter branch.length = “none” to only view the tree topology (cladogram) or other numerical variable to scale the tree (e.g. dN/dS, see also in Tree Annotation vignette). ggtree(tree, branch.length=&quot;none&quot;) 4.2 Layout Currently, ggtree supports several layouts, including: rectangular (by default) slanted circular fan for phylogram (by default) and cladogram if user explicitly setting branch.length=‘none’. Unrooted (equal angle and daylight methods), time-scaled and 2-dimensional layouts are also supported. 4.2.1 Phylogram and Cladogram library(ggtree) set.seed(2017-02-16) tr &lt;- rtree(50) ggtree(tr) ggtree(tr, layout=&quot;slanted&quot;) ggtree(tr, layout=&quot;circular&quot;) ggtree(tr, layout=&quot;fan&quot;, open.angle=120) ggtree(tr, layout=&quot;equal_angle&quot;) ggtree(tr, layout=&quot;daylight&quot;) ggtree(tr, branch.length=&#39;none&#39;) ggtree(tr, branch.length=&#39;none&#39;, layout=&#39;circular&#39;) ggtree(tr, layout=&quot;daylight&quot;, branch.length=&#39;none&#39;) There are also other possible layouts that can be drawn by modifying scales/coordination, for examples, reverse label of time scale, repropotion circular/fan tree, etc.. ggtree(tr) + scale_x_reverse() ggtree(tr) + coord_flip() ggtree(tr) + scale_x_reverse() + coord_flip() print(ggtree(tr), newpage=TRUE, vp=grid::viewport(angle=-30, width=.9, height=.9)) ggtree(tr, layout=&#39;slanted&#39;) + coord_flip() ggtree(tr, layout=&#39;slanted&#39;, branch.length=&#39;none&#39;) + coord_flip() + scale_y_reverse() +scale_x_reverse() ggtree(tr, layout=&#39;circular&#39;) + xlim(-10, NA) ggtree(tr) + scale_x_reverse() + coord_polar(theta=&#39;y&#39;) ggtree(tr) + scale_x_reverse(limits=c(10, 0)) + coord_polar(theta=&#39;y&#39;) 4.2.2 Time-scaled tree A phylogenetic tree can be scaled by time (time-scaled tree) by specifying the parameter, mrsd (most recent sampling date). tree2d &lt;- read.beast(system.file(&quot;extdata&quot;, &quot;twoD.tree&quot;, package=&quot;treeio&quot;)) ggtree(tree2d, mrsd=&quot;2014-05-01&quot;) + theme_tree2() 4.2.3 Two dimensional tree ggtree implemented two dimensional tree. It accepts parameter yscale to scale the y-axis based on the selected tree attribute. The attribute should be numerical variable. If it is character/category variable, user should provides a name vector of mapping the variable to numeric by passing it to parameter yscale_mapping. ggtree(tree2d, mrsd=&quot;2014-05-01&quot;, yscale=&quot;NGS&quot;, yscale_mapping=c(N2=2, N3=3, N4=4, N5=5, N6=6, N7=7)) + theme_classic() + theme(axis.line.x=element_line(), axis.line.y=element_line()) + theme(panel.grid.major.x=element_line(color=&quot;grey20&quot;, linetype=&quot;dotted&quot;, size=.3), panel.grid.major.y=element_blank()) + scale_y_continuous(labels=paste0(&quot;N&quot;, 2:7)) In this example, the figure demonstrates the quantity of y increase along the trunk. User can highlight the trunk with different line size or color using the functions described in Tree Manipulation vignette. 4.3 Displaying tree scale (evolution distance) To show tree scale, user can use geom_treescale() layer. ggtree(tree) + geom_treescale() geom_treescale() supports the following parameters: x and y for tree scale position width for the length of the tree scale fontsize for the size of the text linesize for the size of the line offset for relative position of the line and the text color for color of the tree scale ggtree(tree) + geom_treescale(x=0, y=12, width=6, color=&#39;red&#39;) ggtree(tree) + geom_treescale(fontsize=8, linesize=2, offset=-1) We can also use theme_tree2() to display the tree scale by adding x axis. ggtree(tree) + theme_tree2() Tree scale is not restricted to evolution distance, ggtree can re-scale the tree with other numerical variable. More details can be found in the Tree Annotation vignette. 4.4 Displaying nodes/tips Showing all the internal nodes and tips in the tree can be done by adding a layer of points using geom_nodepoint, geom_tippoint or geom_point. ggtree(tree) + geom_point(aes(shape=isTip, color=isTip), size=3) p &lt;- ggtree(tree) + geom_nodepoint(color=&quot;#b5e521&quot;, alpha=1/4, size=10) p + geom_tippoint(color=&quot;#FDAC4F&quot;, shape=8, size=3) 4.5 Displaying labels Users can use geom_text or geom_label to display the node (if available) and tip labels simultaneously or geom_tiplab to only display tip labels: p + geom_tiplab(size=3, color=&quot;purple&quot;) geom_tiplab not only supports using text or label geom to display labels, it also supports image geom to label tip with image files. A corresponding geom, geom_nodelab is also provided for displaying node labels. For details of label nodes with images, please refer to the vignette, Annotating phylogenetic tree with images. For circular and unrooted layout, ggtree supports rotating node labels according to the angles of the branches. ggtree(tree, layout=&quot;circular&quot;) + geom_tiplab(aes(angle=angle), color=&#39;blue&#39;) To make it more readable for human eye, ggtree provides a geom_tiplab2 for circular layout (see post 1 and 2). ggtree(tree, layout=&quot;circular&quot;) + geom_tiplab2(color=&#39;blue&#39;) By default, the positions are based on the node positions, we can change them to based on the middle of the branch/edge. p + geom_tiplab(aes(x=branch), size=3, color=&quot;purple&quot;, vjust=-0.3) Based on the middle of branch is very useful when annotating transition from parent node to child node. 4.6 Update tree view with a new tree In previous example, we have a p object that stored the tree viewing of 13 tips and internal nodes highlighted with specific colored big dots. If users want to apply this pattern (we can imaging a more complex one) to a new tree, you don’t need to build the tree step by step. ggtree provides an operator, %&lt;%, for applying the visualization pattern to a new tree. For example, the pattern in the p object will be applied to a new tree with 50 tips as shown below: p %&lt;% rtree(50) 4.7 Theme theme_tree() defined a totally blank canvas, while theme_tree2() adds phylogenetic distance (via x-axis). These two themes all accept a parameter of bgcolor that defined the background color. Users can pass any theme components to the theme_tree() function to modify them. ggtree(rtree(30), color=&quot;red&quot;) + theme_tree(&quot;steelblue&quot;) ggtree(rtree(20), color=&quot;white&quot;) + theme_tree(&quot;black&quot;) 4.8 Visualize a list of trees ggtree supports multiPhylo object and a list of trees can be viewed simultaneously. trees &lt;- lapply(c(10, 20, 40), rtree) class(trees) &lt;- &quot;multiPhylo&quot; ggtree(trees) + facet_wrap(~.id, scale=&quot;free&quot;) + geom_tiplab() One hundred bootstrap trees can also be view simultaneously. btrees &lt;- read.tree(system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bootstrap.H3&quot;, package=&quot;treeio&quot;)) ggtree(btrees) + facet_wrap(~.id, ncol=10) Another way to view the bootstrap trees is to merge them together to form a density tree. We can add a layer of the best tree on the top of the density tree. p &lt;- ggtree(btrees, layout=&quot;rectangular&quot;, color=&quot;lightblue&quot;, alpha=.3) best_tree &lt;- read.tree(system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;)) df &lt;- fortify(best_tree, branch.length=&#39;none&#39;) p+geom_tree(data=df, color=&#39;firebrick&#39;) 4.9 Rescale tree Most of the phylogenetic trees are scaled by evolutionary distance (substitution/site). In ggtree, users can re-scale a phylogenetic tree by any numerical variable inferred by evolutionary analysis (e.g. dN/dS). library(&quot;treeio&quot;) beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) beast_tree ## &#39;treedata&#39; S4 object that stored information of ## &#39;C:/Users/YGC/Library/R/library/ggtree/examples/MCC_FluA_H3.tree&#39;. ## ## ...@ phylo: ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. p1 &lt;- ggtree(beast_tree, mrsd=&#39;2013-01-01&#39;) + theme_tree2() + ggtitle(&quot;Divergence time&quot;) p2 &lt;- ggtree(beast_tree, branch.length=&#39;rate&#39;) + theme_tree2() + ggtitle(&quot;Substitution rate&quot;) library(cowplot) plot_grid(p1, p2, ncol=2) mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc_tree &lt;- read.codeml_mlc(mlcfile) p1 &lt;- ggtree(mlc_tree) + theme_tree2() + ggtitle(&quot;nucleotide substitutions per codon&quot;) p2 &lt;- ggtree(mlc_tree, branch.length=&#39;dN_vs_dS&#39;) + theme_tree2() + ggtitle(&quot;dN/dS tree&quot;) plot_grid(p1, p2, ncol=2) In addition to specify branch.length in tree visualization, users can change branch length stored in tree object by using rescale_tree function. beast_tree2 &lt;- rescale_tree(beast_tree, branch.length=&#39;rate&#39;) ggtree(beast_tree2) + theme_tree2() 4.10 Zoom on a portion of tree ggtree provides gzoom function that similar to zoom function provided in ape. This function plots simultaneously a whole phylogenetic tree and a portion of it. It aims at exploring very large trees. library(&quot;ape&quot;) data(chiroptera) library(&quot;ggtree&quot;) gzoom(chiroptera, grep(&quot;Plecotus&quot;, chiroptera$tip.label)) Zoom in selected clade of a tree that was already annotated with ggtree is also supported. groupInfo &lt;- split(chiroptera$tip.label, gsub(&quot;_\\\\w+&quot;, &quot;&quot;, chiroptera$tip.label)) chiroptera &lt;- groupOTU(chiroptera, groupInfo) p &lt;- ggtree(chiroptera, aes(color=group)) + geom_tiplab() + xlim(NA, 23) gzoom(p, grep(&quot;Plecotus&quot;, chiroptera$tip.label), xmax_adjust=2) 4.11 Color tree In ggtree, coloring phylogenetic tree is easy, by using aes(color=VAR) to map the color of tree based on a specific variable (numeric and category are both supported). ggtree(beast_tree, aes(color=rate)) + scale_color_continuous(low=&#39;darkgreen&#39;, high=&#39;red&#39;) + theme(legend.position=&quot;right&quot;) User can use any feature (if available), including clade posterior and dN/dS etc., to scale the color of the tree. References "],
["phylogenetic-tree-annotation.html", "Chapter 5 Phylogenetic Tree Annotation 5.1 Annotate clades 5.2 Labelling associated taxa (Monophyletic, Polyphyletic or Paraphyletic) 5.3 Highlight clades 5.4 Taxa connection 5.5 Tree annotation with output from evolution software", " Chapter 5 Phylogenetic Tree Annotation 5.1 Annotate clades ggtree (Yu et al. 2017) implements geom_cladelabel layer to annotate a selected clade with a bar indicating the clade with a corresponding label. The geom_cladelabel layer accepts a selected internal node number. To get the internal node number, please refer to Tree Manipulation vignette. set.seed(2015-12-21) tree &lt;- rtree(30) p &lt;- ggtree(tree) + xlim(NA, 6) p + geom_cladelabel(node=45, label=&quot;test label&quot;) + geom_cladelabel(node=34, label=&quot;another clade&quot;) Users can set the parameter, align = TRUE, to align the clade label, and use the parameter, offset, to adjust the position. p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=TRUE, offset=.5) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=TRUE, offset=.5) Users can change the color of the clade label via the parameter color. p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=T, color=&#39;red&#39;) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, color=&#39;blue&#39;) Users can change the angle of the clade label text and relative position from text to bar via the parameter offset.text. p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=T, angle=270, hjust=&#39;center&#39;, offset.text=.5) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, angle=45) The size of the bar and text can be changed via the parameters barsize and fontsize respectively. p + geom_cladelabel(node=45, label=&quot;test label&quot;, align=T, angle=270, hjust=&#39;center&#39;, offset.text=.5, barsize=1.5) + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, angle=45, fontsize=8) Users can also use geom_label to label the text. p + geom_cladelabel(node=34, label=&quot;another clade&quot;, align=T, geom=&#39;label&#39;, fill=&#39;lightblue&#39;) 5.1.1 Annotate clades for unrooted tree ggtree provides geom_clade2 for labeling clades of unrooted layout trees. pg &lt;- ggtree(tree, layout=&quot;daylight&quot;) pg + geom_cladelabel2(node=45, label=&quot;test label&quot;, angle=10) + geom_cladelabel2(node=34, label=&quot;another clade&quot;, angle=305) 5.2 Labelling associated taxa (Monophyletic, Polyphyletic or Paraphyletic) geom_cladelabel is designed for labelling Monophyletic (Clade) while there are related taxa that are not form a clade. ggtree provides geom_strip to add a strip/bar to indicate the association with optional label (see the issue). nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) ggtree(tree) + geom_tiplab() + geom_strip(5, 7, barsize=2, color=&#39;red&#39;) + geom_strip(6, 12, barsize=2, color=&#39;blue&#39;) 5.3 Highlight clades ggtree implements geom_hilight layer, that accepts an internal node number and add a layer of rectangle to highlight the selected clade. ggtree(tree) + geom_hilight(node=21, fill=&quot;steelblue&quot;, alpha=.6) + geom_hilight(node=17, fill=&quot;darkgreen&quot;, alpha=.6) ggtree(tree, layout=&quot;circular&quot;) + geom_hilight(node=21, fill=&quot;steelblue&quot;, alpha=.6) + geom_hilight(node=23, fill=&quot;darkgreen&quot;, alpha=.6) Another way to highlight selected clades is setting the clades with different colors and/or line types as demonstrated in Tree Manipulation vignette. 5.3.1 Highlight balances In addition to geom_hilight, ggtree also implements geom_balance which is designed to highlight neighboring subclades of a given internal node. ggtree(tree) + geom_balance(node=16, fill=&#39;steelblue&#39;, color=&#39;white&#39;, alpha=0.6, extend=1) + geom_balance(node=19, fill=&#39;darkgreen&#39;, color=&#39;white&#39;, alpha=0.6, extend=1) 5.3.2 Highlight clades for unrooted tree ggtree provides geom_hilight_encircle to support highlight clades for unrooted layout trees. pg + geom_hilight_encircle(node=45) + geom_hilight_encircle(node=34, fill=&#39;darkgreen&#39;) 5.4 Taxa connection Some evolutionary events (e.g. reassortment, horizontal gene transfer) can be modeled by a simple tree. ggtree provides geom_taxalink layer that allows drawing straight or curved lines between any of two nodes in the tree, allow it to represent evolutionary events by connecting taxa. ggtree(tree) + geom_tiplab() + geom_taxalink(&#39;A&#39;, &#39;E&#39;) + geom_taxalink(&#39;F&#39;, &#39;K&#39;, color=&#39;red&#39;, arrow=grid::arrow(length=grid::unit(0.02, &quot;npc&quot;))) 5.5 Tree annotation with output from evolution software The treeio package implemented several parser functions to parse output from commonly used software in evolutionary biology. Here, we used BEAST (Bouckaert et al. 2014) output as an example. For details, please refer to the Importer vignette. file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) ggtree(beast, aes(color=rate)) + geom_range(range=&#39;length_0.95_HPD&#39;, color=&#39;red&#39;, alpha=.6, size=2) + geom_nodelab(aes(x=branch, label=round(posterior, 2)), vjust=-.5, size=3) + scale_color_continuous(low=&quot;darkgreen&quot;, high=&quot;red&quot;) + theme(legend.position=c(.1, .8)) References "],
["visual-exploration-of-phylogenetic-tree.html", "Chapter 6 Visual Exploration of Phylogenetic Tree 6.1 Internal node number 6.2 View Clade 6.3 Group Clades 6.4 Group OTUs 6.5 Collapse clade 6.6 Expand collapsed clade 6.7 Scale clade 6.8 Rotate clade 6.9 Flip clade 6.10 Open tree 6.11 Rotate tree 6.12 Interactive tree manipulation", " Chapter 6 Visual Exploration of Phylogenetic Tree 6.1 Internal node number Some of the functions in ggtree work with clade and accept a parameter of internal node number. To get the internal node number, user can use geom_text2 to display it: nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) ggtree(tree) + geom_text2(aes(subset=!isTip, label=node), hjust=-.3) + geom_tiplab() Another way to get the internal node number is using MRCA() function by providing a vector of taxa names. The function will return node number of input taxa’s most recent commond ancestor (MRCA). It works with tree and graphic object. MRCA(tree, &#39;A&#39;, &#39;E&#39;) ## [1] 17 MRCA(tree, &#39;H&#39;, &#39;G&#39;) ## [1] 21 p &lt;- ggtree(tree) MRCA(p, &#39;A&#39;, &#39;E&#39;) ## [1] 17 6.2 View Clade ggtree provides a function viewClade to visualize a clade of a phylogenetic tree. viewClade(p+geom_tiplab(), node=21) 6.3 Group Clades The ggtree package defined several functions to manipulate tree view. groupClade and groupOTU methods were designed for clustering clades or related OTUs. groupClade accepts an internal node or a vector of internal nodes to cluster clade/clades. Both groupClade and groupOTU work fine with tree and graphic object. tree &lt;- groupClade(tree, .node=21) ggtree(tree, aes(color=group, linetype=group)) The following command will produce the same figure. ggtree(read.tree(nwk)) %&gt;% groupClade(.node=21) + aes(color=group, linetype=group) With groupClade and groupOTU, it’s easy to highlight selected taxa and easy to select taxa to display related features. tree &lt;- groupClade(tree, .node=c(21, 17)) ggtree(tree, aes(color=group, linetype=group)) + geom_tiplab(aes(subset=(group==2))) 6.4 Group OTUs groupOTU accepts a vector of OTUs (taxa name) or a list of OTUs. groupOTU will trace back from OTUs to their most recent common ancestor and cluster them together. Related OTUs are not necessarily within a clade, they can be monophyletic (clade), polyphyletic or paraphyletic. tree &lt;- groupOTU(tree, .node=c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;)) ggtree(tree, aes(color=group)) + geom_tiplab() groupOTU can also input a list of tip groups. cls &lt;- list(c1=c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), c2=c(&quot;F&quot;, &quot;G&quot;, &quot;H&quot;), c3=c(&quot;L&quot;, &quot;K&quot;, &quot;I&quot;, &quot;J&quot;), c4=&quot;M&quot;) tree &lt;- groupOTU(tree, cls) library(&quot;colorspace&quot;) ggtree(tree, aes(color=group, linetype=group)) + geom_tiplab() + scale_color_manual(values=c(&quot;black&quot;, rainbow_hcl(4))) + theme(legend.position=&quot;right&quot;) groupOTU also works with graphic object. p &lt;- ggtree(tree) groupOTU(p, LETTERS[1:5]) + aes(color=group) + geom_tiplab() + scale_color_manual(values=c(&quot;black&quot;, &quot;firebrick&quot;)) The following example use groupOTU to display taxa classification. library(&quot;ape&quot;) data(chiroptera) groupInfo &lt;- split(chiroptera$tip.label, gsub(&quot;_\\\\w+&quot;, &quot;&quot;, chiroptera$tip.label)) chiroptera &lt;- groupOTU(chiroptera, groupInfo) ggtree(chiroptera, aes(color=group), layout=&#39;circular&#39;) + geom_tiplab(size=1, aes(angle=angle)) 6.5 Collapse clade With collapse function, user can collapse a selected clade. cp &lt;- collapse(p, node=21) cp + geom_point2(aes(subset=(node == 21)), size=5, shape=23, fill=&quot;steelblue&quot;) 6.6 Expand collapsed clade The collapsed clade can be expanded via expand function. cp %&gt;% expand(node=21) p1 &lt;- ggtree(tree) p2 &lt;- collapse(p1, 21) + geom_point2(aes(subset=(node==21)), size=5, shape=23, fill=&quot;blue&quot;) p3 &lt;- collapse(p2, 17) + geom_point2(aes(subset=(node==17)), size=5, shape=23, fill=&quot;red&quot;) p4 &lt;- expand(p3, 17) p5 &lt;- expand(p4, 21) library(cowplot) plot_grid(p1, p2, p3, p4, p5, ncol=5) 6.7 Scale clade Collpase selected clades can save some space, another approach is to zoom out clade to a small scale. plot_grid(ggtree(tree) + geom_hilight(21, &quot;steelblue&quot;), ggtree(tree) %&gt;% scaleClade(21, scale=0.3) + geom_hilight(21, &quot;steelblue&quot;), ncol=2) Of course, scaleClade can accept scale larger than 1 and zoom in the selected portion. plot_grid(ggtree(tree) + geom_hilight(17, fill=&quot;steelblue&quot;) + geom_hilight(21, fill=&quot;darkgreen&quot;), ggtree(tree) %&gt;% scaleClade(17, scale=2) %&gt;% scaleClade(21, scale=0.3) + geom_hilight(17, &quot;steelblue&quot;) + geom_hilight(21, fill=&quot;darkgreen&quot;), ncol=2) 6.8 Rotate clade A selected clade can be rotated by 180 degree using rotate function. tree &lt;- groupClade(tree, c(21, 17)) p &lt;- ggtree(tree, aes(color=group)) + scale_color_manual(values=c(&quot;black&quot;, &quot;firebrick&quot;, &quot;steelblue&quot;)) p2 &lt;- rotate(p, 21) %&gt;% rotate(17) plot_grid(p, p2, ncol=2) set.seed(2016-05-29) p &lt;- ggtree(tree &lt;- rtree(50)) + geom_tiplab() for (n in reorder(tree, &#39;postorder&#39;)$edge[,1] %&gt;% unique) { p &lt;- rotate(p, n) print(p + geom_point2(aes(subset=(node == n)), color=&#39;red&#39;)) } 6.9 Flip clade The positions of two selected clades (should share a same parent) can be flip over using flip function. plot_grid(p, flip(p, 17, 21), ncol=2) 6.10 Open tree ggtree supports fan layout and can also transform the circular layout tree to a fan tree by specifying an open angle to open_tree function. set.seed(123) tr &lt;- rtree(50) p &lt;- ggtree(tr, layout=&#39;circular&#39;) + geom_tiplab2() for (angle in seq(0, 270, 10)) { print(open_tree(p, angle=angle) + ggtitle(paste(&quot;open angle:&quot;, angle))) } 6.11 Rotate tree Rotating a circular tree is supported by rotate_tree function. for (angle in seq(0, 270, 10)) { print(rotate_tree(p, angle) + ggtitle(paste(&quot;rotate angle:&quot;, angle))) } 6.12 Interactive tree manipulation Interactive tree manipulation is also possible, please refer to https://guangchuangyu.github.io/2016/06/identify-method-for-ggtree. "],
["plotting-tree-with-data.html", "Chapter 7 Plotting tree with data 7.1 Visualize tree with associated matrix 7.2 Visualize tree with multiple sequence alignment 7.3 Plot tree with associated data", " Chapter 7 Plotting tree with data Integrating user data to annotate phylogenetic tree can be done at different levels. The treeio package implements full_join methods to combine tree data to phylogenetic tree object. The tidytree package supports linking tree data to phylogeny using tidyverse verbs. ggtree supports mapping external data to phylogeny for visualization and annotation on the fly. 7.0.1 The %&lt;+% operator Suppose we have the following data that associate with the tree and would like to attach the data in the tree. nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) p &lt;- ggtree(tree) dd &lt;- data.frame(taxa = LETTERS[1:13], place = c(rep(&quot;GZ&quot;, 5), rep(&quot;HK&quot;, 3), rep(&quot;CZ&quot;, 4), NA), value = round(abs(rnorm(13, mean=70, sd=10)), digits=1)) ## you don&#39;t need to order the data ## data was reshuffled just for demonstration dd &lt;- dd[sample(1:13, 13), ] row.names(dd) &lt;- NULL print(dd) taxa place value D GZ 78.4 K CZ 72.7 C GZ 83.0 H HK 102.6 E GZ 75.3 M NA 67.1 J CZ 70.4 A GZ 51.5 B GZ 56.6 L CZ 79.6 F HK 55.9 I CZ 68.0 G HK 86.1 We can imaging that the place column stores the location that we isolated the species and value column stores numerical values (e.g. bootstrap values). We have demonstrated using the operator, %&lt;%, to update a tree view with a new tree. Here, we will introduce another operator, %&lt;+%, that attaches annotation data to a tree view. The only requirement of the input data is that its first column should be matched with the node/tip labels of the tree. After attaching the annotation data to the tree by %&lt;+%, all the columns in the data are visible to ggtree. As an example, here we attach the above annotation data to the tree view, p, and add a layer that showing the tip labels and colored them by the isolation site stored in place column. p &lt;- p %&lt;+% dd + geom_tiplab(aes(color=place)) + geom_tippoint(aes(size=value, shape=place, color=place), alpha=0.25) p + theme(legend.position=&quot;right&quot;) Once the data was attached, it is always attached. So that we can add other layers to display these information easily. p + geom_text(aes(color=place, label=place), hjust=1, vjust=-0.4, size=3) + geom_text(aes(color=place, label=value), hjust=1, vjust=1.4, size=3) 7.1 Visualize tree with associated matrix The gheatmap function is designed to visualize phylogenetic tree with heatmap of associated matrix. In the following example, we visualized a tree of H3 influenza viruses with their associated genotype. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) genotype_file &lt;- system.file(&quot;examples/Genotype.txt&quot;, package=&quot;ggtree&quot;) genotype &lt;- read.table(genotype_file, sep=&quot;\\t&quot;, stringsAsFactor=F) colnames(genotype) &lt;- sub(&quot;\\\\.$&quot;, &quot;&quot;, colnames(genotype)) p &lt;- ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + geom_treescale(x=2008, y=1, offset=2) p &lt;- p + geom_tiplab(size=2) gheatmap(p, genotype, offset=5, width=0.5, font.size=3, colnames_angle=-45, hjust=0) + scale_fill_manual(breaks=c(&quot;HuH3N2&quot;, &quot;pdm&quot;, &quot;trig&quot;), values=c(&quot;steelblue&quot;, &quot;firebrick&quot;, &quot;darkgreen&quot;)) The width parameter is to control the width of the heatmap. It supports another parameter offset for controlling the distance between the tree and the heatmap, for instance to allocate space for tip labels. For time-scaled tree, as in this example, it’s more often to use x axis by using theme_tree2. But with this solution, the heatmap is just another layer and will change the x axis. To overcome this issue, we implemented scale_x_ggtree to set the x axis more reasonable. p &lt;- ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + geom_tiplab(size=2, align=TRUE, linesize=.5) + theme_tree2() pp &lt;- (p + scale_y_continuous(expand=c(0, 0.3))) %&gt;% gheatmap(genotype, offset=8, width=0.6, colnames=FALSE) %&gt;% scale_x_ggtree() pp + theme(legend.position=&quot;right&quot;) 7.2 Visualize tree with multiple sequence alignment With msaplot function, user can visualize multiple sequence alignment with phylogenetic tree, as demonstrated below: fasta &lt;- system.file(&quot;examples/FluA_H3_AA.fas&quot;, package=&quot;ggtree&quot;) msaplot(ggtree(beast_tree), fasta) A specific slice of the alignment can also be displayed by specific window parameter. msaplot(ggtree(beast_tree), fasta, window=c(150, 200)) + coord_polar(theta=&#39;y&#39;) 7.3 Plot tree with associated data For associating phylogenetic tree with different type of plot produced by user’s data, ggtree provides facet_plot function which accepts an input data.frame and a geom function to draw the input data. The data will be displayed in an additional panel of the plot. tr &lt;- rtree(30) d1 &lt;- data.frame(id=tr$tip.label, val=rnorm(30, sd=3)) p &lt;- ggtree(tr) p2 &lt;- facet_plot(p, panel=&quot;dot&quot;, data=d1, geom=geom_point, aes(x=val), color=&#39;firebrick&#39;) d2 &lt;- data.frame(id=tr$tip.label, value=abs(rnorm(30, mean=100, sd=50))) facet_plot(p2, panel=&#39;bar&#39;, data=d2, geom=geom_segment, aes(x=0, xend=value, y=y, yend=y), size=3, color=&#39;steelblue&#39;) + theme_tree2() "],
["annotating-tree-with-silhouette-images-and-sub-plots.html", "Chapter 8 Annotating Tree with Silhouette Images and Sub-plots 8.1 Annotating Tree with Images 8.2 Annotating Tree with Phylopic 8.3 Annotating Tree with Sub-plots 8.4 Have Fun with Phylomoji", " Chapter 8 Annotating Tree with Silhouette Images and Sub-plots 8.1 Annotating Tree with Images We usually use text to label taxa, i.e. displaying taxa names. If the text is image file name (either local or remote), ggtree can read the image and display the actual image as label of the taxa. The geom_tiplab and geom_nodelab are capable to render silhouette image by internally called ggimage package. library(ggimage) library(ggtree) nwk &lt;- &quot;((((bufonidae, dendrobatidae), ceratophryidae), (centrolenidae, leptodactylidae)), hylidae);&quot; x = read.tree(text = nwk) ggtree(x) + xlim(NA, 7) + ylim(NA, 6.2) + geom_tiplab(aes(image=paste0(&quot;img/frogs/&quot;, label, &#39;.jpg&#39;)), geom=&quot;image&quot;, offset=2, align=2, size=.2) + geom_tiplab(geom=&#39;label&#39;, offset=1, hjust=.5) + geom_image(x=.8, y=5.5, image=&quot;img/frogs/frog.jpg&quot;, size=.2) 8.2 Annotating Tree with Phylopic Phylopic contains more than 3200 silhouettes and covers almost all life forms. ggtree also supports using phylopic9 to annotate the tree. Most importantly, we can color the image using numerical/categorical variable. tree &lt;- ape::read.nexus(&quot;https://raw.githubusercontent.com/rgriff23/Dissertation/master/Chapter_2/data/tree.nex&quot;) phylopic_info &lt;- data.frame(node = c(124, 113, 110, 96, 89, 70), phylopic = c(&quot;7fb9bea8-e758-4986-afb2-95a2c3bf983d&quot;, &quot;bac25f49-97a4-4aec-beb6-f542158ebd23&quot;, &quot;f598fb39-facf-43ea-a576-1861304b2fe4&quot;, &quot;aceb287d-84cf-46f1-868c-4797c4ac54a8&quot;, &quot;0174801d-15a6-4668-bfe0-4c421fbe51e8&quot;, &quot;72f2f854-f3cd-4666-887c-35d5c256ab0f&quot;), species = c(&quot;galagoids&quot;, &quot;lemurs&quot;, &quot;tarsiers&quot;, &quot;cebids&quot;, &quot;hominoids&quot;, &quot;cercopithecoids&quot;)) pg &lt;- ggtree(tree) pg %&lt;+% phylopic_info + geom_nodelab(aes(image=phylopic, color=species, subset=!is.na(species)), geom=&quot;phylopic&quot;) + theme(legend.position=c(.1, .8)) 8.3 Annotating Tree with Sub-plots ggtree provides a function, inset, for adding subplots to a phylogenetic tree. The input is a tree graphic object and a named list of ggplot graphic objects (can be any kind of charts), these objects should named by node numbers. To facilitate adding bar and pie charts (e.g. summarized stats of results from ancestral reconstruction) to phylogenetic tree, ggtree provides nodepie and nodebar functions to create a list of pie or bar charts. 8.3.1 Annotate with bar charts set.seed(2015-12-31) tr &lt;- rtree(15) p &lt;- ggtree(tr) a &lt;- runif(14, 0, 0.33) b &lt;- runif(14, 0, 0.33) c &lt;- runif(14, 0, 0.33) d &lt;- 1 - a - b - c dat &lt;- data.frame(a=a, b=b, c=c, d=d) ## input data should have a column of `node` that store the node number dat$node &lt;- 15+1:14 ## cols parameter indicate which columns store stats (a, b, c and d in this example) bars &lt;- nodebar(dat, cols=1:4) inset(p, bars, width=.2, height=1) Users can set the color via the parameter color. The x position can be one of ‘node’ or ‘branch’ and can be adjusted by the parameter hjust and vjust for horizontal and vertical adjustment respecitvely. bars2 &lt;- nodebar(dat, cols=1:4, position=&#39;dodge&#39;, color=c(a=&#39;blue&#39;, b=&#39;red&#39;, c=&#39;green&#39;, d=&#39;cyan&#39;)) p2 &lt;- inset(p, bars2, x=&#39;branch&#39;, width=.2, height=1, vjust=-.3) print(p2) 8.3.2 Annotate with pie charts Similarly, users can use nodepie function to generate a list of pie charts and place these charts to annotate corresponding nodes. Both nodebar and nodepie accepts parameter alpha to allow transparency. pies &lt;- nodepie(dat, cols=1:4, alpha=.6) inset(p, pies, width=1, height=1, hjust=-.06) 8.3.3 Annotate with other types of charts The inset function accepts a list of ggplot graphic objects and these input objects are not restricted to pie or bar charts. They can be any kinds of charts and hybrid of these charts. pies_and_bars &lt;- bars2 pies_and_bars[9:14] &lt;- pies[9:14] inset(p, pies_and_bars, width=.3, height=1) d &lt;- lapply(1:15, rnorm, n=100) ylim &lt;- range(unlist(d)) bx &lt;- lapply(d, function(y) { dd &lt;- data.frame(y=y) ggplot(dd, aes(x=1, y=y))+geom_boxplot() + ylim(ylim) + theme_inset() }) names(bx) &lt;- 1:15 inset(p, bx, width=.2, height=2, hjust=-.05) After annotating with insets, users can further annotate the tree with another layer of insets. p2 &lt;- inset(p, bars2, x=&#39;branch&#39;, width=.5, height=1, vjust=-.4) p2 &lt;- inset(p2, pies, x=&#39;branch&#39;, vjust=.4, width=.5, height=1) bx2 &lt;- lapply(bx, function(g) g+coord_flip()) inset(p2, bx2, width=2, height=1, vjust=.04, hjust=p2$data$x[1:15]-5) + xlim(NA, 6) 8.4 Have Fun with Phylomoji #phylomoji is fun and it is internally supported by ggtree since 201510. Here, we will use ggtree to recreate the figure: library(ggplot2) library(ggtree) tt = &#39;((snail,mushroom),(((sunflower,evergreen_tree),leaves),green_salad));&#39; tree = read.tree(text = tt) d &lt;- data.frame(label = c(&#39;snail&#39;,&#39;mushroom&#39;, &#39;sunflower&#39;, &#39;evergreen_tree&#39;,&#39;leaves&#39;, &#39;green_salad&#39;), group = c(&#39;animal&#39;, &#39;fungi&#39;, &#39;flowering plant&#39;, &#39;conifers&#39;, &#39;ferns&#39;, &#39;mosses&#39;)) ggtree(tree, linetype = &quot;dashed&quot;, size=1, color=&#39;firebrick&#39;) %&lt;+% d + xlim(0, 4.5) + ylim(0.5, 6.5) + geom_tiplab(aes(color=label), parse=&quot;emoji&quot;, size=15, vjust=.25) + geom_tiplab(aes(label = group), geom=&quot;label&quot;, x=3.5, hjust=.5) With ggtree, it is easy to generate phylomoji. The emoji is treated as text, like abc. We can use emojis to label taxa, clade, color and ratate emoji with any given color and angle. 8.4.1 emoji in cirular/fan layout tree p &lt;- ggtree(tree, layout = &quot;circular&quot;, size=1) + geom_tiplab2(aes(color=label), parse=&quot;emoji&quot;, size=10, vjust=.25) print(p) ## fan layout p2 &lt;- open_tree(p, angle=200) print(p2) p2 %&gt;% rotate_tree(-90) 8.4.2 emoji to label clades set.seed(123) tr &lt;- rtree(30) ggtree(tr) + xlim(NA, 5) + geom_cladelabel(node=41, label=&quot;chicken&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;firebrick&quot;) + geom_cladelabel(node=51, label=&quot;duck&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;steelblue&quot;) + geom_cladelabel(node=32, label=&quot;family&quot;, parse=&quot;emoji&quot;, fontsize=12, align=TRUE, color=&quot;darkkhaki&quot;) 8.4.3 Apple Color Emoji Although R’s graphical devices don’t support AppleColorEmoji font, it’s still possible to use it. We can export the plot to svg file and render it in Safari. library(ggtree) tree_text &lt;- &quot;(((((cow, (whale, dolphin)), (pig2, boar)), camel), fish), seedling);&quot; x &lt;- read.tree(text=tree_text) library(ggimage) library(gridSVG) p &lt;- ggtree(x, size=2) + geom_tiplab(size=20, parse=&#39;emoji&#39;) + xlim(NA, 7) + ylim(NA, 8.5) + geom_phylopic(image=&quot;79ad5f09-cf21-4c89-8e7d-0c82a00ce728&quot;, color=&quot;firebrick&quot;, alpha = .3, size=Inf) p ps = grid.export(&quot;emoji.svg&quot;, addClass=T) https://twitter.com/guangchuangyu/status/593443854541434882↩ https://twitter.com/guangchuangyu/status/662095056610811904 and https://twitter.com/guangchuangyu/status/667337429704011777↩ "],
["ggtree-extensions.html", "Chapter 9 ggtree extensions", " Chapter 9 ggtree extensions deeptime: Plotting Tools for Anyone Working in Deep Time ggnetworx: phylogenetic networks using ggplot2 and ggtree microbiomeViz: Visualize microbiome data with black magic ggtree deeptime "],
["figures-and-tables.html", "A Figures and Tables", " A Figures and Tables Table A.1: Functions defined in treeio. Function Description read.beast parsing output of BEAST read.codeml parsing output of CodeML (rst and mlc files) read.codeml_mlc parsing mlc file (output of CodeML) read.hyphy parsing output of HYPHY read.jplace parsing jplace file including output of EPA and pplacer read.nhx parsing NHX file including output of PHYLODOG and RevBayes read.paml_rst parsing rst file (output of BaseML or CodeML) read.phylip parsing phylip file read.phyloT parsing output of phyloT (http://phylot.biobyte.de/) read.r8s parsing output of r8s read.raxml parsing output of RAxML Nnode get number of internal nodes Nnode2 get number of all nodes (including internal and external nodes) Ntip get number of all tips (external nodes) as.phylo convert tree object to phylo object as.treedata convert tree object to treedata object drop.tip remove tips in a tree get.fields get available tree attributes stored in tree object get.placements get placement result of jplace object get.subs get substitution by comparing parent node and child node get.tipseq get tip sequences get.treetext get newick text of a tree object groupClade add clade grouping information to tree object groupOTU grouping OTUs by tracing back to most recent commond ancestor merge_tree merging tree objects into one write.jpace write tree with associated annotation data to a jplace file "],
["references.html", "References", " References "]
]
