[["chapter1.html", "Chapter 1 Importing Tree with Data 1.1 Overview of Phylogenetic Tree Construction 1.2 Phylogenetic Tree Formats 1.3 Getting Tree Data with treeio 1.4 Summary", " Chapter 1 Importing Tree with Data 1.1 Overview of Phylogenetic Tree Construction Phylogenetic trees are used to describe genealogical relationships among a group of organisms, which can be constructed based on the genetic sequences of the organisms. A rooted phylogenetic tree represents a model of evolutionary history depicted by ancestor-descendant relationships between tree nodes and clustering of ‘sister’ or ‘cousin’ organisms at a different level of relatedness, as illustrated in Figure 1.1. In infectious disease research, phylogenetic trees are usually built from the pathogens’ gene or genome sequences to show which pathogen sample is genetically closer to another sample, providing insights into the underlying unobserved epidemiologic linkage and a potential source of an outbreak. FIGURE 1.1: Components of a phylogenetic tree. External nodes (green circles), also called ‘tips,’ represent actual organisms sampled and sequenced (e.g., viruses in infectious disease research). They are the ‘taxa’ in the terminology of evolutionary biology. The internal nodes (blue circles) represent hypothetical ancestors for the tips. The root (red circle) is the common ancestor of all species in the tree. The horizontal lines are branches and represent evolutionary changes (grey number) measured in a unit of time or genetic divergence. The bar at the bottom provides the scale of these branch lengths. A phylogenetic tree can be constructed from genetic sequences using distance-based methods or character-based methods. Distance-based methods, including the unweighted pair group method with arithmetic means (UPGMA) and the Neighbor-joining (NJ), are based on the matrix of pairwise genetic distances calculated between sequences. The character-based methods, including maximum parsimony (MP) (Fitch 1971), maximum likelihood (ML) (J. Felsenstein 1981), and Bayesian Markov Chain Monte Carlo (BMCMC) method (Rannala and Yang 1996), are based on a mathematical model that describes the evolution of genetic characters and searches for the best phylogenetic tree according to their own optimality criteria. Maximum Parsimony (MP) method assumes that the evolutionary change is rare and minimizes the amount of character-state changes (e.g., number of DNA substitutions). The criterion is similar to Occam’s razor, that the simplest hypothesis that can explain the data is the best hypothesis. Unweighted parsimony assumes mutations across different characters (nucleotides or amino acids) are equally likely while weighted method assumes unequal likely of mutations (e.g., the third codon position is more liable than other codon positions; and the transition mutations have a higher frequency than transversion). The concept of MP method is straightforward and intuitive, which is a probable reason for its popularity amongst biologists who care more about the research question rather than the computational details of the analysis. However, this method has a number of disadvantages, which in particular the tree inference can be biased by the well-known systematic error called long-branch attraction (LBA) that incorrectly infer distantly related lineages as closely related (Joseph Felsenstein 1978). This is because MP method poorly takes into consideration of many sequence evolution factors (e.g., reversals and convergence) that are hardly observable from the existing genetic data. Maximum Likelihood (ML) method and Bayesian Markov Chain Monte Carlo (BMCMC) method are the two most commonly used methods in phylogenetic tree construction and are most often used in scientific publications. ML and BMCMC methods require a substitution model of sequence evolution. Different sequence data have different substitution models to formulate the evolutionary process of DNA, codon and amino acid. There are several models for nucleotide substitution, including JC69, K2P, F81, HKY and GTR (Arenas 2015). These models can be used in conjunction with the rate variation across sites (denoted as +\\(\\Gamma\\))) (Z. Yang 1994) and the proportion of invariable sites (denoted as +I) (Shoemaker and Fitch 1989). Previous research (Lemmon and Moriarty 2004) had suggested that misspecification of substitution model might bias phylogenetic inference. Procedural testing for the best-fit substitution model is recommended. The optimal criterion of ML method is to find the tree that maximizes the likelihood given the sequence data. The procedure of ML method is simple: calculating the likelihood of a tree and optimizing its topology and branches (and the substitution model parameters, if not fixed) until the best tree is found. Heuristic search such as those implemented in PhyML and RAxML, is often used to find the best tree based on the likelihood criterion. Bayesian method finds the tree that maximizes posterior probability by sampling trees through MCMC based on the given substitution model. One of the advantages of BMCMC is that parameter variance and tree topological uncertainty, included by the posterior clade probability, can be naturally and conveniently obtained from the sampling trees in MCMC process. Moreover, the influence of topological uncertainty on other parameter estimates is also naturally integrated in the BMCMC phylogenetic framework. In a simple phylogenetic tree, data associated with the tree branches/nodes could be the branch lengths (indicating genetic or time divergence) and lineage supports such as bootstrap values estimated from bootstrapping procedure or posterior clade probability summarized from the sampled trees in the BMCMC analysis. 1.2 Phylogenetic Tree Formats There are several file formats designed to store phylogenetic trees and the data associated with the nodes and branches. The three commonly used formats are Newick2, NEXUS (Maddison et al. 1997) and Phylip (Joseph Felsenstein 1989). Some formats (e.g., NHX) are extended from Newick format. Newick and NEXUS formats are supported as input by most of the software in evolutionary biology, while some of the software tools output newer standard files (e.g., BEAST and MrBayes) by introducing new rules/data blocks for storing evolutionary inferences. In the other cases (e.g., PAML and r8s), output log files are only recognized by their own single software. 1.2.1 Newick tree format The Newick tree format is the standard for representing trees in computer-readable form. FIGURE 1.2: A sample tree for demonstrating Newick text to encode tree structure. Tips were aligned to the right hand side and branch lengths were labelled on the middle of each branch. The rooted tree shown in Figure 1.2 can be represented by the following sequence of characters as a Newick tree text. ((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59); The tree text ends with a semicolon. Internal nodes are represented by a pair of matched parentheses. Between the parentheses are descendant nodes of that node. For instance (t2:0.04,t1:0.34) represents the parent node of t2 and t1 that are the immediate descendants. Sibling nodes are separated by comma and tips are represented by their names. A branch length (from parent node to child node) is represented by a real number after the child node and preceded by a colon. Singular data (e.g., bootstrap values) associated with internal nodes or branches may be encoded as node label and represented by the simple text/numbers before the colon. Newick tree format was developed by Meacham in 1984 for the PHYLIP (Retief 2000) package. Newick format is now the most widely used tree format and used by PHYLIP, PAUP* (Wilgenbusch and Swofford 2003), TREE-PUZZLE (Schmidt et al. 2002), MrBayes and many other applications. Phylip tree format contains Phylip multiple sequence alignment (MSA) with a corresponding Newick tree text that was built based on the MSA sequences in the same file. 1.2.2 NEXUS tree format The NEXUS format (Maddison et al. 1997) incorporates Newick tree text with related information organized into separated units known as blocks. A NEXUS block has the following structure: #NEXUS ... BEGIN characters; ... END; For example, the above example tree can be saved as a following NEXUS format: ## #NEXUS ## [R-package APE, Mon Oct 11 10:25:55 2021] ## ## BEGIN TAXA; ## DIMENSIONS NTAX = 5; ## TAXLABELS ## t2 ## t1 ## t5 ## t4 ## t3 ## ; ## END; ## BEGIN TREES; ## TRANSLATE ## 1 t2, ## 2 t1, ## 3 t5, ## 4 t4, ## 5 t3 ## ; ## TREE * UNTITLED = [&amp;R] ((1:0.04,2:0.34):0.89,(3:0.37,(4:0.03,5:0.67):0.9):0.59); ## END; Comments can be placed by using square brackets. Some blocks can be recognized by most of the programs including TAXA (contains information of taxa), DATA (contains data matrix, e.g., sequence alignment) and TREE (contains phylogenetic tree, i.e., Newick tree text). Notably, blocks can be very diversed and some of them are only be recognized by one particular program. For example NEXUS file exported by PAUP* has a paup block which contains PAUP* commands, whereas FigTree exports NEXUS file with a figtree block that contains visualization settings. NEXUS organizes different types of data into different blocks, whereas programs that support reading NEXUS can parse some blocks they recognized and ignore those they could not. This is a good mechanism to allow different programs to use the same format without crashing when unsupported types of data are present. Notably most of the programs only support parsing TAXA, DATA and TREE blocks, therefore a program/platform that could generically read all kinds of data blocks from the NEXUS would be useful for phylogenetic data integration. The DATA block is widely used to store sequence alignment. For this purpose, user can store tree and sequence data in Phylip format which are essentially Phylip multiple sequence alignment and Newick tree text respectively. It is used in Phylogeny Inference Package (PHYLIP). 1.2.3 New Hampshire eXtended format Newick, NEXUS and phylip are mainly designed to store phylogenetic tree and basic singular data associated with internal nodes or branches. In addition to the singular data annotation at branches and nodes (mentioned above), New Hampshire eXtended format (NHX), which is based on Newick (also called New Hampshire), was developed to introduce tags to associate multiple data fields with the tree nodes (both internal nodes and tips). Tags are placed after branch length and must be wrapped between [&amp;&amp;NHX and ] which makes it possible to be compatible with NEXUS format as it defined characters between [ and ] as comments. NHX is also the output format of PHYLDOG (Boussau et al. 2013) and RevBayes (Höhna et al. 2016). A Tree Viewer (ATV) (Zmasek and Eddy 2001) is a java tool that supports displaying annotation data stored in NHX format, but this package is no more maintained. Here is a sample tree from NHX definition document3: (((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]):0.05[&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY:0.1[&amp;&amp;NHX:S=nematode],ADHX:0.12[&amp;&amp;NHX:S=insect]):0.1[&amp;&amp;NHX:S=metazoa:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast],ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast],ADH1:0.11[&amp;&amp;NHX:S=yeast]):0.1[&amp;&amp;NHX:S=Fungi]) [&amp;&amp;NHX:D=N]; 1.2.4 Jplace format In order to store the NGS short reads mapped onto a phylogenetic tree (for the purpose of metagenomic classification), Matsen proposed jplace format for such phylogenetic placements (Frederick A. Matsen et al. 2012). Jplace format is based on JSON and contains four keys: tree, fields, placements, metadata and version. The tree value contains tree text extended from Newick tree format by putting the edge label in brackets (if available) after branch length and putting the edge number in curly braces after the edge label. The fields value contains header information of placement data. The value of placements is a list of pqueries. Each pquery contains two keys: p for placements and n for name or nm for names with multiplicity. The value of p is a list of placement for that pqueries. Here is a jplace sample file: { &quot;tree&quot;: &quot;(((((((A:4{1},B:4{2}):6{3},C:5{4}):8{5},D:6{6}): 3{7},E:21{8}):10{9},((F:4{10},G:12{11}):14{12},H:8{13}): 13{14}):13{15},((I:5{16},J:2{17}):30{18},(K:11{19}, L:11{20}):2{21}):17{22}):4{23},M:56{24});&quot;, &quot;placements&quot;: [ {&quot;p&quot;:[24, -61371.300778, 0.333344, 0.000003, 0.003887], &quot;n&quot;:[&quot;AA&quot;] }, {&quot;p&quot;:[[1, -61312.210786, 0.333335, 0.000001, 0.000003], [2, -61322.210823, 0.333322, 0.000003, 0.000003], [3, -61352.210823, 0.333322, 0.000961, 0.000003]], &quot;n&quot;:[&quot;BB&quot;] }, {&quot;p&quot;:[[8, -61312.229128, 0.200011, 0.000001, 0.000003], [9, -61322.229179, 0.200000, 0.000003, 0.000003], [10, -61342.229223, 0.199992, 0.000003, 0.000003]], &quot;n&quot;:[&quot;CC&quot;] } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;a jplace sample file&quot;}, &quot;version&quot; : 2, &quot;fields&quot;: [&quot;edge_num&quot;, &quot;likelihood&quot;, &quot;like_weight_ratio&quot;, &quot;distal_length&quot;, &quot;pendant_length&quot; ] } Jplace is the output format of pplacer (Frederick A. Matsen, Kodner, and Armbrust 2010a) and Evolutionary Placement Algorithm (EPA) (Berger, Krompass, and Stamatakis 2011). But these two programs do not contain tools to visualize placement results. Pplacer provides placeviz to convert jplace file to phyloXML or Newick formats which can be visualized by Archaeopteryx4. 1.2.5 Software outputs RAxML (Stamatakis 2014) can output Newick format by storing the bootstrap values as internal node labels. Another way that RAxML supports is to place bootstrap value inside square brackets and after branch length. This could not be supported by most of the software that support Newick format where square brackets will be ignored. BEAST (Bouckaert et al. 2014) output is based on NEXUS and it also introduces square brackets in the tree block to store evolutionary evidence inferred by BEAST. Inside brackets, curly braces may also be incorporated if feature values have a length more than 1 (e.g., HPD or range of substitution rate). These brackets are placed between node and branch length (i.e., after label if exists and before colon). Bracket is not defined in Newick format and is a reserve character for NEXUS comment. So these information will be ignored for standard NEXUS parsers. Here is a sample TREE block of the BEAST output: tree TREE1 = [&amp;R] (((11[&amp;length=9.4]:9.38,14[&amp;length=6.4]:6.385096430786298) [&amp;length=25.7]:25.43,4[&amp;length=9.1]:8.821663252749829) [&amp;length=3.0]:3.10,(12[&amp;length=0.6]:0.56, (10[&amp;length=1.6]:1.56,(7[&amp;length=5.2]:5.19, ((((2[&amp;length=3.3]:3.26,(1[&amp;length=1.3]:1.32, (6[&amp;length=0.8]:0.83,13[&amp;length=0.8]:0.8311577761397366) [&amp;length=2.4]:2.48917886025146) [&amp;length=0.9]:0.9416178372674331) [&amp;length=0.4]:0.49,9[&amp;length=1.7]:1.757288031101215) [&amp;length=2.4]:2.35,8[&amp;length=2.1]:2.1125745387283246) [&amp;length=0.2]:0.23,(3[&amp;length=3.3]:3.31, (15[&amp;length=5.2]:5.27,5[&amp;length=3.2]:3.2710481368304585) [&amp;length=1.0]:1.0409443024626412) [&amp;length=1.9]:2.0372962536780435) [&amp;length=2.8]:2.8446835614595685) [&amp;length=5.3]:5.367459711197171) [&amp;length=2.0]:2.0037467863383043) [&amp;length=4.3]:4.360909907798238)[&amp;length=0.0]; BEAST output can contain many different evolutionary inferences, depending on the analysis models defined in BEAUTi for running. For example in molecular clock analysis, it contains rate, length, height, posterior and corresponding HPD and range for uncertainty estimation. Rate is the estimated evolutionary rate of the branch. Length is the length of the branch in years. Height is the time from node to root while posterior is the Bayesian clade credibility value. The above example is the output tree of a molecular clock analysis and should contain these inferences. To save space, only the length estimation was shown above. Besides, Molecular Evolutionary Genetics Analysis (MEGA) (Kumar, Stecher, and Tamura 2016) also supports exporting tree in BEAST compatible Nexus format (see session 1.3.2). MrBayes (Huelsenbeck and Ronquist 2001) is a program that uses Markov Chain Monte Carlo method to sample from the posterior probability distributions. Its output file annotates nodes and branches separately by two sets of square brackets. For example below, posterior clade probabilities for the node and branch length estimates for the branch: tree con_all_compat = [&amp;U] (8[&amp;prob=1.0]:2.94e-1[&amp;length_mean=2.9e-1],10[&amp;prob=1.0]:2.25e-1[&amp;length_mean=2.2e-1], ((((1[&amp;prob=1.0]:1.43e-1[&amp;length_mean=1.4e-1],2[&amp;prob=1.0]:1.92e-1[&amp;length_mean=1.9e-1]) [&amp;prob=1.0]:1.24e-1[&amp;length_mean=1.2e-1],9[&amp;prob=1.0]:2.27e-1[&amp;length_mean=2.2e-1]) [&amp;prob=1.0]:1.72e-1[&amp;length_mean=1.7e-1],12[&amp;prob=1.0]:5.11e-1[&amp;length_mean=5.1e-1]) [&amp;prob=1.0]:1.76e-1[&amp;length_mean=1.7e-1], (((3[&amp;prob=1.0]:5.46e-2[&amp;length_mean=5.4e-2], (6[&amp;prob=1.0]:1.03e-2[&amp;length_mean=1.0e-2],7[&amp;prob=1.0]:7.13e-3[&amp;length_mean=7.2e-3]) [&amp;prob=1.0]:6.93e-2[&amp;length_mean=6.9e-2]) [&amp;prob=1.0]:6.03e-2[&amp;length_mean=6.0e-2], (4[&amp;prob=1.0]:6.27e-2[&amp;length_mean=6.2e-2],5[&amp;prob=1.0]:6.31e-2[&amp;length_mean=6.3e-2]) [&amp;prob=1.0]:6.07e-2[&amp;length_mean=6.0e-2]) [&amp;prob=1.0]:1.80e-1[&amp;length_mean=1.8e-1],11[&amp;prob=1.0]:2.37e-1[&amp;length_mean=2.3e-1]) [&amp;prob=1.0]:4.05e-1[&amp;length_mean=4.0e-1]) [&amp;prob=1.0]:1.16e+000[&amp;length_mean=1.162699558201079e+000]) [&amp;prob=1.0][&amp;length_mean=0]; To save space, most of the inferences were removed and only contains prob for clade probability and length_mean for mean value of branch length. The full version of this file also contains prob_stddev, prob_range, prob(percent), prob+-sd for probability inferences and length_median, length_95%_HPD for every branch. The BEAST and MrBayes outputs are expected to be parsed without inferences (dropped as comments) by software that supports NEXUS. FigTree supports parsing BEAST and MrBayes outputs with inferences that can be used to display or annotate on the tree. But from there extracting these data for further analysis is still challenging. HyPhy (Pond, Frost, and Muse 2005) could do a number of phylogenetic analysis, including ancestral sequence reconstruction. For ancestral sequence reconstruction, these sequences and the Newick tree text are stored in NEXUS format as the major analysis output. It did not completely follow the NEXUS definition and only put the ancestral node labels in TAXA instead of the external node label. The MATRIX block contains sequence alignment of ancestral nodes which cannot be referred back to the tree stored in TREES block since it does not contain node labels. Here is the sample output (to save space, only the first 72bp of alignment are shown): #NEXUS [ Generated by HYPHY 2.0020110620beta(MP) for MacOS(Universal Binary) on Tue Dec 23 13:52:34 2014 ] BEGIN TAXA; DIMENSIONS NTAX = 13; TAXLABELS &#39;Node1&#39; &#39;Node2&#39; &#39;Node3&#39; &#39;Node4&#39; &#39;Node5&#39; &#39;Node12&#39; &#39;Node13&#39; &#39;Node15&#39; &#39;Node18&#39; &#39;Node20&#39; &#39;Node22&#39; &#39;Node24&#39; &#39;Node26&#39; ; END; BEGIN CHARACTERS; DIMENSIONS NCHAR = 2148; FORMAT DATATYPE = DNA GAP=- MISSING=? NOLABELS ; MATRIX ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATTGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAGTGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT END; BEGIN TREES; TREE tree = (K,N,(D,(L,(J,(G,((C,(E,O)),(H,(I,(B,(A,(F,M))))))))))); END; There are other applications that output rich information text that also contains phylogenetic trees with associated data. For example r8s (Sanderson 2003) output three trees in its log file, namely TREE, RATE and PHYLO for branches scaled by time, substitution rate, and absolute substitutions respectively. Phylogenetic Analysis by Maximum Likelihood (PAML) (Ziheng Yang 2007) is a package of programs for phylogenetic analyses of DNA or protein sequences. Two main programs, BaseML and CodeML, implement a variety of models. BaseML estimates tree topology, branch lengths and substitution parameters using a number of nucleotide substitution models available, including JC69, K80, F81, F84, HKY85, T92, TN93 and GTR. CodeML estimates synonymous and non-synonymous substitution rates, likelihood ratio test of positive selection under codon substitution models (Goldman and Yang 1994). BaseML outputs mlb file that contains input sequence (taxa) alignment and phylogenetic tree with branch length as well as substitution model and other parameters estimated. The supplementary result file, rst, contains sequence alignment (with ancestral sequence if perform reconstruction of ancestral sequences) and Naive Empirical Bayes (NBE) probabilities that each site in the alignment evolved. CodeML outputs mlc file that contains tree structure and estimation of synonymous and non-synonymous substitution rates. CodeML also output supplementary result file, rst, that is similar to BaseML except that site is defined as codon instead of nucleotide. Parsing these files can be tedious and would oftentimes need a number of post-processing steps and require expertise in programming (e.g. with Python5 or Perl6). Introducing square brackets is quite common for storing extra information, including RAxML to store bootstrap value, NHX format for annotation, jplace for edge label and BEAST for evolutionary estimation, etc.. But the positions to place square brackets are not consistent in different software and the contents employ different rules for storing associated data, these properties make it difficult to parse associated data. For most of the software, they will just ignore square brackets and only parse the tree structure if the file is compatible. Some of them contain invalid characters (e.g. curly braces in tree field of jplace format) and even the tree structure can’t be parsed by standard parsers. It is difficult to extract useful phylogeny/taxon-related information from the different analysis outputs produced by various evolutionary inference software, for displaying on the same phylogenetic tree and for further analysis. FigTree supports BEAST output, but not for most of the other software outputs that contain evolutionary inferences or associated data. For those output-rich text files (e.g. r8s, PAML, etc.), the tree structure cannot be parsed by any tree viewing software and users need expertise to manually extract the phylogenetic tree and other useful result data from the output file. However, such manual operation is slow and error-prone. It was not easy to retrieve phylogenetic trees with evolutionary data from different analysis outputs of commonly used software in the field. Some of them (e.g., PAML output and jplace file) without software or programming library to support parsing file, while others (e.g., BEAST and MrBayes output) can be parsed without evolutionary inferences as they are stored in square brackets that will be omitted as comment by most of the software. Although FigTree support visualizing evolutionary statistics inferred by BEAST and MrBayes, extracting these data for further analysis is not supported. Different software packages implement different algorithms for different analyses (e.g., PAML for dN/dS, HyPhy for ancestral sequences and BEAST for skyline analysis). Therefore, in encountering the genomic sequence data, there is a desire need to efficiently and flexibly integrate different analysis inference results for comprehensive understanding, comparison and further analysis. This motivated us to develop the programming library to parse the phylogenetic trees and data from various sources. 1.3 Getting Tree Data with treeio Phylogenetic trees are commonly used to present evolutionary relationships of species. Information associated with taxon species/strains may be further analyzed in the context of the evolutionary history depicted by the phylogenetic tree. For example, the host information of the influenza virus strains in the tree could be studied to understand the host range of a virus linage. Moreover, such meta-data (e.g., isolation host, time, location, etc.) directly associated with taxon strains are also often subjected to further evolutionary or comparative phylogenetic models and analyses, to infer their dynamics associated with the evolutionary or transmission processes of the virus. All these meta-data or other phenotypic or experimental data are stored either as the annotation data associated with the nodes or branches, and are often produced in inconsistent format by different analysis programs. Getting trees into R is still limited. Newick and Nexus can be imported by several packages, including ape, phylobase. NeXML format can be parsed by RNeXML. However, analysis results from widely used software packages in this field are not well supported. SIMMAP output can be parsed by phyext2 and phytools. Although PHYLOCH can import BEAST and MrBayes output, only internal node attributes were parsed and tip attributes were ignore7. Many other software outputs are mainly required programming expertise to import the tree with associated data. Linking external data, including experimental and clinical data, to phylogeny is another obstacle for evolution biologists. To fill the gap that most of the tree formats or software outputs cannot be parsed within the same software/platform, an R package treeio (Wang et al. 2020) was developed for parsing various tree file formats and outputs from common evolutionary analysis software. The treeio package is developed with the R programming language (R Core Team 2016). Not only the tree structure can be parsed but also the associated data and evolutionary inferences, including NHX annotation, clock rate inferences (from BEAST or r8s (Sanderson 2003) programs), synonymous and non-synonymous substitutions (from CodeML), and ancestral sequence construction (from HyPhy, BaseML or CodeML), etc.. Currently, treeio is able to read the following file formats: Newick, Nexus, New Hampshire eXtended format (NHX), jplace and Phylip as well as the data outputs from the following analysis programs: ASTRAL, BEAST, EPA, HyPhy, MEGA, MrBayes, PAML, PHYLDOG, pplacer, r8s, RAxML and RevBayes etc. This is made possible with the several parser functions developed in treeio (Table 1.1) (Wang et al. 2020). TABLE 1.1: Parser functions defined in treeio Parser function Description read.astral parsing output of ASTRAL read.beast parsing output of BEAST read.codeml parsing output of CodeML (rst and mlc files) read.codeml_mlc parsing mlc file (output of CodeML) read.fasta parsing FASTA format sequence file read.hyphy parsing output of HYPHY read.hyphy.seq parsing ancestral sequences from HYPHY output read.iqtree parsing IQ-Tree newick string, with ability to parse SH-aLRT and UFBoot support values read.jplace parsing jplace file including output of EPA and pplacer read.jtree parsing jtree format read.mega parsing MEGA Nexus output read.mega_tabular parsing MEGA tabular output read.mrbayes parsing output of MrBayes read.newick parsing newick string, with ability to parse node label as support values read.nexus parsing standard NEXUS file (re-exported from ape) read.nhx parsing NHX file including output of PHYLDOG and RevBayes read.paml_rst parsing rst file (output of BaseML or CodeML) read.phylip parsing phylip file (phylip alignment + newick string) read.phylip.seq parsing multiple sequence alignment from phylip file read.phylip.tree parsing newick string from phylip file read.phyloxml parsing phyloXML file read.r8s parsing output of r8s read.raxml parsing output of RAxML read.tree parsing newick string (re-exported from ape) The treeio package defines base classes and functions for phylogenetic tree input and output. It is an infrastructure that enables evolutionary evidence inferred by commonly used software packages to be used in R. For instance, dN/dS values or ancestral sequences inferred by CODEML (Ziheng Yang 2007), clade support values (posterior) inferred by BEAST (Bouckaert et al. 2014) and short read placement by EPA (Berger, Krompass, and Stamatakis 2011) and pplacer (Frederick A. Matsen, Kodner, and Armbrust 2010b). These pieces of evolutionary evidence can be further analyzed in R and used to annotate a phylogenetic tree using ggtree (Yu et al. 2017). The growth of analysis tools and models introduces a challenge to integrate different varieties of data and analysis results from different sources for an integral analysis on the same phylogenetic tree background. The treeio package (Wang et al. 2020) provides a merge_tree function to allow combining tree data obtained from different sources. In addition, treeio also enables external data to be linked to a phylogenetic tree structure. After parsing, storage of the tree structure with associated data is made through an S4 class, treedata, defined in the tidytree package. These parsed data are mapped to the tree branches and nodes inside treedata object, so that they can be efficiently used to visually annotate the tree using ggtree (Yu et al. 2017) and ggtreeExtra (Xu et al. 2021). A programmable platform for phylogenetic data parsing, integration and annotations as such makes us easier to identify the evolutionary dynamics and correlation patterns (Figure 1.3, Figure 1 of (Wang et al. 2020)). FIGURE 1.3: Overview of the treeio package and its relations with tidytree and ggtree. Treeio supports parsing a tree with data from a number of file formats and software outputs. A treedata object stores a phylogenetic tree with node/branch-associated data. Treeio provides several functions to manipulate a tree with data. Users can convert the treedata object into a tidy data frame (each row represents a node in the tree and each column represents a variable) and process the tree with data using the tidy interface implemented in tidytree. The tree can be extracted from the treedata object and exported to a Newick and NEXUS file or can be exported with associated data into a single file (either in the BEAST NEXUS or jtree format). Associated data stored in the treedata object can be used to annotate the tree using ggtree. In addition, ggtree supports a number of tree objects, including phyloseq for microbiome data and obkData for outbreak data. The phylo, multiPhylo (ape package), phylo4, phylo4d (phylobase package), phylog (ade4 package), phyloseq (phyloseq package), and obkData (OutbreakTools package) are tree objects defined by the R community to store tree with or without domain-specific data. All these tree objects as well as hierachical clustering results (e.g., hclust and dendrogram objects) are supported by ggtree. 1.3.1 Overview of treeio The treeio package (Wang et al. 2020) defined S4 classes for storing phylogenetic tree with diverse types of associated data or covariates from different sources including analysis outputs from different software packages. It also defined corresponding parser functions for parsing phylogenetic tree with annotation data and stored as data object in R for further manipulation or analysis (see Table 1.1). Several accessor functions were defined to facilitate accessing the tree annotation data, including get.fields for obtaining annotation features available in the tree object, get.placements for obtaining the phylogenetic placement results (i.e., output of pplacer, EPA, etc.), get.subs for obtaining the genetic substitutions from parent node to child node, and get.tipseq for getting the tip sequences. The S3 class, phylo, which was defined in ape (Paradis, Claude, and Strimmer 2004) package, is widely used in R community and many packages. As treeio uses S4 class, to enable those available R packages to analyze the tree imported by treeio, treeio provides as.phylo function to convert treeio-generated tree object to phylo object that only contains tree structure without annotation data. In the other way, treeio also provides as.treedata function to convert phylo object with evolutionary analysis result (e.g., bootstrap values calculated by ape or ancestral states inferred by phangorn (Schliep 2011) etc) to be stored as a treedata S4 object, making it easy to map the data to the tree structure and to be visualized using ggtree (Yu et al. 2017). To allow integration of different kinds of data in phylogenetic tree, treeio (Wang et al. 2020) provides merge_tree function (details in section 2.2.1) for combining evolutionary statistics/evidence imported from different sources including those common tree files and outputs from analysis programs (Table 1.1). There is other information, such as sampling location, taxonomy information, experimental result and evolutionary traits, etc. that are stored in separate files with user-defined format. In treeio, we could read in these data from the users’ files using standard R IO functions, and attach them to the tree object by the full_join methods defined in tidytree and treeio packages (see also the %&lt;+% operator defined in ggtree). After attaching, the data will become the attributes associated with nodes or branches, which can be compared with other data incorporated, or can be visually displayed on the tree (Yu et al. 2018). To facilitate storing complex data associated with the phylogenetic tree, treeio implemented write.baset and write.jtree function to export treedata object into a single file (see Chapter 3). 1.3.2 Function Demonstration 1.3.2.1 Parsing BEAST output file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) beast ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. ## ## # The associated data tibble abstraction: 29 × 16 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip height height_0.95_HPD ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 1 A_1995 TRUE 18 &lt;dbl [2]&gt; ## 2 2 B_1996 TRUE 17 &lt;dbl [2]&gt; ## 3 3 C_1995 TRUE 18 &lt;dbl [2]&gt; ## 4 4 D_1987 TRUE 26 &lt;dbl [2]&gt; ## 5 5 E_1996 TRUE 17 &lt;dbl [2]&gt; ## 6 6 F_1997 TRUE 16 &lt;dbl [2]&gt; ## 7 7 G_1992 TRUE 21 &lt;dbl [2]&gt; ## 8 8 H_1992 TRUE 21 &lt;dbl [2]&gt; ## 9 9 I_1994 TRUE 19 &lt;dbl [2]&gt; ## 10 10 J_1983 TRUE 30 &lt;dbl [2]&gt; ## # … with 19 more rows, and 11 more variables: ## # height_median &lt;dbl&gt;, height_range &lt;list&gt;, ## # length &lt;dbl&gt;, length_0.95_HPD &lt;list&gt;, ## # length_median &lt;dbl&gt;, length_range &lt;list&gt;, ## # posterior &lt;dbl&gt;, rate &lt;dbl&gt;, rate_0.95_HPD &lt;list&gt;, ## # rate_median &lt;dbl&gt;, rate_range &lt;list&gt; Since % is not a valid character in names, all the feature names that contain x% will convert to 0.x. For example, length_95%_HPD will be changed to length_0.95_HPD. Not only tree structure but also all the features inferred by BEAST will be stored in the S4 object. These features can be used for tree annotation (Figure ??). 1.3.2.2 Parsing MEGA output Molecular Evolutionary Genetics Analysis (MEGA) software (Kumar, Stecher, and Tamura 2016) supports exporting trees in three distinct formats: Newick, tabular and Nexus. The Newick file can be parsed using the read.tree or read.newick functions. MEGA Nexus file is similar to BEAST Nexus and treeio (Wang et al. 2020) provides read.mega function to parse the tree. file &lt;- system.file(&quot;extdata/MEGA7&quot;, &quot;mtCDNA_timetree.nex&quot;, package = &quot;treeio&quot;) read.mega(file) ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/MEGA7/mtCDNA_timetree.nex&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 7 tips and 6 internal nodes. ## ## Tip labels: ## homo_sapiens, chimpanzee, bonobo, gorilla, ## orangutan, sumatran, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;branch_length&#39;, &#39;data_coverage&#39;, &#39;rate&#39;, &#39;reltime&#39;, &#39;reltime_0.95_CI&#39;, &#39;reltime_stderr&#39;. ## ## # The associated data tibble abstraction: 13 × 9 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip branch_length data_coverage rate ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 homo_… TRUE 0.2379478768… &lt;NA&gt; 1.14… ## 2 2 chimp… TRUE 0.0627635980… &lt;NA&gt; 0.82… ## 3 3 bonobo TRUE 0.0617442197… &lt;NA&gt; 0.80… ## 4 4 goril… TRUE 0.2637897065… &lt;NA&gt; 0.94… ## 5 5 orang… TRUE 0.1528866124… &lt;NA&gt; 1.34… ## 6 6 sumat… TRUE 0.0945753081… &lt;NA&gt; 0.83… ## 7 7 gibbon TRUE 0.7998997331… &lt;NA&gt; 1.00… ## 8 8 &lt;NA&gt; FALSE &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 9 9 &lt;NA&gt; FALSE 0.2106195281… 100% 1.00… ## 10 10 &lt;NA&gt; FALSE 0.2940311129… 100% 0.95… ## 11 11 &lt;NA&gt; FALSE 0.0682392048… 100% 0.96… ## 12 12 &lt;NA&gt; FALSE 0.1065517919… 100% 0.81… ## 13 13 &lt;NA&gt; FALSE 0.4995763327… 100% 1.06… ## # … with 3 more variables: reltime &lt;chr&gt;, ## # reltime_0.95_CI &lt;list&gt;, reltime_stderr &lt;chr&gt; The tabular output contains tree and associated information (divergence time in this example) in a tabular flat text file. The read.mega_tabular function can parse the tree with data simultaneously. file &lt;- system.file(&quot;extdata/MEGA7&quot;, &quot;mtCDNA_timetree_tabular.txt&quot;, package = &quot;treeio&quot;) read.mega_tabular(file) ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/MEGA7/mtCDNA_timetree_tabular.txt&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 7 tips and 6 internal nodes. ## ## Tip labels: ## chimpanzee, bonobo, homo sapiens, gorilla, ## orangutan, sumatran, ... ## Node labels: ## , , demoLabel2, , , ## ## Rooted; no branch lengths. ## ## with the following features available: ## &#39;RelTime&#39;, &#39;CI_Lower&#39;, &#39;CI_Upper&#39;, &#39;Rate&#39;, &#39;Data ## Coverage&#39;. ## ## # The associated data tibble abstraction: 13 × 8 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip RelTime CI_Lower CI_Upper Rate ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 &quot;chimpa… TRUE - - - 0.821 ## 2 2 &quot;bonobo&quot; TRUE - - - 0.808 ## 3 3 &quot;homo s… TRUE - - - 1.15 ## 4 4 &quot;gorill… TRUE - - - 0.950 ## 5 5 &quot;orangu… TRUE - - - 1.35 ## 6 6 &quot;sumatr… TRUE - - - 0.834 ## 7 7 &quot;gibbon&quot; TRUE - - - 1.01 ## 8 8 &quot;&quot; FALSE 0.8064… - - 1.01 ## 9 9 &quot;&quot; FALSE 0.5940… 0.439042 0.749109 1.01 ## 10 10 &quot;demoLa… FALSE 0.2822… 0.200617 0.363958 0.958 ## 11 11 &quot;&quot; FALSE 0.2105… 0.138713 0.282458 0.967 ## 12 12 &quot;&quot; FALSE 0.0776… 0.045061 0.110260 0.815 ## 13 13 &quot;&quot; FALSE 0.1152… 0.076326 0.154178 1.06 ## # … with 1 more variable: Data Coverage &lt;chr&gt; 1.3.2.3 Parsing MrBayes output The Nexus file generated by MrBayes is BEAST compatible. The treeio package provides the read.mrbayes() which internally calls read.beast() to parse MrBayes outputs. file &lt;- system.file(&quot;extdata/MrBayes&quot;, &quot;Gq_nxs.tre&quot;, package=&quot;treeio&quot;) read.mrbayes(file) ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/MrBayes/Gq_nxs.tre&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 12 tips and 10 internal nodes. ## ## Tip labels: ## B_h, B_s, G_d, G_k, G_q, G_s, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;length_0.95HPD&#39;, &#39;length_mean&#39;, &#39;length_median&#39;, &#39;prob&#39;, &#39;prob_range&#39;, &#39;prob_stddev&#39;, &#39;prob_percent&#39;, &#39;prob+-sd&#39;. ## ## # The associated data tibble abstraction: 22 × 11 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip length_0.95HPD length_mean ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 B_h TRUE &lt;dbl [2]&gt; 0.143466740213549 ## 2 2 B_s TRUE &lt;dbl [2]&gt; 0.192505437461966 ## 3 3 G_d TRUE &lt;dbl [2]&gt; 0.0547261328447764 ## 4 4 G_k TRUE &lt;dbl [2]&gt; 0.0628571252612805 ## 5 5 G_q TRUE &lt;dbl [2]&gt; 0.0632261126188735 ## 6 6 G_s TRUE &lt;dbl [2]&gt; 0.0105788053828403 ## 7 7 G_t TRUE &lt;dbl [2]&gt; 0.00726860545932313 ## 8 8 M_s TRUE &lt;dbl [2]&gt; 0.295027222515593 ## 9 9 N_m TRUE &lt;dbl [2]&gt; 0.227792481371376 ## 10 10 P_h TRUE &lt;dbl [2]&gt; 0.22505344991402 ## # … with 12 more rows, and 6 more variables: ## # length_median &lt;chr&gt;, prob &lt;chr&gt;, ## # prob_range &lt;list&gt;, prob_stddev &lt;chr&gt;, ## # prob_percent &lt;chr&gt;, prob+-sd &lt;chr&gt; 1.3.2.4 Parsing PAML output Phylogenetic Analysis by Maximum Likelihood (PAML) is a package of tools for phylogenetic analyses of DNA and protein sequences using maximum likelihood. Tree search algorithms are implemented in BASEML and CODEML. The read.paml_rst() function provided in treeio can parse rst file from BASEML and CODEML. The only difference is the space in the sequences. For BASEML, each ten bases are separated by one space, while for CODEML, each three bases (triplet) are separated by one space. brstfile &lt;- system.file(&quot;extdata/PAML_Baseml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) brst &lt;- read.paml_rst(brstfile) brst ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Baseml/rst&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. ## ## # The associated data tibble abstraction: 28 × 5 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip subs AA_subs ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 A TRUE C214T / G294T /… &quot;R262K / K603R&quot; ## 2 2 B TRUE C222T / G555A /… &quot;R262K&quot; ## 3 3 C TRUE A204G / C222T /… &quot;N272S / I354T&quot; ## 4 4 D TRUE A111G / A168G /… &quot;K104R / F105L /… ## 5 5 E TRUE C174T / G243A /… &quot;T208S / V379I /… ## 6 6 F TRUE T829C / C1353T … &quot;S277P / L549I&quot; ## 7 7 G TRUE A5T / A69G / G1… &quot;E2V / A36S / G9… ## 8 8 H TRUE A112G / C132A /… &quot;I38V / E258D / … ## 9 9 I TRUE T211C / C582T /… &quot;&quot; ## 10 10 J TRUE G295A / A618G /… &quot;G99R&quot; ## # … with 18 more rows Similarly, we can parse the rst file from CODEML. crstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) ## type can be one of &quot;Marginal&quot; or &quot;Joint&quot; crst &lt;- read.paml_rst(crstfile, type = &quot;Joint&quot;) crst ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/rst&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. ## ## # The associated data tibble abstraction: 28 × 5 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip subs AA_subs ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 A TRUE C214T / G294T /… &quot;K603R&quot; ## 2 2 B TRUE C222T / G555A /… &quot;&quot; ## 3 3 C TRUE A204G / C222T /… &quot;N272S / I354T&quot; ## 4 4 D TRUE A111G / A168G /… &quot;K104R / F105L /… ## 5 5 E TRUE C174T / G243A /… &quot;T208S / V379I /… ## 6 6 F TRUE T829C / C1353T … &quot;S277P / L549I&quot; ## 7 7 G TRUE A5T / A69G / G1… &quot;E2V / A36S / G9… ## 8 8 H TRUE A112G / C132A /… &quot;I38V / E258D / … ## 9 9 I TRUE T211C / C582T /… &quot;&quot; ## 10 10 J TRUE G295A / A618G /… &quot;G99R&quot; ## # … with 18 more rows abc CODEML abc Ancestral sequences inferred by BASEML or CODEML via marginal or joint ML reconstruction methods will be stored in the S4 object and mapped to tree nodes. treeio (Wang et al. 2020) will automatically determine the substitutions between the sequences at both ends of each branch. Amino acid substitution will also be determined by translating nucleotide sequences to amino acid sequences. These computed substitutions will also be stored in the S4 object for efficient tree annotation later (Figure ??). CODEML infers selection pressure and estimated dN/dS, dN and dS. These pieces of information are stored in output file mlc, which can be parsed by read.codeml_mlc function. mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc &lt;- read.codeml_mlc(mlcfile) mlc ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. ## ## # The associated data tibble abstraction: 28 × 11 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip t N S dN_vs_dS dN ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 A TRUE 0.01 1515. 633. 0.0646 0.0007 ## 2 2 B TRUE 0.032 1515. 633. 0.0001 0 ## 3 3 C TRUE 0.028 1515. 633. 0.0461 0.0013 ## 4 4 D TRUE 0.082 1515. 633. 0.0385 0.0033 ## 5 5 E TRUE 0.031 1515. 633. 0.0641 0.002 ## 6 6 F TRUE 0.007 1515. 633. 0.298 0.0013 ## 7 7 G TRUE 0.046 1515. 633. 0.162 0.006 ## 8 8 H TRUE 0.021 1515. 633. 0.103 0.002 ## 9 9 I TRUE 0.015 1515. 633. 0.0001 0 ## 10 10 J TRUE 0.014 1515. 633. 0.0457 0.0007 ## # … with 18 more rows, and 3 more variables: dS &lt;dbl&gt;, ## # N_x_dN &lt;dbl&gt;, S_x_dS &lt;dbl&gt; In the previous session, we separately parsed rst and mlc files. However, they can also be parsed together using read.codeml function. ## tree can be one of &quot;rst&quot; or &quot;mlc&quot; to specify ## using tree from which file as base tree in the object ml &lt;- read.codeml(crstfile, mlcfile, tree = &quot;mlc&quot;) ml ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/rst&#39;, ## &#39;/home/ygc/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. ## ## # The associated data tibble abstraction: 28 × 13 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip subs AA_subs t N S ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 A TRUE C214T … &quot;K603R&quot; 0.01 1515. 633. ## 2 2 B TRUE C222T … &quot;&quot; 0.032 1515. 633. ## 3 3 C TRUE A204G … &quot;N272S … 0.028 1515. 633. ## 4 4 D TRUE A111G … &quot;K104R … 0.082 1515. 633. ## 5 5 E TRUE C174T … &quot;T208S … 0.031 1515. 633. ## 6 6 F TRUE T829C … &quot;S277P … 0.007 1515. 633. ## 7 7 G TRUE A5T / … &quot;E2V / … 0.046 1515. 633. ## 8 8 H TRUE A112G … &quot;I38V /… 0.021 1515. 633. ## 9 9 I TRUE T211C … &quot;&quot; 0.015 1515. 633. ## 10 10 J TRUE G295A … &quot;G99R&quot; 0.014 1515. 633. ## # … with 18 more rows, and 5 more variables: ## # dN_vs_dS &lt;dbl&gt;, dN &lt;dbl&gt;, dS &lt;dbl&gt;, N_x_dN &lt;dbl&gt;, ## # S_x_dS &lt;dbl&gt; All the features in both rst and mlc files were imported into a single S4 object and hence are available for further annotation and visualization. For example, we can annotate and display both dN/dS (from mlc file) and amino acid substitutions (derived from rst file) on the same phylogenetic tree (Yu et al. 2017). 1.3.2.5 Parsing HyPhy output Ancestral sequences inferred by HyPhy are stored in the Nexus output file, which contains the tree topology and ancestral sequences. To parse this data file, users can use the read.hyphy.seq function. ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) read.hyphy.seq(ancseq) ## 13 DNA sequences in binary format stored in a list. ## ## All sequences of same length: 2148 ## ## Labels: ## Node1 ## Node2 ## Node3 ## Node4 ## Node5 ## Node12 ## ... ## ## Base composition: ## a c g t ## 0.335 0.208 0.237 0.220 ## (Total: 27.92 kb) To map the sequences on the tree, users should also provide an internal-node-labelled tree. If users want to determine substitution, they need to also provide tip sequences. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) hy ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/HYPHY/labelledtree.tree&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## Node labels: ## Node1, Node2, Node3, Node4, Node5, Node12, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;subs&#39;, &#39;AA_subs&#39;. ## ## # The associated data tibble abstraction: 28 × 5 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip subs AA_subs ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 K TRUE G96A / T279C / … &quot;V387I / I407V /… ## 2 2 N TRUE A126G / A171G /… &quot;H535Y&quot; ## 3 3 D TRUE A111G / A168G /… &quot;K104R / F105L /… ## 4 4 L TRUE G852T / G1020A &quot;&quot; ## 5 5 J TRUE G295A / A618G /… &quot;G99R&quot; ## 6 6 G TRUE A5T / A69G / G1… &quot;E2V / A36S / G9… ## 7 7 C TRUE A204G / C222T /… &quot;N272S / I354T&quot; ## 8 8 E TRUE C174T / G243A /… &quot;T208S / V379I /… ## 9 9 O TRUE C16A / G96A / C… &quot;N96H / N115S / … ## 10 10 H TRUE A112G / C132A /… &quot;I38V / E258D / … ## # … with 18 more rows 1.3.2.6 Parsing r8s output r8s uses parametric, semiparametric and nonparametric methods to relax molecular clock to allow better estimations of divergence times and evolution rates (Sanderson 2003). It outputs three trees in log file, namely TREE, RATO and PHYLO for time tree, rate tree and absolute substitution tree respectively. Time tree is scaled by divergence time, rate tree is scaled by substitution rate and absolute substitution tree is scaled by the absolute number of substitution. After parsing the file, all these three trees are stored in a multiPhylo object (Figure ??). r8s &lt;- read.r8s(system.file(&quot;extdata/r8s&quot;, &quot;H3_r8s_output.log&quot;, package=&quot;treeio&quot;)) r8s ## 3 phylogenetic trees 1.3.2.7 Parsing output of RAxML bootstraping analysis RAxML bootstrapping analysis outputs a Newick tree text that is not standard as it stores bootstrap values inside square brackets after branch lengths. This file usually cannot be parsed by traditional Newick parser, such as ape::read.tree. The function read.raxml can read such file and stored the bootstrap as an additional feature, which can be used to display on the tree or used to color tree branches, etc.. raxml_file &lt;- system.file(&quot;extdata/RAxML&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;) raxml &lt;- read.raxml(raxml_file) raxml ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/RAxML/RAxML_bipartitionsBranchLabels.H3&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 64 tips and 62 internal nodes. ## ## Tip labels: ## A_Hokkaido_M1_2014_H3N2_2014, ## A_Czech_Republic_1_2014_H3N2_2014, ## FJ532080_A_California_09_2008_H3N2_2008, ## EU199359_A_Pennsylvania_05_2007_H3N2_2007, ## EU857080_A_Hong_Kong_CUHK69904_2006_H3N2_2006, ## EU857082_A_Hong_Kong_CUHK7047_2005_H3N2_2005, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;bootstrap&#39;. ## ## # The associated data tibble abstraction: 126 × 4 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip bootstrap ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 1 A_Hokkaido_M1_2014_H3N2_2014 TRUE NA ## 2 2 A_Czech_Republic_1_2014_H3N2_… TRUE NA ## 3 3 FJ532080_A_California_09_2008… TRUE NA ## 4 4 EU199359_A_Pennsylvania_05_20… TRUE NA ## 5 5 EU857080_A_Hong_Kong_CUHK6990… TRUE NA ## 6 6 EU857082_A_Hong_Kong_CUHK7047… TRUE NA ## 7 7 YGSIV1046_Sw_Binh_Duong_03_10… TRUE NA ## 8 8 YGSIV1044_Sw_Binh_Duong_03_08… TRUE NA ## 9 9 YGSIV1522_SW_HK_1071_2012 TRUE NA ## 10 10 YGSIV1534_SW_HK_2454_2012 TRUE NA ## # … with 116 more rows 1.3.2.8 Parsing NHX tree NHX (New Hampshire eXtended) format is an extension of Newick by introducing NHX tags. NHX is commonly used in phylogenetics software, including PHYLDOG (Boussau et al. 2013), RevBayes (Höhna et al. 2014), for storing statistical inferences. The following codes imported an NHX tree with associated data inferred by PHYLDOG (Figure ??A). nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;phyldog.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) nhx ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/NHX/phyldog.nhx&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 16 tips and 15 internal nodes. ## ## Tip labels: ## Prayidae_D27SS7@2825365, Kephyes_ovata@2606431, ## Chuniphyes_multidentata@1277217, ## Apolemia_sp_@1353964, Bargmannia_amoena@263997, ## Bargmannia_elongata@946788, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;Ev&#39;, &#39;ND&#39;, &#39;S&#39;. ## ## # The associated data tibble abstraction: 31 × 6 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip Ev ND S ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Prayidae_D27SS7@28253… TRUE S 0 58 ## 2 2 Kephyes_ovata@2606431 TRUE S 1 69 ## 3 3 Chuniphyes_multidenta… TRUE S 2 70 ## 4 4 Apolemia_sp_@1353964 TRUE S 9 31 ## 5 5 Bargmannia_amoena@263… TRUE S 10 37 ## 6 6 Bargmannia_elongata@9… TRUE S 11 38 ## 7 7 Physonect_sp_@2066767 TRUE S 13 61 ## 8 8 Stephalia_dilata@2960… TRUE S 15 52 ## 9 9 Frillagalma_vityazi@1… TRUE S 16 53 ## 10 10 Resomia_ornicephala@3… TRUE S 17 54 ## # … with 21 more rows 1.3.2.9 Parsing Phylip tree Phylip format contains multiple sequence alignment of taxa in Phylip sequence format with corresponding Newick tree text that was built from taxon sequences. Multiple sequence alignment can be sorted based on the tree structure and displayed at the right hand side of the tree using ggtree (see also the msaplot function and Basic Protocol 5 of (Yu 2020)). phyfile &lt;- system.file(&quot;extdata&quot;, &quot;sample.phy&quot;, package=&quot;treeio&quot;) phylip &lt;- read.phylip(phyfile) phylip ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/sample.phy&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## ## Unrooted; no branch lengths. ## ## None available features. ## # The associated data tibble abstraction: 28 × 3 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 K TRUE ## 2 2 N TRUE ## 3 3 D TRUE ## 4 4 L TRUE ## 5 5 J TRUE ## 6 6 G TRUE ## 7 7 C TRUE ## 8 8 E TRUE ## 9 9 O TRUE ## 10 10 H TRUE ## # … with 18 more rows 1.3.2.10 Parsing EPA and pplacer output EPA (Berger, Krompass, and Stamatakis 2011) and PPLACER (Frederick A. Matsen, Kodner, and Armbrust 2010b) have common output file format, jplace, which can be parsed by read.jplace() function. jpf &lt;- system.file(&quot;extdata/EPA.jplace&quot;, package=&quot;treeio&quot;) jp &lt;- read.jplace(jpf) print(jp) ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/home/ygc/R/library/treeio/extdata/EPA.jplace&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 493 tips and 492 internal nodes. ## ## Tip labels: ## CIR000447A, CIR000479, CIR000078, CIR000083, ## CIR000070, CIR000060, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;nplace&#39;. ## ## # The associated data tibble abstraction: 985 × 4 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip nplace ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 1 CIR000447A TRUE 0 ## 2 2 CIR000479 TRUE 0 ## 3 3 CIR000078 TRUE 1 ## 4 4 CIR000083 TRUE 1 ## 5 5 CIR000070 TRUE 1 ## 6 6 CIR000060 TRUE 1 ## 7 7 CIR000063 TRUE 0 ## 8 8 CIR000051 TRUE 1 ## 9 9 CIR000148 TRUE 0 ## 10 10 CIR000153 TRUE 0 ## # … with 975 more rows The number of evolutionary placement on each branch will be calculated and stored as the nplace feature, which can be mapped to line size and/or color using ggtree (Yu et al. 2017). 1.3.2.11 Parsing jtree format The jtree is a JSON based format that was defined in this treeio package (Wang et al. 2020) to support tree data interchange (see session 3.3). Phylogenetic tree with associated data can be exported to a single jtree file using write.jtree function. The jtree can be easily parsed using any JSON parser. The jtree format contains three keys: tree, data and metadata. The tree value contains tree text extended from Newick tree format by putting the edge number in curly braces after branch length. The data value contains node/branch-specific data, while the metadata value contains additional meta information. jtree_file &lt;- tempfile(fileext = &#39;.jtree&#39;) write.jtree(beast, file = jtree_file) read.jtree(file = jtree_file) ## &#39;treedata&#39; S4 object that stored information ## of ## &#39;/tmp/Rtmp29upZc/file85ba64946179.jtree&#39;. ## ## ...@ phylo: ## ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## K_2013, N_2010, D_1987, L_1980, J_1983, G_1992, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, &#39;length_median&#39;, &#39;length_range&#39;, &#39;rate&#39;, &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;, &#39;height_median&#39;, &#39;posterior&#39;. ## ## # The associated data tibble abstraction: 29 × 16 ## # The &#39;node&#39;, &#39;label&#39; and &#39;isTip&#39; are from the phylo ## tree. ## node label isTip height height_0.95_HPD ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 1 K_2013 TRUE 0 &lt;lgl [1]&gt; ## 2 2 N_2010 TRUE 3 &lt;lgl [1]&gt; ## 3 3 D_1987 TRUE 26 &lt;int [2]&gt; ## 4 4 L_1980 TRUE 33 &lt;int [2]&gt; ## 5 5 J_1983 TRUE 30 &lt;int [2]&gt; ## 6 6 G_1992 TRUE 21 &lt;int [2]&gt; ## 7 7 B_1996 TRUE 17 &lt;int [2]&gt; ## 8 8 A_1995 TRUE 18 &lt;int [2]&gt; ## 9 9 F_1997 TRUE 16 &lt;int [2]&gt; ## 10 10 M_1997 TRUE 16 &lt;int [2]&gt; ## # … with 19 more rows, and 11 more variables: ## # height_range &lt;list&gt;, length &lt;dbl&gt;, ## # length_0.95_HPD &lt;list&gt;, length_median &lt;dbl&gt;, ## # length_range &lt;list&gt;, rate &lt;dbl&gt;, ## # rate_0.95_HPD &lt;list&gt;, rate_median &lt;dbl&gt;, ## # rate_range &lt;list&gt;, height_median &lt;dbl&gt;, ## # posterior &lt;dbl&gt; 1.3.3 Converting other tree-like object to phylo or treedata object To extend the application scopes of treeio, tidytree and ggtree, treeio (Wang et al. 2020) provides several as.phylo and as.treedata methods to convert other tree-like objects, such as phylo4d and pml, to phylo or treedata object. So that users can easily mapping associated data to the tree structure, exporting tree with/without data to a single file, manipulating and visualizing tree with/without data. These convert functions (Table 1.2) create the possibility of using tidytree to process tree using tidy interface and ggtree to visualize tree using grammar of graphic syntax. TABLE 1.2: Conversion of tree-like object to phylo or treedata object Convert function Supported object Description as.phylo ggtree convert ggtree object to phylo object as.phylo igraph convert igraph object (only tree graph supported) to phylo object as.phylo phylo4 convert phylo4 object to phylo object as.phylo pvclust convert pvclust object to phylo object as.phylo treedata convert treedata object to phylo object as.treedata ggtree convert ggtree object to treedata object as.treedata phylo4 convert phylo4 object to treedata object as.treedata phylo4d convert phylo4d object to treedata object as.treedata pml convert pml object to treedata object as.treedata pvclust convert pvclust object to treedata object Here, we used pml object which was defined in the phangorn package, as an example. The pml() function computes the likelihood of a phylogenetic tree given a sequence alignment and a model and the optim.pml() function optimizes different model parameters. The output is a pml object and it can be converted to a treedata object using as.treedata provided by treeio (Wang et al. 2020). The amino acid substitution (ancestral sequence estimated by pml) that stored in the treedata object can be visualized using ggtree as demonstrated in Figure 1.4. library(phangorn) treefile &lt;- system.file(&quot;extdata&quot;, &quot;pa.nwk&quot;, package=&quot;treeio&quot;) tre &lt;- read.tree(treefile) tipseqfile &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) tipseq &lt;- read.phyDat(tipseqfile,format=&quot;fasta&quot;) fit &lt;- pml(tre, tipseq, k=4) fit &lt;- optim.pml(fit, optNni=FALSE, optBf=T, optQ=T, optInv=T, optGamma=T, optEdge=TRUE, optRooted=FALSE, model = &quot;GTR&quot;, control = pml.control(trace =0)) pmltree &lt;- as.treedata(fit) ggtree(pmltree) + geom_text(aes(x=branch, label=AA_subs, vjust=-.5)) FIGURE 1.4: Converting pml object to treedata object. 1.3.4 Getting information from treedata object After the tree was imported, users may want to extract information stored in the treedata object. treeio provides several accessor methods to extract tree structure, features/attributes that stored in the object and their corresponding values. The get.tree or as.phylo methods can convert the treedata object to phylo object which is the fundamental tree object in the R community and many packages work with phylo object. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) # or get.tree as.phylo(beast_tree) ## ## Phylogenetic tree with 76 tips and 75 internal nodes. ## ## Tip labels: ## A/Hokkaido/30-1-a/2013, A/New_York/334/2004, A/New_York/463/2005, A/New_York/452/1999, A/New_York/238/2005, A/New_York/523/1998, ... ## ## Rooted; includes branch lengths. The get.fields method returns a vector of features/attributes stored in the object and associated with the phylogeny. get.fields(beast_tree) ## [1] &quot;height&quot; &quot;height_0.95_HPD&quot; ## [3] &quot;height_median&quot; &quot;height_range&quot; ## [5] &quot;length&quot; &quot;length_0.95_HPD&quot; ## [7] &quot;length_median&quot; &quot;length_range&quot; ## [9] &quot;posterior&quot; &quot;rate&quot; ## [11] &quot;rate_0.95_HPD&quot; &quot;rate_median&quot; ## [13] &quot;rate_range&quot; The get.data method returns a tibble of all the associated data. get.data(beast_tree) ## # A tibble: 151 × 14 ## height height_0.95_HPD height_median height_range ## &lt;dbl&gt; &lt;list&gt; &lt;dbl&gt; &lt;list&gt; ## 1 19 &lt;dbl [2]&gt; 19 &lt;dbl [2]&gt; ## 2 17 &lt;dbl [2]&gt; 17 &lt;dbl [2]&gt; ## 3 14 &lt;dbl [2]&gt; 14 &lt;dbl [2]&gt; ## 4 12 &lt;dbl [2]&gt; 12 &lt;dbl [2]&gt; ## 5 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; ## 6 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; ## 7 10 &lt;dbl [2]&gt; 10 &lt;dbl [2]&gt; ## 8 10.8 &lt;dbl [2]&gt; 10.8 &lt;dbl [2]&gt; ## 9 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; ## 10 9 &lt;dbl [2]&gt; 9 &lt;dbl [2]&gt; ## # … with 141 more rows, and 10 more variables: ## # length &lt;dbl&gt;, length_0.95_HPD &lt;list&gt;, ## # length_median &lt;dbl&gt;, length_range &lt;list&gt;, ## # posterior &lt;dbl&gt;, rate &lt;dbl&gt;, rate_0.95_HPD &lt;list&gt;, ## # rate_median &lt;dbl&gt;, rate_range &lt;list&gt;, node &lt;int&gt; If users are only interested in a subset of the features/attributes return by get.fields, they can extract the information from the output of get.data or directly subset the data by [ or [[. beast_tree[, c(&quot;node&quot;, &quot;height&quot;)] ## # A tibble: 151 × 2 ## node height ## &lt;int&gt; &lt;dbl&gt; ## 1 10 19 ## 2 9 17 ## 3 36 14 ## 4 31 12 ## 5 29 9 ## 6 28 10 ## 7 39 10 ## 8 90 10.8 ## 9 16 9 ## 10 2 9 ## # … with 141 more rows head(beast_tree[[&quot;height_median&quot;]]) ## height_median1 height_median2 height_median3 ## 19 17 14 ## height_median4 height_median5 height_median6 ## 12 9 10 1.4 Summary Software tools for inferring molecular evolution (e.g., ancestral states, molecular dating and selection pressure, etc.) are proliferating, but there is no single data format that is used by all different programs and capable to store different types of phylogenetic data. Most of the software packages have their own unique output formats and these formats are not compatible with each other. Parsing software outputs is challenging, which restricts the joint analysis using different tools. The treeio (Wang et al. 2020) provides a set of functions (Table 1.1) for parsing various types of phylogenetic data files and a set of converter (Table 1.2) to convert tree-like object to phylo or treedata object. These phylogenetic data can be integrated together that allows further exploration and comparison. To date, most software tools in the field of molecular evolution are isolated and often not fully compatible with each other’s input and output files. These software tools are designed to do their own analysis and the outputs are often not readable in other software. No tools have been designed to unify the inference data from different analysis programs. Efficient incorporation of data from different inference methods can enhance the comparison and understanding of the study target, which may help discover new systematic patterns and generate new hypotheses. As phylogenetic trees are growing in their application to identify patterns in an evolutionary context, more different disciplines are employing phylogenetic trees in their research. For example, spatial ecologists may map the geographical positions of the organisms to their phylogenetic trees to understand the biogeography of the species (Schön et al. 2015); disease epidemiologists may incorporate the pathogen sampling time and locations into the phylogenetic analysis to infer the disease transmission dynamics in spatiotemporal space (He et al. 2013); microbiologists may determine the pathogenicity of different pathogen strains and map them into their phylogenetic trees to identify the genetic determinants of the pathogenicity (Bosi et al. 2016); genomic scientists may use the phylogenetic trees to help taxonomically classify their metagenomic sequence data (Gupta and Sharma 2015). A robust tool such as treeio to import and map different types of data into the phylogenetic tree is important to facilitate these phylogenetics-related research, or a.k.a ‘phylodynamics.’ Such tools could also help integrate different metadata (time, geography, genotype, epidemiological information) and analysis results (selective pressure, evolutionary rates) at the highest level and provide a comprehensive understanding of the study organisms. In the field of influenza research, there have been such attempts of studying phylodynamics of the influenza virus by mapping different meta-data and analysis results on the same phylogenetic tree and evolutionary time scale (Lam et al. 2015). References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
